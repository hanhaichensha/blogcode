{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1},{"_id":"themes/landscape/source/js/jquery2.0.3.min.js","path":"js/jquery2.0.3.min.js","modified":1},{"_id":"themes/landscape/source/js/jquery.min.map","path":"js/jquery.min.map","modified":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/landscape/source/css/images/favicon.jpg","path":"css/images/favicon.jpg","modified":1},{"_id":"themes/landscape/source/css/images/banner_bak.jpg","path":"css/images/banner_bak.jpg","modified":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1},{"_id":"themes/landscape/source/css/font.css","path":"css/font.css","modified":1}],"Cache":[{"_id":"source/_drafts/Linux服务器安全.md","shasum":"6cb832a115651b2d1e82c0d40a72a2f47f0ce1ff","modified":1458704585141},{"_id":"source/_drafts/Web服务器安全策略.md","shasum":"fba6c16eb53759e79d3f39b093972ce99968c25e","modified":1448857214141},{"_id":"source/_posts/C-11特性与应用（三）.md","shasum":"0504b86ed82e6c6f9f78297a33c0509e72153125","modified":1470735234570},{"_id":"source/_posts/C-11特性与应用（二）.md","shasum":"473da51df27e1808a4396e22073c5e42c26ea29e","modified":1470296405791},{"_id":"source/_posts/Github个人静态博客的搭建.md","shasum":"d9b3334b7f8f09a844e94ab47c5d11555e2a5579","modified":1468463517746},{"_id":"source/_drafts/《中国互联网地下产业链分析白皮书》阅读笔记.md","shasum":"1dcadce4db4fa565e835de9c218657e506eb6f14","modified":1467464412923},{"_id":"source/_posts/RSA系类（一）：辗转相除法/图一.png","shasum":"381bde105287bdda205a1e096fb7ef5c9cb16e73","modified":1468393023433},{"_id":"source/_posts/C-11特性与应用（一）：C-11语言特性.md","shasum":"3355ce6a6cee355fe5cccabc3d5348d7dc12f4f7","modified":1470296417167},{"_id":"source/_posts/RSA系类（三）：从物不知数到中国剩余定理和费马小定理.md","shasum":"e6557c6e0889218c92431f9148c41f21c38a6ac9","modified":1468464443049},{"_id":"source/_posts/C-11并发编程（一）：你好，并发世界.md","shasum":"0cee7a00a279dfb402520513fcc10e7c35517fb3","modified":1470023501363},{"_id":"source/_posts/RSA系类（一）：辗转相除法.md","shasum":"2069ba6e617a0476d2a085117d8a6185cd691779","modified":1468393888059},{"_id":"source/_posts/RSA系类（二）：分水问题.md","shasum":"a8482b08e52f36049e6d583296b6d49b78304527","modified":1468399011712},{"_id":"source/_posts/RSA系类（四）：完結篇.md","shasum":"34e9d5025bb4bd6d6b137d326f80d92eff295c45","modified":1468478175717},{"_id":"source/_posts/一个关于递推关系的思考/图三.png","shasum":"d0902d31fa7cc140ab7acc181a294cbd93713980","modified":1468493323649},{"_id":"source/_posts/一个关于递推关系的思考.md","shasum":"7f45f10367665dd47246770ab04f16742035c535","modified":1468493476387},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图一.png","shasum":"e3ed2bfa8e9f75a6608448132ecda618cfb36aa0","modified":1468554654045},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图七.png","shasum":"962ff498f40ec2dce05ed2ff1abe40e3051a925e","modified":1468554654046},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图九.png","shasum":"47de16bd5e15b97b98a7d282596b48130c3882dd","modified":1468554654046},{"_id":"source/_posts/一个关于递推关系的思考/图二.jpg","shasum":"265137d5e126033958b1509ea942ee7419b503d1","modified":1468493323691},{"_id":"source/_posts/一个关于递推关系的思考/图一.jpg","shasum":"59a5a050bd90e6587607db17b84c65f449dde884","modified":1468493323694},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图二十.png","shasum":"1532e6e48f120ebaf2a97b4ceca5dc516b879957","modified":1468554654048},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图二十一.png","shasum":"9ace241a7b64be6e0f0a321b27e1b6198a666dc3","modified":1468554654048},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图八.png","shasum":"7bd6520778c095d82030137a39ba95509cdd749a","modified":1468554654048},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图二十三.png","shasum":"765bfe30dc938d23cea7920e1985f497a5e6e320","modified":1468554654048},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图六.png","shasum":"c4d181b95d000577284ab68e8d6c32390928b684","modified":1468554654049},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十七.png","shasum":"05a6e9940493e468eb71b8a36d7d9006c9ac3cdd","modified":1468554654049},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图五.png","shasum":"05ab1519891c2d0fc01a641e48285a17d9a1d215","modified":1468554654048},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十一.png","shasum":"f923576c81f1106a77bc4a413da690470f46ba38","modified":1468554654049},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十五.png","shasum":"853311d1a1ce40fed21ef6e4b33bb8109b0c6bb8","modified":1468554654049},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十九.png","shasum":"50e408a5e93e3d2964743224865c8c04df02089c","modified":1468554654049},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十六.png","shasum":"e9fbf041e9f864b1fb831a5e06abf06b69f2cb2a","modified":1468554654049},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十四.png","shasum":"74a6edd5a5cf02b3ec214dc9e38e061744f05809","modified":1468554654049},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图四.png","shasum":"5db0ec325d56ef4bbb051d393fb6ae743fe05272","modified":1468554654049},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十二.png","shasum":"2c85ed57ab2f07ae05c454a45099f392d2e309de","modified":1468554654049},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”.md","shasum":"dc2624cca2d6a828a74eb5142273fcd1a651b6e4","modified":1468554653985},{"_id":"source/_posts/信息编码随想/图三.png","shasum":"70dabe39bee4b423742bd8d306d4d861cc5c0607","modified":1468575245892},{"_id":"source/_posts/信息编码随想/图一.png","shasum":"0b10d7ce658df2ff2bf51da3af5937c09d1f3812","modified":1468575245879},{"_id":"source/_posts/信息编码随想/图五.png","shasum":"b2b130933c1fc3f5fc89006c7579822aa4fda5a8","modified":1468575245893},{"_id":"source/_posts/信息编码随想/图四.png","shasum":"20de3d1583d02e643a85733d8cf5b00777a716f8","modified":1468575245893},{"_id":"source/_posts/信息编码随想/图二.png","shasum":"7252f0fb41ece9b0ccf18c6df9d8b7581e7e7b55","modified":1468575245892},{"_id":"source/_posts/信息编码随想.md","shasum":"9ad8fa7dbd71a7b57fa26c898e71780aa019623b","modified":1468575245834},{"_id":"source/_posts/初识Netfilter-iptables/Netfilter与iptabales关系.png","shasum":"f07b793296e3a9f13dbef4e65d63576e2eee07b6","modified":1458910194406},{"_id":"source/_posts/初识Netfilter-iptables/iptables策略组成.png","shasum":"41dd95105f2e09ef801d3e8dc1a76efa3ab25598","modified":1458910194407},{"_id":"source/_posts/初识Netfilter-iptables/模拟网络.png","shasum":"c3946cc30033e971acfb3313778775b0df8f4e76","modified":1458910194407},{"_id":"source/_posts/初识Netfilter-iptables/虚拟机网络配置1.png","shasum":"a385762c42f4a30f350841e2e8259ec88c905e95","modified":1458910194407},{"_id":"source/_posts/初识Netfilter-iptables/访问LM服务1.png","shasum":"22971485ee334d7de37727f4acb19101955ea9a1","modified":1458910194407},{"_id":"source/_posts/初识Netfilter-iptables/访问LM服务2.png","shasum":"428e539065338f67ebe089eb66de058ce9a14ec9","modified":1458910194407},{"_id":"source/_posts/初识Netfilter-iptables/设置默认网关.png","shasum":"5dcbdddc7dba1175e69daa03e124aa8317ba91fd","modified":1458910194407},{"_id":"source/_posts/别样的整数表示和运算.md","shasum":"a7208dab04dc74f9d9aa851dc24f04ee08ae3916","modified":1465178783044},{"_id":"source/_posts/别样的进制/图一.png","shasum":"97b2e679bfdc70b5dfeb0aeca1ac355042c3d9ca","modified":1465178783063},{"_id":"source/_posts/初识Netfilter-iptables/iptables数据包流程.png","shasum":"0f1d291a330ce1abd680a98e3322e11f8877c7de","modified":1458910194406},{"_id":"source/_posts/别样的进制/图二.png","shasum":"d7c110d1db9abbc7b4362a0064a811725fe734c6","modified":1465178783087},{"_id":"source/_posts/别样的进制/图四.png","shasum":"2c89c86ee2e1e9c287570520ef45be8c43c44c53","modified":1465178783088},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十八.png","shasum":"84e5764fc3c03d58a6aa6eb1279df5be655a6201","modified":1468554654049},{"_id":"source/_posts/别样的进制/图三.png","shasum":"60155bc7fe76d65eee31bddd787d6ef20b0e67a9","modified":1465180630203},{"_id":"source/_posts/单击微信文章进入原文的方法/fengmian.jpg","shasum":"36161bbb799c3bc08067d14c758602b8f6b7ac8b","modified":1458704585179},{"_id":"source/_posts/初识Netfilter-iptables.md","shasum":"e7ded4ac662da8e24bfd6b3c8954998390962e3f","modified":1458910194338},{"_id":"source/_posts/别样的进制.md","shasum":"9f16b2abf27c005974f201f12ee77db670c683a1","modified":1465179528458},{"_id":"source/_posts/博客名字的由来.md","shasum":"245d79db7029045512487dfcfb7d842f2baf9774","modified":1468393437358},{"_id":"source/_posts/常见面试题复习：字符串-一/图一.png","shasum":"b5b5f9b4b2488e327817462bcd3b36b703e210b7","modified":1469087465568},{"_id":"source/_posts/常见面试题复习：字符串-一/图三.png","shasum":"f1c61ac3cb490a0c9a3e8cef04830fc2654d59ad","modified":1469087465569},{"_id":"source/_posts/单击微信文章进入原文的方法/图六.png","shasum":"d6df76b9deaa263ff7028157dab5371ec3dc2ace","modified":1458704585195},{"_id":"source/_posts/单击微信文章进入原文的方法.md","shasum":"218ffed71c3fc5ff67b3e52d48a13f1922a90c48","modified":1458704585142},{"_id":"source/_posts/常见面试题复习：字符串-一/图四.png","shasum":"8b71977df74b47c0304259cc4d8ebd5c5297846c","modified":1469087465572},{"_id":"source/_posts/常见面试题复习：字符串-一/图二.png","shasum":"a9372228173f54206d1f13d77951a4516903f572","modified":1469087465570},{"_id":"source/_posts/常见面试题复习：字符串-一.md","shasum":"6343d20c03797624879a57e342332ba6b18fcc3b","modified":1469087465566},{"_id":"source/_posts/常见面试题复习：字符串-二/图一.jpg","shasum":"3c8ad88cb45e16b5d195c1ffbd9fa6de84d8b6d4","modified":1469087465574},{"_id":"source/_posts/手电筒的启示/图三.png","shasum":"ab5996b42a586f59ad11fd3c70153d0302a8b8b9","modified":1468575284108},{"_id":"source/_posts/常见面试题复习：字符串-二.md","shasum":"b04eb4bd407de0759489b7dcf5a77ec0e9a8b284","modified":1469087465573},{"_id":"source/_posts/手电筒的启示/图一.png","shasum":"4f9ec25897e9155fa975391031beb6a45369cbc6","modified":1468575284107},{"_id":"source/_posts/手电筒的启示.md","shasum":"6c7f311dfb5bf87f901a11e27429b7c446b95906","modified":1468575284060},{"_id":"source/_posts/计算机网络概述/图三.png","shasum":"c078fb552b5f969d3156d5365177d26ceae74fd7","modified":1448588936081},{"_id":"source/_posts/手电筒的启示/图二.png","shasum":"366f162d06b389f521e26a406edd5a2eebab0345","modified":1468575284108},{"_id":"source/_posts/手电筒的启示/图四.png","shasum":"39a3cee8180ed7aa8d159b6f82920dd15833fd2f","modified":1468575284108},{"_id":"source/_posts/手电筒的启示/图五.png","shasum":"afec8f40cb279e9673c5467b2805d24b90ae0238","modified":1468575284108},{"_id":"source/_posts/计算机网络概述/图四.png","shasum":"80a6ff3d993cb7f5aba1c3a3223cc4a57f69ac0d","modified":1448588936162},{"_id":"source/_posts/计算机网络概述.md","shasum":"a170460d77327ba2e9538874fd368c4b5c658e69","modified":1448588936040},{"_id":"source/_posts/计算机网络概述/图二.png","shasum":"1a56f33a1fa563de33744b2ac4814bbb8bde1e26","modified":1448588936099},{"_id":"source/_posts/读书笔记：Ruby篇（一）.md","shasum":"ba4c9305074d9b01af7e17d6d5458ec294837c71","modified":1468575314708},{"_id":"source/_posts/读书笔记：Ruby篇（三）/图三.jpg","shasum":"9cba461ebd5b185954cdbe0505ebeb62fd992798","modified":1468580067928},{"_id":"source/_posts/读书笔记：Ruby篇（三）.md","shasum":"88c29d2e7895fada86f2799ee06b9d7f3c9729c0","modified":1468580067844},{"_id":"source/_posts/读书笔记：Ruby篇（三）/图一.jpg","shasum":"7ae436cee4dae0b0fa2aacb9ff31201c0df84170","modified":1468580067918},{"_id":"source/_posts/读书笔记：Ruby篇（二）/图一.png","shasum":"4c66174e3ccaa6112037efc884c22e04f2d28933","modified":1468578297739},{"_id":"source/_posts/读书笔记：Ruby篇（三）/图二.jpg","shasum":"4c931fe1df7999e387caf9739b4a10055f235726","modified":1468580067942},{"_id":"source/_posts/读书笔记：Ruby篇（二）/图四.png","shasum":"7e8bd104f761866139f6b3e89ad97a2c5107d945","modified":1468578297740},{"_id":"source/_posts/读书笔记：Ruby篇（二）/图二.png","shasum":"d22110e01266aa7f66483357efb7bafd84f4f5af","modified":1468578297740},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图三.png","shasum":"8aa22c73b852c2084c3abea3867ed2b9e055fbcc","modified":1468554654050},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图二十二.png","shasum":"84962a339839bf3b21ab21a88dc9c4eda05b362f","modified":1468554654050},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图二.png","shasum":"84284d57c44d41844e22aaba33c1df3f4360ef44","modified":1468554654050},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十三.png","shasum":"4f8364c2c226a84a25f698b60b86f9db360121bc","modified":1468554654050},{"_id":"source/_posts/信息编码随想/图六.png","shasum":"1cc34e417cfcc5b473b92363fda78340c93d9eab","modified":1468575245893},{"_id":"source/_posts/初识Netfilter-iptables/Netfilter-packet-flow.svg","shasum":"b93652bb519e2f632b0a459461d2779a588e92b4","modified":1458910194407},{"_id":"source/_posts/初识Netfilter-iptables/虚拟机网络配置2.png","shasum":"f583ddd58d1730c961bd6051a5d8f681a8fe6864","modified":1458910194408},{"_id":"source/_posts/初识Netfilter-iptables/虚拟机网络配置3.png","shasum":"ff911d09c4bd2c3574f62bff5a7ac738901bd6fe","modified":1458910194408},{"_id":"source/_posts/初识Netfilter-iptables/隐含匹配.jpg","shasum":"c1c7fdeecdb754d0cb6d5cab759add00d8bea3e4","modified":1458910194408},{"_id":"source/_posts/单击微信文章进入原文的方法/图一.png","shasum":"ec4bc73ec7abfd302e24988929dc0eba297e2af6","modified":1458704585183},{"_id":"source/_posts/单击微信文章进入原文的方法/图三.png","shasum":"ada815093d7bd9c95778dd75500ed6627aa1becf","modified":1458704585186},{"_id":"source/_posts/单击微信文章进入原文的方法/图二.png","shasum":"df77cfd2e9f7546cdd1b15b05e65ad7b8432906d","modified":1458704585190},{"_id":"source/_posts/单击微信文章进入原文的方法/图四.png","shasum":"c2af20e2c69405284ed6cf92a703332cba06670e","modified":1458704585198},{"_id":"source/_posts/常见面试题复习：字符串-一/图五.png","shasum":"9e15be72ef4fe67a5df71a2dea1f45c095da0950","modified":1469087465571},{"_id":"source/_posts/读书笔记：Ruby篇（二）.md","shasum":"2e67a21682c73478dc42348518981a9679a62f6f","modified":1468578297683},{"_id":"source/_posts/读书笔记：Ruby篇（二）/图三.jpg","shasum":"b058af036c5c6c4b0b22fe706faaac420933a8cb","modified":1468578297740},{"_id":"source/_posts/读书笔记：Ruby篇（二）/图五.jpg","shasum":"1abf0897f345e8ef7ffd23f469b1d4e167b6690a","modified":1468578297748},{"_id":"source/_posts/初识Netfilter-iptables/Netfilter-packet-flow.png","shasum":"62e35afd4e37c919b903dfb5cea619a84e9a1ba8","modified":1458910194408},{"_id":"source/_posts/单击微信文章进入原文的方法/图五.png","shasum":"77c13f3006a540178052e120289bdc749294c916","modified":1458704585194},{"_id":"source/_posts/计算机网络概述/图五.png","shasum":"667b20c74023428436cdaa7b26f6d26a65cad7f1","modified":1448588936155},{"_id":"themes/landscape/Gruntfile.js","shasum":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1448423282620},{"_id":"themes/landscape/_config.yml","shasum":"4fcba4a86ecceda026fc3c49ee4446beedcfb79e","modified":1448423282621},{"_id":"themes/landscape/LICENSE","shasum":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1448423282621},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","shasum":"5062c723721d8497eebad372f57092ade45041f4","modified":1448423282622},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","shasum":"58b4c73a2e26fa899157ba89d18ff93e00d41fb6","modified":1448423282622},{"_id":"themes/landscape/layout/_partial/article.ejs","shasum":"01f6615c6ee17969f2adfa78def1fcdc117d9095","modified":1465184168171},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","shasum":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1448423282624},{"_id":"themes/landscape/layout/_partial/head.ejs","shasum":"3df94dc164f4d1bd256fc9049386d489a9da057b","modified":1448423282624},{"_id":"themes/landscape/README.md","shasum":"e7cc82dc79596f36ba05a8139e7d6b2dfc4ae5f9","modified":1448423282621},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","shasum":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1448423282625},{"_id":"themes/landscape/layout/_partial/post/category.ejs","shasum":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1448423282625},{"_id":"themes/landscape/layout/_partial/post/date.ejs","shasum":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1448423282626},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","shasum":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1448423282626},{"_id":"themes/landscape/layout/_partial/archive.ejs","shasum":"943ac1aa6281e74fdd626a5549dd8c65646ff5ff","modified":1468562405798},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","shasum":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1448423282627},{"_id":"themes/landscape/layout/_partial/post/title.ejs","shasum":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1448423282627},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","shasum":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1448423282627},{"_id":"themes/landscape/layout/_widget/archive.ejs","shasum":"88e191e3d14541299ed03b9a45be70974df51143","modified":1448423282628},{"_id":"themes/landscape/layout/_widget/category.ejs","shasum":"4d3f92e3cd652cb69d71e40d1c64b2369922ca26","modified":1448423282628},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","shasum":"d6591c745402fbc600e682830a343f732e336e4f","modified":1448423282628},{"_id":"themes/landscape/layout/_widget/tag.ejs","shasum":"7ba10fbd17b83b9b89eaea99bb78158d318c6d75","modified":1448423282628},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","shasum":"9028129dd2e56813197d0c38db5df8110aaeaabb","modified":1448423282629},{"_id":"themes/landscape/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1448423282629},{"_id":"themes/landscape/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1448423282629},{"_id":"themes/landscape/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1448423282629},{"_id":"themes/landscape/layout/layout.ejs","shasum":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1448423282630},{"_id":"themes/landscape/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1448423282630},{"_id":"themes/landscape/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1448423282631},{"_id":"themes/landscape/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1448423282631},{"_id":"themes/landscape/package.json","shasum":"d07f326588fef82f1d23ae3101c9ddfff34c132f","modified":1448423282631},{"_id":"themes/landscape/scripts/fancybox.js","shasum":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1448423282632},{"_id":"themes/landscape/source/css/_extend.styl","shasum":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1448423282632},{"_id":"themes/landscape/source/css/_partial/archive.styl","shasum":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1448423282633},{"_id":"themes/landscape/source/css/_partial/comment.styl","shasum":"2834870661e490775f9154d71638bfdc72e640a6","modified":1448423282633},{"_id":"themes/landscape/source/css/_partial/footer.styl","shasum":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1448423282634},{"_id":"themes/landscape/layout/_partial/header.ejs","shasum":"f158b8b3f2e260c4090718bf7154922f54bac5d1","modified":1448423282625},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","shasum":"eb000d9d8a9ebd9087046fa019abe1cddae8fd9c","modified":1448423282626},{"_id":"themes/landscape/source/css/_partial/mobile.styl","shasum":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1448423282635},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","shasum":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1448423282635},{"_id":"themes/landscape/source/css/_partial/header.styl","shasum":"8a737f61e78bf488642a85627d8fc66ef4a50acd","modified":1448423282634},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","shasum":"f6023861b2fbd858946e2108438b5f8f17586179","modified":1448423282635},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","shasum":"8d971a00e644a600179b04815688d188f094012e","modified":1448423282636},{"_id":"themes/landscape/source/css/_partial/highlight.styl","shasum":"05da1b8f4859761dc60bca40b8682f167e350742","modified":1448423282635},{"_id":"themes/landscape/source/css/_partial/article.styl","shasum":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1448423282633},{"_id":"themes/landscape/source/css/_util/grid.styl","shasum":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1448423282636},{"_id":"themes/landscape/source/css/_variables.styl","shasum":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1448423282637},{"_id":"themes/landscape/source/css/_util/mixin.styl","shasum":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1448423282636},{"_id":"themes/landscape/source/css/font.css","shasum":"7b737ba95d532c65173e14cc5269b9a1ac638e2d","modified":1448423282637},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1448423282639},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1448423282638},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1448423282642},{"_id":"themes/landscape/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1448423282647},{"_id":"themes/landscape/source/css/images/favicon.jpg","shasum":"1ed9999d5f43b9d5873ce9fe72263eb271fae9d3","modified":1448423282646},{"_id":"themes/landscape/source/css/style.styl","shasum":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1448423282647},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1448423282647},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1448423282648},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1448423282649},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1448423282649},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1448423282650},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1448423282651},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1448423282651},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1448423282652},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","shasum":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1448423282652},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","shasum":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1448423282653},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","shasum":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1448423282653},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1448423282649},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"6394c48092085788a8c0ef72670b0652006231a1","modified":1448423282650},{"_id":"themes/landscape/layout/_partial/footer.ejs","shasum":"29849f7d8f34acf80fc1a2bfd11a935581c32e3d","modified":1448423282624},{"_id":"source/_posts/初识Netfilter-iptables/显式匹配.jpg","shasum":"ab728363b3fb1277620df778aa34d89e52a21a2c","modified":1458910194408},{"_id":"source/_posts/计算机网络概述/图一.jpg","shasum":"6fe0234cfaaea8b8665cb48b5cf36e61e60410cb","modified":1448588936043},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1448423282641},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1448423282651},{"_id":"themes/landscape/source/js/jquery.min.map","shasum":"83c9ec8ebb61ee9916f624a1e75ba47b0f1b0ec4","modified":1448423282655},{"_id":"themes/landscape/source/css/images/banner.jpg","shasum":"813f6072ce732ad698e9979bfb3a3dcd1e4b0d0a","modified":1448423282643},{"_id":"themes/landscape/source/js/script.js","shasum":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1465183428834},{"_id":"themes/landscape/source/js/jquery2.0.3.min.js","shasum":"745ab5d6e434cf8d321779da3c527b6d301e2b50","modified":1448423282656},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","shasum":"a275426daefd3716c53561fad121d258a7f05b47","modified":1448423282640},{"_id":"themes/landscape/source/css/images/banner_bak.jpg","shasum":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1448423282646},{"_id":"source/_posts/单击微信文章进入原文的方法/六一儿童节.png","shasum":"de9f1d926ac19e6c8b4c0076e7a1fb212d65cc92","modified":1464677830092},{"_id":"public/js/script.js","modified":1470735265718,"shasum":"2876e0b19ce557fca38d7c6f49ca55922ab666a1"},{"_id":"public/js/jquery2.0.3.min.js","modified":1470735265724,"shasum":"a6eedf84389e1bc9f757bc2d19538f8c8d1cae9d"},{"_id":"public/js/jquery.min.map","modified":1470735265732,"shasum":"83c9ec8ebb61ee9916f624a1e75ba47b0f1b0ec4"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1470735265736,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1470735265738,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1470735265741,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1470735265743,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1470735265747,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1470735265750,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1470735265754,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1470735265756,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1470735265759,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1470735265761,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1470735265766,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1470735265768,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1470735265771,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1470735265773,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1470735265775,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1470735266495,"shasum":"67182948fec42b5b89a68a17bea4ada6fcef79a0"},{"_id":"public/css/images/favicon.jpg","modified":1470735266662,"shasum":"1ed9999d5f43b9d5873ce9fe72263eb271fae9d3"},{"_id":"public/css/images/banner_bak.jpg","modified":1470735266758,"shasum":"843d9d47bf2b7b75495db11b3d765efaaae442a9"},{"_id":"public/css/images/banner.jpg","modified":1470735266780,"shasum":"813f6072ce732ad698e9979bfb3a3dcd1e4b0d0a"},{"_id":"public/css/fonts/fontawesome-webfont.woff","modified":1470735266792,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/css/fonts/fontawesome-webfont.ttf","modified":1470735266796,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/css/fonts/fontawesome-webfont.svg","modified":1470735266800,"shasum":"a275426daefd3716c53561fad121d258a7f05b47"},{"_id":"public/css/fonts/fontawesome-webfont.eot","modified":1470735266802,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/css/fonts/FontAwesome.otf","modified":1470735266804,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/css/font.css","modified":1470735266807,"shasum":"d2c3b48df4256b730b9dcb4b932550544cd83243"},{"_id":"public/2015/07/26/读书笔记：Ruby篇（二）/图一.png","modified":1470735266810,"shasum":"4c66174e3ccaa6112037efc884c22e04f2d28933"},{"_id":"public/2015/07/26/读书笔记：Ruby篇（二）/图三.jpg","modified":1470735266813,"shasum":"b058af036c5c6c4b0b22fe706faaac420933a8cb"},{"_id":"public/2015/07/26/读书笔记：Ruby篇（二）/图二.png","modified":1470735266826,"shasum":"d22110e01266aa7f66483357efb7bafd84f4f5af"},{"_id":"public/2015/07/26/读书笔记：Ruby篇（二）/图五.jpg","modified":1470735266830,"shasum":"1abf0897f345e8ef7ffd23f469b1d4e167b6690a"},{"_id":"public/2015/07/26/读书笔记：Ruby篇（二）/图四.png","modified":1470735266842,"shasum":"7e8bd104f761866139f6b3e89ad97a2c5107d945"},{"_id":"public/2015/07/29/读书笔记：Ruby篇（三）/图一.jpg","modified":1470735266844,"shasum":"7ae436cee4dae0b0fa2aacb9ff31201c0df84170"},{"_id":"public/2015/07/29/读书笔记：Ruby篇（三）/图三.jpg","modified":1470735266856,"shasum":"9cba461ebd5b185954cdbe0505ebeb62fd992798"},{"_id":"public/2015/07/29/读书笔记：Ruby篇（三）/图二.jpg","modified":1470735266869,"shasum":"4c931fe1df7999e387caf9739b4a10055f235726"},{"_id":"public/2015/11/26/计算机网络概述/图一.jpg","modified":1470735266884,"shasum":"6fe0234cfaaea8b8665cb48b5cf36e61e60410cb"},{"_id":"public/2015/11/26/计算机网络概述/图三.png","modified":1470735266897,"shasum":"c078fb552b5f969d3156d5365177d26ceae74fd7"},{"_id":"public/2015/11/26/计算机网络概述/图二.png","modified":1470735266899,"shasum":"1a56f33a1fa563de33744b2ac4814bbb8bde1e26"},{"_id":"public/2015/11/26/计算机网络概述/图五.png","modified":1470735266902,"shasum":"667b20c74023428436cdaa7b26f6d26a65cad7f1"},{"_id":"public/2015/11/26/计算机网络概述/图四.png","modified":1470735266904,"shasum":"80a6ff3d993cb7f5aba1c3a3223cc4a57f69ac0d"},{"_id":"public/2015/03/12/手电筒的启示/图一.png","modified":1470735266906,"shasum":"4f9ec25897e9155fa975391031beb6a45369cbc6"},{"_id":"public/2015/03/12/手电筒的启示/图三.png","modified":1470735266908,"shasum":"ab5996b42a586f59ad11fd3c70153d0302a8b8b9"},{"_id":"public/2015/03/12/手电筒的启示/图二.png","modified":1470735266910,"shasum":"366f162d06b389f521e26a406edd5a2eebab0345"},{"_id":"public/2015/03/12/手电筒的启示/图五.png","modified":1470735266911,"shasum":"afec8f40cb279e9673c5467b2805d24b90ae0238"},{"_id":"public/2015/03/12/手电筒的启示/图四.png","modified":1470735266913,"shasum":"39a3cee8180ed7aa8d159b6f82920dd15833fd2f"},{"_id":"public/2015/09/09/常见面试题复习：字符串-二/图一.jpg","modified":1470735266915,"shasum":"3c8ad88cb45e16b5d195c1ffbd9fa6de84d8b6d4"},{"_id":"public/2015/09/08/常见面试题复习：字符串-一/图一.png","modified":1470735266927,"shasum":"b5b5f9b4b2488e327817462bcd3b36b703e210b7"},{"_id":"public/2015/09/08/常见面试题复习：字符串-一/图三.png","modified":1470735266930,"shasum":"f1c61ac3cb490a0c9a3e8cef04830fc2654d59ad"},{"_id":"public/2015/09/08/常见面试题复习：字符串-一/图二.png","modified":1470735266932,"shasum":"a9372228173f54206d1f13d77951a4516903f572"},{"_id":"public/2015/09/08/常见面试题复习：字符串-一/图五.png","modified":1470735266934,"shasum":"9e15be72ef4fe67a5df71a2dea1f45c095da0950"},{"_id":"public/2015/09/08/常见面试题复习：字符串-一/图四.png","modified":1470735266936,"shasum":"8b71977df74b47c0304259cc4d8ebd5c5297846c"},{"_id":"public/2016/03/06/单击微信文章进入原文的方法/fengmian.jpg","modified":1470735266937,"shasum":"36161bbb799c3bc08067d14c758602b8f6b7ac8b"},{"_id":"public/2016/03/06/单击微信文章进入原文的方法/六一儿童节.png","modified":1470735266953,"shasum":"de9f1d926ac19e6c8b4c0076e7a1fb212d65cc92"},{"_id":"public/2016/03/06/单击微信文章进入原文的方法/图一.png","modified":1470735266958,"shasum":"ec4bc73ec7abfd302e24988929dc0eba297e2af6"},{"_id":"public/2016/03/06/单击微信文章进入原文的方法/图三.png","modified":1470735266971,"shasum":"ada815093d7bd9c95778dd75500ed6627aa1becf"},{"_id":"public/2016/03/06/单击微信文章进入原文的方法/图二.png","modified":1470735266973,"shasum":"df77cfd2e9f7546cdd1b15b05e65ad7b8432906d"},{"_id":"public/2016/03/06/单击微信文章进入原文的方法/图五.png","modified":1470735266976,"shasum":"77c13f3006a540178052e120289bdc749294c916"},{"_id":"public/2016/03/06/单击微信文章进入原文的方法/图六.png","modified":1470735266979,"shasum":"d6df76b9deaa263ff7028157dab5371ec3dc2ace"},{"_id":"public/2016/03/06/单击微信文章进入原文的方法/图四.png","modified":1470735266981,"shasum":"c2af20e2c69405284ed6cf92a703332cba06670e"},{"_id":"public/2016/06/06/别样的进制/图一.png","modified":1470735266983,"shasum":"97b2e679bfdc70b5dfeb0aeca1ac355042c3d9ca"},{"_id":"public/2016/06/06/别样的进制/图三.png","modified":1470735266985,"shasum":"60155bc7fe76d65eee31bddd787d6ef20b0e67a9"},{"_id":"public/2016/06/06/别样的进制/图二.png","modified":1470735266986,"shasum":"d7c110d1db9abbc7b4362a0064a811725fe734c6"},{"_id":"public/2016/06/06/别样的进制/图四.png","modified":1470735266988,"shasum":"2c89c86ee2e1e9c287570520ef45be8c43c44c53"},{"_id":"public/2016/03/25/初识Netfilter-iptables/Netfilter-packet-flow.png","modified":1470735266990,"shasum":"62e35afd4e37c919b903dfb5cea619a84e9a1ba8"},{"_id":"public/2016/03/25/初识Netfilter-iptables/Netfilter-packet-flow.svg","modified":1470735266993,"shasum":"b93652bb519e2f632b0a459461d2779a588e92b4"},{"_id":"public/2016/03/25/初识Netfilter-iptables/Netfilter与iptabales关系.png","modified":1470735266996,"shasum":"f07b793296e3a9f13dbef4e65d63576e2eee07b6"},{"_id":"public/2016/03/25/初识Netfilter-iptables/iptables数据包流程.png","modified":1470735266998,"shasum":"0f1d291a330ce1abd680a98e3322e11f8877c7de"},{"_id":"public/2016/03/25/初识Netfilter-iptables/iptables策略组成.png","modified":1470735267000,"shasum":"41dd95105f2e09ef801d3e8dc1a76efa3ab25598"},{"_id":"public/2016/03/25/初识Netfilter-iptables/显式匹配.jpg","modified":1470735267003,"shasum":"ab728363b3fb1277620df778aa34d89e52a21a2c"},{"_id":"public/2016/03/25/初识Netfilter-iptables/模拟网络.png","modified":1470735267016,"shasum":"c3946cc30033e971acfb3313778775b0df8f4e76"},{"_id":"public/2016/03/25/初识Netfilter-iptables/虚拟机网络配置1.png","modified":1470735267019,"shasum":"a385762c42f4a30f350841e2e8259ec88c905e95"},{"_id":"public/2016/03/25/初识Netfilter-iptables/虚拟机网络配置2.png","modified":1470735267021,"shasum":"f583ddd58d1730c961bd6051a5d8f681a8fe6864"},{"_id":"public/2016/03/25/初识Netfilter-iptables/虚拟机网络配置3.png","modified":1470735267023,"shasum":"ff911d09c4bd2c3574f62bff5a7ac738901bd6fe"},{"_id":"public/2016/03/25/初识Netfilter-iptables/设置默认网关.png","modified":1470735267030,"shasum":"5dcbdddc7dba1175e69daa03e124aa8317ba91fd"},{"_id":"public/2016/03/25/初识Netfilter-iptables/访问LM服务1.png","modified":1470735267038,"shasum":"22971485ee334d7de37727f4acb19101955ea9a1"},{"_id":"public/2016/03/25/初识Netfilter-iptables/访问LM服务2.png","modified":1470735267045,"shasum":"428e539065338f67ebe089eb66de058ce9a14ec9"},{"_id":"public/2016/03/25/初识Netfilter-iptables/隐含匹配.jpg","modified":1470735267049,"shasum":"c1c7fdeecdb754d0cb6d5cab759add00d8bea3e4"},{"_id":"public/2015/03/12/信息编码随想/图一.png","modified":1470735267065,"shasum":"0b10d7ce658df2ff2bf51da3af5937c09d1f3812"},{"_id":"public/2015/03/12/信息编码随想/图三.png","modified":1470735267067,"shasum":"70dabe39bee4b423742bd8d306d4d861cc5c0607"},{"_id":"public/2015/03/12/信息编码随想/图二.png","modified":1470735267069,"shasum":"7252f0fb41ece9b0ccf18c6df9d8b7581e7e7b55"},{"_id":"public/2015/03/12/信息编码随想/图五.png","modified":1470735267071,"shasum":"b2b130933c1fc3f5fc89006c7579822aa4fda5a8"},{"_id":"public/2015/03/12/信息编码随想/图六.png","modified":1470735267073,"shasum":"1cc34e417cfcc5b473b92363fda78340c93d9eab"},{"_id":"public/2015/03/12/信息编码随想/图四.png","modified":1470735267075,"shasum":"20de3d1583d02e643a85733d8cf5b00777a716f8"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图一.png","modified":1470735267077,"shasum":"e3ed2bfa8e9f75a6608448132ecda618cfb36aa0"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图七.png","modified":1470735267079,"shasum":"962ff498f40ec2dce05ed2ff1abe40e3051a925e"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图三.png","modified":1470735267081,"shasum":"8aa22c73b852c2084c3abea3867ed2b9e055fbcc"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图九.png","modified":1470735267085,"shasum":"47de16bd5e15b97b98a7d282596b48130c3882dd"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图二.png","modified":1470735267088,"shasum":"84284d57c44d41844e22aaba33c1df3f4360ef44"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图二十.png","modified":1470735267090,"shasum":"1532e6e48f120ebaf2a97b4ceca5dc516b879957"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图二十一.png","modified":1470735267092,"shasum":"9ace241a7b64be6e0f0a321b27e1b6198a666dc3"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图二十三.png","modified":1470735267094,"shasum":"765bfe30dc938d23cea7920e1985f497a5e6e320"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图二十二.png","modified":1470735267096,"shasum":"84962a339839bf3b21ab21a88dc9c4eda05b362f"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图五.png","modified":1470735267097,"shasum":"05ab1519891c2d0fc01a641e48285a17d9a1d215"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图八.png","modified":1470735267101,"shasum":"7bd6520778c095d82030137a39ba95509cdd749a"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图六.png","modified":1470735267103,"shasum":"c4d181b95d000577284ab68e8d6c32390928b684"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十一.png","modified":1470735267104,"shasum":"f923576c81f1106a77bc4a413da690470f46ba38"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十七.png","modified":1470735267106,"shasum":"05a6e9940493e468eb71b8a36d7d9006c9ac3cdd"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十三.png","modified":1470735267108,"shasum":"4f8364c2c226a84a25f698b60b86f9db360121bc"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十九.png","modified":1470735267110,"shasum":"50e408a5e93e3d2964743224865c8c04df02089c"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十二.png","modified":1470735267112,"shasum":"2c85ed57ab2f07ae05c454a45099f392d2e309de"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十五.png","modified":1470735267114,"shasum":"853311d1a1ce40fed21ef6e4b33bb8109b0c6bb8"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十八.png","modified":1470735267118,"shasum":"84e5764fc3c03d58a6aa6eb1279df5be655a6201"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十六.png","modified":1470735267119,"shasum":"e9fbf041e9f864b1fb831a5e06abf06b69f2cb2a"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十四.png","modified":1470735267121,"shasum":"74a6edd5a5cf02b3ec214dc9e38e061744f05809"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图四.png","modified":1470735267123,"shasum":"5db0ec325d56ef4bbb051d393fb6ae743fe05272"},{"_id":"public/2015/08/18/一个关于递推关系的思考/图一.jpg","modified":1470735267125,"shasum":"59a5a050bd90e6587607db17b84c65f449dde884"},{"_id":"public/2015/08/18/一个关于递推关系的思考/图三.png","modified":1470735267138,"shasum":"d0902d31fa7cc140ab7acc181a294cbd93713980"},{"_id":"public/2015/08/18/一个关于递推关系的思考/图二.jpg","modified":1470735267140,"shasum":"265137d5e126033958b1509ea942ee7419b503d1"},{"_id":"public/2015/02/01/RSA系类（一）：辗转相除法/图一.png","modified":1470735267152,"shasum":"381bde105287bdda205a1e096fb7ef5c9cb16e73"},{"_id":"public/2016/08/09/C-11特性与应用（三）/index.html","modified":1470735267258,"shasum":"d64023834628d41a9182f8e6e5afb9f6f96ba121"},{"_id":"public/2016/08/04/C-11特性与应用（二）/index.html","modified":1470735267285,"shasum":"94ba757484e9e913c33842b3b7d2984aaa673cf0"},{"_id":"public/2016/08/01/C-11特性与应用（一）：C-11语言特性/index.html","modified":1470735267306,"shasum":"05b20d1ac79aacc68e7dd899cb0dcf900aa2c312"},{"_id":"public/2016/07/22/C-11并发编程（一）：你好，并发世界/index.html","modified":1470735267316,"shasum":"a94d09f2672aec2651a73591ea0ab83ea2600c26"},{"_id":"public/2016/06/06/别样的进制/index.html","modified":1470735267326,"shasum":"750c700343c9caf31151c251f189e4a9c9856b88"},{"_id":"public/2016/06/04/别样的整数表示和运算/index.html","modified":1470735267336,"shasum":"cac172e8514370072e16738be81e4352088957f4"},{"_id":"public/2016/03/25/初识Netfilter-iptables/index.html","modified":1470735267346,"shasum":"99ba6114b9858805546676a1bf2d05180f1b7735"},{"_id":"public/2016/03/06/单击微信文章进入原文的方法/index.html","modified":1470735267357,"shasum":"8e846709047f5529cff8081425a855e5179d6c78"},{"_id":"public/2015/11/26/计算机网络概述/index.html","modified":1470735267364,"shasum":"652daad7f79bed1c45ec881acc90be2249d2704d"},{"_id":"public/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/index.html","modified":1470735267372,"shasum":"90dc7900fb19daf73ceffe2add300000ec841693"},{"_id":"public/2015/09/09/常见面试题复习：字符串-二/index.html","modified":1470735267392,"shasum":"ccca536d8440398620514ca72c3920578c5c6fae"},{"_id":"public/2015/09/08/常见面试题复习：字符串-一/index.html","modified":1470735267411,"shasum":"92abfef7eb2ee4a44caf54e67195acf855b55152"},{"_id":"public/2015/08/18/一个关于递推关系的思考/index.html","modified":1470735267420,"shasum":"f303a8315c090fca487fba25e0df79b5aba5f9d6"},{"_id":"public/2015/07/29/读书笔记：Ruby篇（三）/index.html","modified":1470735267448,"shasum":"fc70beb392e39d07cd522d707d7fa001351872f8"},{"_id":"public/2015/07/26/读书笔记：Ruby篇（二）/index.html","modified":1470735267464,"shasum":"72d5a88927d4b52d422db2bfb5b3bfccfabfff48"},{"_id":"public/2015/07/19/读书笔记：Ruby篇（一）/index.html","modified":1470735267479,"shasum":"aa3e2862e660ebea10e1f973fc1b91b9ce2662b1"},{"_id":"public/2015/03/12/手电筒的启示/index.html","modified":1470735267486,"shasum":"3ac25a9d459d39323f5282e5f55051e38a9598fb"},{"_id":"public/2015/03/12/信息编码随想/index.html","modified":1470735267492,"shasum":"fbc0181f42edc5fc5da083432cfeefe04ee06ba2"},{"_id":"public/2015/02/04/RSA系类（四）：完結篇/index.html","modified":1470735267504,"shasum":"bc9f7d725912c735f541b9fa8f5a7af82d004e2d"},{"_id":"public/2015/02/03/RSA系类（三）：从物不知数到中国剩余定理和费马小定理/index.html","modified":1470735267514,"shasum":"6eee6705a484c085245db2b112d912ebae38446b"},{"_id":"public/2015/02/02/RSA系类（二）：分水问题/index.html","modified":1470735267520,"shasum":"06f8478c1722c59679c0143e4a4f376b83240fa8"},{"_id":"public/2015/02/01/RSA系类（一）：辗转相除法/index.html","modified":1470735267529,"shasum":"66df29e3e48f148e980c1e75c69a36c47a6a1d70"},{"_id":"public/2015/02/01/Github个人静态博客的搭建/index.html","modified":1470735267557,"shasum":"5193bff5c1287d345796fabd6ca1bb27cce62bde"},{"_id":"public/2015/02/01/博客名字的由来/index.html","modified":1470735267564,"shasum":"a98f16fa4b17af8edce84ad920ebcbfd8fa36437"},{"_id":"public/baidusitemap.xml","modified":1470735267566,"shasum":"2f2dc45b18873b75530a658ef3875b4d81af32ad"},{"_id":"public/categories/Ruby/index.html","modified":1470735267574,"shasum":"028979c95b16cfcb033d2baa08b6a2c83265ac63"},{"_id":"public/categories/计算机网络/index.html","modified":1470735267580,"shasum":"908dba6f51c24a5b5d7b4f607f29a84b2b8f443e"},{"_id":"public/categories/信息编码/index.html","modified":1470735267586,"shasum":"25f7a8ad59c54b74d31fa835c579a41b7d55715a"},{"_id":"public/categories/笔试/index.html","modified":1470735267592,"shasum":"9716701fcaac9be394067c3a2eca2cde80134a60"},{"_id":"public/categories/杂谈/index.html","modified":1470735267595,"shasum":"b0ecf9f42b30a88ccc0fa1e1c1e54d7f4c777cac"},{"_id":"public/categories/微信开发/index.html","modified":1470735267599,"shasum":"c0a64532117de2852516cdb44901879366ddd724"},{"_id":"public/categories/计算机基础/index.html","modified":1470735267604,"shasum":"fb6d91c2712d42b3973ba96feb7ef6d4c32f85e8"},{"_id":"public/categories/Linux防火墙/index.html","modified":1470735267609,"shasum":"32c08f79a75379e83fc6219ea2821c4cfeaea638"},{"_id":"public/categories/算法/index.html","modified":1470735267616,"shasum":"f43b65a67d5be14078ca5f95e698cf4a97393300"},{"_id":"public/categories/Hexo/index.html","modified":1470735267620,"shasum":"af1e9aca95c5fe1d9fba7af9c377ff9a6b7a610c"},{"_id":"public/categories/C/index.html","modified":1470735267626,"shasum":"f5af4c5524c6bf51c545d3a4dec1afdae85d56d7"},{"_id":"public/atom.xml","modified":1470735267629,"shasum":"7703347a3826a4530c676eb0d24584820981288c"},{"_id":"public/archives/index.html","modified":1470735267644,"shasum":"65574674a6f5d3274371b7a59854741649ee5f68"},{"_id":"public/archives/page/2/index.html","modified":1470735267660,"shasum":"22bde893f5281cd6994f1ff36ba893452b905a07"},{"_id":"public/archives/page/3/index.html","modified":1470735267667,"shasum":"f2e5642ddb7888ff0c4a951c0c0c52848d3100fa"},{"_id":"public/archives/2015/index.html","modified":1470735267678,"shasum":"b04544bbd553c1d4a67ddd522bf221e994eee8e0"},{"_id":"public/archives/2015/page/2/index.html","modified":1470735267687,"shasum":"9c5f1a7850e5879357ced5c7cd86dc59834a0ba6"},{"_id":"public/archives/2015/02/index.html","modified":1470735267696,"shasum":"221b01b8eb6987d3b8d59c00107a02b467473b05"},{"_id":"public/archives/2015/03/index.html","modified":1470735267701,"shasum":"0e6fdc7ca582c71843a421e958f8417ab7addec1"},{"_id":"public/archives/2015/07/index.html","modified":1470735267706,"shasum":"a93f14fe281f1e8980ef30e9b553fc1431243394"},{"_id":"public/archives/2015/08/index.html","modified":1470735267710,"shasum":"5fde0466cf83c3aa693bd60f5577346fc4e75e2a"},{"_id":"public/archives/2015/09/index.html","modified":1470735267716,"shasum":"3fcd6e9dee38b04eaff23bb696fa120d9ee2e8d8"},{"_id":"public/archives/2015/11/index.html","modified":1470735267722,"shasum":"204617ded5c4cfc7f125f060448aaf8193a0afd0"},{"_id":"public/archives/2016/index.html","modified":1470735267732,"shasum":"ac7fb4eb66fb68645145046a09722b3d265bfd61"},{"_id":"public/archives/2016/03/index.html","modified":1470735267737,"shasum":"967c68c6b32b996fe2857b5cda01f2b6cb79f0a4"},{"_id":"public/archives/2016/06/index.html","modified":1470735267742,"shasum":"7797fa210256a25293f355cbe1c66b7cbf8172e7"},{"_id":"public/archives/2016/07/index.html","modified":1470735267746,"shasum":"a011a3d7e2857554af428a133d6d2839f2e69b51"},{"_id":"public/archives/2016/08/index.html","modified":1470735267751,"shasum":"65143613b5628b8ae2b9e1b0fa610d4ba1006a82"},{"_id":"public/index.html","modified":1470735267775,"shasum":"35358a4ae7157e60f9d3c42859b969f9c4ed147a"},{"_id":"public/page/2/index.html","modified":1470735267797,"shasum":"ccd24105e733e51ebd7d9aefcecff1f13c3b4319"},{"_id":"public/page/3/index.html","modified":1470735267807,"shasum":"0f5b47b9d67682dddbe7dd866908a6c62cf9ab2f"},{"_id":"public/sitemap.xml","modified":1470735267808,"shasum":"fd22d9231bd65594c465c383c4f43271e2b71735"},{"_id":"public/tags/Ruby/index.html","modified":1470735267814,"shasum":"ba4dc97369237e8010083728687d0941572c4b5f"},{"_id":"public/tags/计算机网络/index.html","modified":1470735267819,"shasum":"e2e47d1d17809f7b5449294a4f1c5313a17716b8"},{"_id":"public/tags/信息编码/index.html","modified":1470735267825,"shasum":"1a19dd3c407a9d385c70ff5b305ba171068bd092"},{"_id":"public/tags/字符串/index.html","modified":1470735267830,"shasum":"327d7ddc70b7a03908d8211be10cb0cebc38318c"},{"_id":"public/tags/笔试题/index.html","modified":1470735267834,"shasum":"f5b3dedd92d549e4c1d9418e9c9fc1abcb2dd398"},{"_id":"public/tags/杂谈/index.html","modified":1470735267838,"shasum":"be7f88047039f5417a948d346b557637d1a00a53"},{"_id":"public/tags/关于博客/index.html","modified":1470735267841,"shasum":"f6819a8a6b894e38a9e6f23d932d57afe9fda083"},{"_id":"public/tags/微信开发/index.html","modified":1470735267845,"shasum":"748b23094314b9db179d441c0ec813241609a042"},{"_id":"public/tags/计算机基础/index.html","modified":1470735267853,"shasum":"01a53c25b5042cbe22fa461146f05ff72b1ea19c"},{"_id":"public/tags/数学/index.html","modified":1470735267862,"shasum":"149df6cb4698ac820bf1cf7f4024269be5b3e924"},{"_id":"public/tags/iptables/index.html","modified":1470735267866,"shasum":"e4ff4083196131f099b10ea66e6a075d962561ca"},{"_id":"public/tags/Netfilter/index.html","modified":1470735267872,"shasum":"3671bc1ec4bc4d8c69c4d9f8dab4bee0ef98b853"},{"_id":"public/tags/防火墙/index.html","modified":1470735267876,"shasum":"ef9593a8704fd4b50b49ca3b72b56552247be6e2"},{"_id":"public/tags/网络/index.html","modified":1470735267881,"shasum":"ae99ec9f8203384722804719f67dc4e2eb8b91ac"},{"_id":"public/tags/笔试/index.html","modified":1470735267885,"shasum":"8e7eb51694e75cdd4b303a194cb44533a541f096"},{"_id":"public/tags/RSA算法/index.html","modified":1470735267893,"shasum":"7ffba88796245466090260b13ff462d113cf77bf"},{"_id":"public/tags/欧拉函数/index.html","modified":1470735267897,"shasum":"7e0038ed118c09e95b1f5d5978650c8f58928999"},{"_id":"public/tags/费马小定理/index.html","modified":1470735267902,"shasum":"d1ef8847def516e75e6bb88428e7568db8208333"},{"_id":"public/tags/扩展辗转相除法/index.html","modified":1470735267907,"shasum":"15baab8d1efd3fd49a9757e8189898e996b728a1"},{"_id":"public/tags/中国剩余定理/index.html","modified":1470735267911,"shasum":"4b050ae9b77a63312961e7cb92d2dffae947988a"},{"_id":"public/tags/辗转相除法/index.html","modified":1470735267916,"shasum":"504dbf250b3690cca2e2d794aae9d7f9b39d8fa0"},{"_id":"public/tags/教程/index.html","modified":1470735267920,"shasum":"47367202231631eb1f6ad8265a27ea87da5eaa51"},{"_id":"public/tags/总结/index.html","modified":1470735267924,"shasum":"33980a4e4071b41d562a804306918fb8925fa22a"},{"_id":"public/tags/Hexo/index.html","modified":1470735267931,"shasum":"69bbd5afd30ba27644b4a218f09a26eef2e25745"},{"_id":"public/tags/C-11/index.html","modified":1470735267957,"shasum":"b152e4e1d6d741cd503dc814acf54948cd947694"},{"_id":"public/tags/并发编程/index.html","modified":1470735267963,"shasum":"7fbfc7a52fb0f1b871cb93449daf62dc899fc33d"}],"Category":[{"name":"Ruby","_id":"cirn9svqk0002tkb9cvb6hzb8"},{"name":"计算机网络","_id":"cirn9svv9000dtkb9v8585wlf"},{"name":"信息编码","_id":"cirn9svya000itkb993opuipu"},{"name":"笔试","_id":"cirn9svz1000ntkb9u2rtkh16"},{"name":"杂谈","_id":"cirn9sw05000ytkb9a4ebcigp"},{"name":"微信开发","_id":"cirn9sw0a0015tkb9k7wdq7r8"},{"name":"计算机基础","_id":"cirn9sw0v001atkb9570oyqm5"},{"name":"Linux防火墙","_id":"cirn9sw1n001ltkb9sj3h84ke"},{"name":"算法","_id":"cirn9sw550027tkb9byjfr7yh"},{"name":"Hexo","_id":"cirn9sw5v0030tkb9k6lbbes6"},{"name":"C++","_id":"cirn9sw5z0039tkb9i1lm406h"}],"Data":[],"Page":[],"Post":[{"title":"Linux服务器安全","_content":"","source":"_drafts/Linux服务器安全.md","raw":"title: Linux服务器安全\ntags:\n---\n","slug":"Linux服务器安全","published":0,"date":"2016-03-23T03:43:05.141Z","updated":"2016-03-23T03:43:05.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9svq30000tkb9xwmxsx0i"},{"title":"读书笔记：Ruby篇（二）","date":"2015-07-26T15:53:00.000Z","_content":"\n\n第一天对Ruby做了概述，第二天，你会亲身体验令Ruby大受欢迎的小魔法。你将学习对象、集合、类等基本构建单元的用法，还将学到代码块的基本要素。我在这里补充了Ruby中的一些基本知识。\n\n预备知识：\n\nRuby使用一种命名惯例来区分名称的用途：名称的第一个字符显示这个名称如何被使用。局部变量、方法参数和方法名称都必须以小写字母或下划线开始。全局变量以美元符号（$）为前缀，而实例变量以“at”（@）符号开始。类变量以两个“at”（@@）符号开始。最后，类名称、模块名称和常量都必须以一个大写字母开始。之后的字符可以是字母、数字和下划线的任意组合（但跟在@符号候命的符号不能是数字）。但是按照惯例，包含多个单词的实例变量名称在词与词之间使用下划线连接，包含多个单词的类变量名称使用混合大小写（每个单词首字母大写）。方法名称可以以?、!和=字符结束。还有一点：从定义一元运算符有 +（正）、 -（负）、 ~（位反）、 !（非）， 它们分别以 +@、 -@、 ~@、 !@ 为方法名进行方法的定义，调用时直接使用+、-、~、@。\n\n### 1．基本数据类型\n{% asset_img  图一.png 图一 %}\n<!--more-->\n1.1 Numeric（数值）\n\n数值类型包括：Integer（整数）、Float（浮点数）、Rational（有理数）和Complex（复数），其中Integer（整数）分为Fixnum（普通整数）和Bignum（大整数）。程序中用到的整数一般都是 Fixnum 类范围内的整数。 如果使用的整数超过了 Fixnum 的范围， Ruby 就会自动将其转换为 Bignum 类。 因此， 在写程序的时候， 我们几乎可以忽略上述整数类的区别。\n\nRational 对象用“Rational( 分子 , 分母 )”的形式定义：\n```ruby\na = Rational(2, 5)\np a #=> (2/5)\n```\nComplex 对象用“Complex( 实数 , 虚数 )”的形式定义：\n```ruby\nc = Complex(1, 2)\np c #=> (1+2i)\n```\nInteger 对象与 Float 对象的运算结果为 Float 对象。 Integer 对象之间、 Float 对象之间的运算结果分别为 Integer 对象、 Float 对象。\n\n将 Integer 对象转换为 Float 对象时， 可以使用 to_f 方法。 相反， 使用 to_i 方法则可以将 Float 对象转换为 Integer 对象（ Integer#to_i 方法和Float#to_f 方法返回与接收者一样的值） 。 另外， 也可以把字符串转换为数值，如：”123.45”.to_f。最后，还有一个新运算符**表示乘方。更多信息，请参考手册。\n\n1.2 Symbols符号\n符号是前面带有冒号的标识符，类似于:symbol的形式。符号与字符串之间的区别是：两个同值字符串在物理上是不同，但相同的符号却是同一物理对象。\n```ruby\n>> 'string'.object_id\n=> 10617408\n>> 'string'.object_id\n=> 18259680\n>> :string.object_id\n=> 160340\n>> :string.object_id\n=> 160340\n```\n1．3 Ranges（区间）\n除了用在条件表达式中expr..expr和expr…expr还能构成Range对象。两个点的形式是闭合区间，而三个点的形式是半开半闭的。\n1.4String（字符串），从略，更多信息，请参考手册。\n1.5 Arrays（数组）\n1．5．1 数组创建\n1）a = Array.new，有两个可选参数，第一个参数表示数组元素个数，默认值为0，第二个参数表示数组元素初始值，默认值是nil。\n\n2）使用%w或者%i\n\n创建不包含空白的字符串数组时， 可以使用 %w:\n```ruby\nlang = %w(Ruby Perl Python Scheme Pike REBOL)\np lang #=> [\"Ruby\", \"Perl\", \"Python\", \"Scheme\", \"Pike\", \"REBOL\"]\n```\nRuby2.0 还提供了创建符号（ Symbol） 数组的 %i：\n```ruby\nlang = %i(Ruby Perl Python Scheme Pike REBOL)\np lang #=> [:Ruby, :Perl, :Python, :Scheme, :Pike, :REBOL]\n```\n创建数组时使用了 () 将数组元素括了起来， 但实际上还可以使用如 <>、 ||、 !!、 @@、 AA 这样的任意字符。\n\n3）使用to_a方法\n很多类都定义了 to_a 方法， 该方法能把该类的对象转换为数组：\n```ruby\ncolor_table = {black: \"#000000\", white: \"#FFFFFF\"}\np color_table.to_a #=> [[:black, \"#000000\"],[:white, \"#FFFFFF\"]]\n```\n4）使用字符串的 split 方法。\n1．5．2通过 [] 指定索引， 获取元素\n（a） a [n]，n为非负整数，从数组的开头获取元素，如a[0]表示数组的第一个元素，n为负数，从数组的末尾获取元素，如a[-1]表示数组的最后一个元素，n大于元素个数返回nil；\n（b） a [n..m] 或者 a [n...m]，n..m(闭区间对象),n…m(左闭右开区间对象)，a[n..m]表示获取从 a [n] 到 a [m] 的元素， 然后用它们创建新数组并返回，a[n…m] 表示获取从 a [n] 到 a [m-1] 的元素， 然后用它们创建新数组并返回；\n（c） a [n, len] 表示从 a [n] 开始， 获取之后的 len 个元素， 用它们创建新数组并返回。\n1．5．3作为集合的数组\n交集：ary = ary1 & ary2\n并集：ary = ary1 | ary2\n集合的差：ary = ary1 - ary2\n```ruby\nary1 = [“a”,”b”,”c”]\nary2 = [“b”,”c”,”d”]\np (ary1 & ary2) #=>[“b”,”c”]\np (ary1 | ary2) #=>[“a”,”b”,”c”,”d”]\np (ary1 – ary2) #=>[“a”]\n```\n“|”与“+”的不同点:\n```ruby\nnum = [1, 2,3]\neven = [2, 4, 6]\np (num + even) #=> [1, 2, 3, 2, 4, 6]\np (num | even) #=> [1, 2, 3, 4, 6]\n```\n1.5.4作为列的数组,即将数组当作栈和队列使用\n1）push 方法和 pop 方法可以实现栈；\n2）push 方法和 shift 方法可以实现队列\n\n|          | 对数组开头的元素操作 | 对数组末尾的元素操作 |\n|:--------:|:------------------:|:-----------------:|\n|  追加元素 |      unshift       |         push      |\n|  删除元素 |      shift         |         pop       |\n|  引用元素 |      first         |         last      |\n\n关于数组的更多内容，请参考手册。\n\n1.6 Hashes（散列表）\n1．6．1 散列的创建\n1）使用 { 键 => 值}：\n```ruby\nh1 = {\"a\"=>\"b\", \"c\"=>\"d\"}\np h1[\"a\"] #=> \"b\"\n```\n2）使用{ 键: 值}：\n```ruby\nh2 = {a: \"b\", c: \"d\"}\np h2 #=> {:a=>\"b\", :c=>\"d\"}\n```\n3）使用 Hash.new：\nHash.new 是用来创建新的散列的方法。 若指定参数， 则该参数值为散列的默认值， 也就是指定不存在的键时所返回的值。 没指定参数时， 散列的默认值为nil。\n\n1．6．2对散列表键值的要求\n散列表键必须能够响应hash消息并返回一个散列码（hash code），并且某个键对应的散列码不能改变。散列表中使用的键也必须能使用eql？来比较。如果eql？在比较两个键是返回真，那么这两个键必定具有相同的散列码。这意味着某些类（例如数据和散列）不适合做键，因为他们的hash值可能会随着其内容而发生变化。\n\n1．6．3 键最好使用Symbols(符号)\n符号是前面带有冒号的标识符，类似于:symbol的形式。它在给事物和概念命名时非常好用。两个同值字符串在物理上是不同，但相同的符号却是同一物理对象。\n\n1．6．4散列的应用\nRuby虽然不支持命名参数， 但可以用散列表来模拟它。只要加进一颗小小的语法糖，你就能获得一些有趣的特性：\n```ruby\n>> def tell_the_truth(options={})\n>>    if options[:profession] == :lawyer\n>>       'it could be believed that this is almost certainly not false.'\n>>    else\n?>       true\n>>    end\n>> end\n=> :tell_the_truth\n>> tell_the_truth\n=> true\n>> tell_the_truth :profession=>:lawyer\n=> \"it could be believed that this is almost certainly not false.\"\n```\n该方法带一个可选参数。如果不传入该参数， options将设为空散列表，但如果传入:profession=>:lawyer，返回结果就有所不同。它不会返回true，但因为Ruby的求值机制将字符串也当作true处理，所以这和返回true几乎毫无差别。还需注意，这里的散列表不必用大括号括起来，因为将散列表用作函数的最后一个参数时，大括号可有可无。\n\n1．6．5 散列与数组的对比\n和数组相比，Hashes有一个突出的优点：几乎可以用任何对象做索引。然而它有一个突出的缺点：他的元素是无序的一次很难使用hash来实现栈和队列。\n\n1．7 Regexp（正则表达式）\n1．7．1 正则表达式对象的创建\n1）/模式/\n2）re = Regexp.new(“模式”)\n3）re = %r(模式)，()可以换成<>,||,!!等等。\n1．7．2正则表达式的模式与匹配\n1）正则表达式 =~ 字符串，=~ 方法是正则表达式中常用的方法， 可以用来判断正则表达式与指定字符串是否匹配。\n2）正则表达式 !~ 字符串，!~ 是=~的取反，来颠倒“真”与“假”。\n\n无趣的基础知识终于结束了。\n\n2.定义函数\n```ruby\n>> def say_hello(name)\n>>    puts \"hi,#{name}\"\n>> end\n=> :say_hello\n>> say_hello \"xxx\"\nhi,xxx\n=> nil\n```\n每个函数都会返回结果。如果你没有显式指定某个返回值，函数就将返回退出函数前最后处理的表达式的值。像所有其他事物一样，函数也是个对象。\n\n3.代码块和yield\n\n代码块是包括在花括号（习惯上，代码在一行时使用花括号）或者do/end（习惯上，多行代码使用do/end）对中的能与参数一起传递的多个处理的集合。看一下昨天的一个习题，看是怎么使用代码块的：\n```ruby\n>> (1..2).each {|i| puts \"This is sentence number #{i}\"}\nThis is sentence number 1\nThis is sentence number 2\n```\n这有点类似于C++中将一个函数指针传给一个方法，然后在方法中调用这个函数。那Ruby是怎样调用这个代码块的呢？让我们来自己来实现一个类似each方法my_each：\n```ruby\n>> (1..2).my_each { |x| p x }\nNoMethodError: undefined method `my_each' for 1..2:Range\nfrom (irb):1\nfrom d:/Ruby22/bin/irb:11:in `<main>'\n```\n在还没有为Range添加my_each实例方法前，会提示错误，下面为Range添加一个实例方法：\n```ruby\n>> class Range\n>>      def my_each\n>>         f = first\n>>         l = last\n>>         e = first\n>>         loop do\n?>             yield e\n>>             break self if e == l\n>>             e = e.succ\n>>         end\n>>      end\n>> end\n=> :my_each\n>> (1..2).my_each { |x| p x }\n1\n2\n```\n从这个例子可以看出，代码块的使用和调用方法，调用方法时将代码块紧接在方法之后，在方法中通过yield调用传过来的代码块。这个例子有个值得一提的地方，我们居然给一个基本数据类型Range添加了一个方法，这里面的奥秘以后再详细介绍。\n\n代码块能让你把可执行代码派发给其他方法。除此之外，代码块还有延迟执行等诸多作用。\n\n4.定义类\n根据以往的经验，面向对象编程意味着要将大量的时间用于定义类。在Java，C++等面向对象编程语言当中，类的定义只是在跟编译器签订契约，约定类的各种行为。此时，编译器其实并没有做什么实质性的工作，直到创建对象，然后调用方法才会有实际的工作。\n\nRuby于此有所不同，Ruby中的类在定义时就已经是实实在在的执行类中的代码了。\nRuby也支持继承，Ruby中的类只能继承自一个类。看代码：\n```ruby\n>> 4.class\n=> Fixnum\n>> 4.class.superclass\n=> Integer\n>> 4.class.superclass.superclass\n=> Numeric\n>> 4.class.superclass.superclass.superclass\n=> Object\n>> 4.class.superclass.superclass.superclass.superclass\n=> BasicObject\n>> 4.class.superclass.superclass.superclass.superclass.superclass\n=> nil\n```\n从这个继承关系，我们立刻就能得到Ruby中的继承关系图：\n{% asset_img 图二.png 图二 %}\n等等，再看看下面的代码：\n```ruby\n>> 4.class.class\n=> Class\n>> 4.class.class.superclass\n=> Module\n>> 4.class.class.superclass.superclass\n=> Object\n>> 4.class.class.superclass.superclass.superclass\n=> BasicObject\n>> 4.class.class.superclass.superclass.superclass.superclass\n=> nil\n```\n我们根据这个关系，又能得出如下关系图：\n{% asset_img  图三.jpg 图三 %}\n请注意第一句话，4.class.class，4.class是Fixnum：说明4是Fixnum的实例对象，4.class.class即Fixnum.class是Class（请注意这里的大小写），这里表示，Fixnum是Class的实例对象，什么鬼？一个类是另一个类的实例!!!这是要逆天吗？好吧，先来看看书上的继承图（图中少了BasicObject类， Ruby1.9之前是没有BasicObject）：\n{% asset_img 图四.png 图四 %}\n现在来解释解释：一切从我们的口号说起：一切都是对象。明白了吗，上面的东西都是对象，类也是对象，不信，请看看下面的代码：\n```ruby\n>> Object.class\n=> Class\n>> Module.class\n=> Class\n>> Class.class\n=> Class\n>> Numeric.class\n=> Class\n>> Integer.class\n=> Class\n>> Fixnum.class\n=> Class\n```\n这些类都是Class类的对象，就连Class本身也是Class的对象。现在就能解释的通定义类时，其实在实例化一个对象，所以它在执行类中的代码（注意方法中的代码是不会执行的）很正常。根据Ruby中的命名规则（常量、类和模块都是以大写字母开头），可以知道，其实类就是一个Class类的实例常量。用图总结如下：\n{% asset_img 图五.jpg 图五 %}\n\n5.编写Mixin\n类已经可以定义了，接下来解决继承问题，由于Ruby是单继承的，那要怎样同时继承自两个及以上的类呢？Java通过接口，C++本来就支持多继承，Ruby是通过Mixin（混入）来实现的。其实就是定义一个module，然后把这个module包含近类。那么module中的方法就继承过来了。看代码：\n```ruby\n>> module M\n>> def m_func\n>> puts \"in M\"\n>> end\n>> end\n=> :m_func\n>> class C\n>> include M\n>> def c_func\n>> puts \"in C\"\n>> end\n>> end\n=> :c_func\n>> obj = C.new\n=> #<C:0x2483010>\n>> obj.m_func\nin M\n=> nil\n>> obj.c_func\nin C\n=> nil\n```\n从这个例子可以看出，通过Mixin技术，就能解决多继承问题，而且这种依赖关系是隐式的，不像Java使用接口实现的多继承，在Java中继承接口，必须显式实现接口中的方法。\n\n6. 模块、可枚举和集合\nRuby有两个至关重要的mixin： 枚举（enumerable）和比较（comparable） 。如果想让类可枚举，必须实现each方法；如果想让类可比较，必须实现<=>操作符。 <=>被人们叫做太空船操作符，它比较a、 b两操作数， b较大返回1， a较大返回1，相等返回0。为避免方法实现之苦，集合已实现了许多便于使用的可枚举和可比较的方法。如：由于整数已通过Fixnum类实现了太空船操作符，因此可以调用sort方法排序，还可以调用min和max方法计算最小值和最大值。举个可枚举的例子：\n```ruby\n>> a = [1,2,3,4,5]\n=> [1, 2, 3, 4, 5]\n>> a.inject(0) do |sum,i|\n?>    puts \"sum: #{sum}     i: #{i}     sum + i: #{sum + i}\"\n>>    sum + i\n>> end\nsum: 0     i: 1     sum + i: 1\nsum: 1     i: 2     sum + i: 3\nsum: 3     i: 3     sum + i: 6\nsum: 6     i: 4     sum + i: 10\nsum: 10     i: 5     sum + i: 15\n=> 15\n```\n7.小结\n今天主要是简单介绍了一些关于基本数据类型、函数、代码块、类、模块和Mixin。集合简直太好用了：用得最多的两个集合都带有众多API。 Ruby关注的是程序员的效率，应用程序的效率是次要的。枚举模块让你品尝到Ruby良好设计的味道，单继承的面向对象结构虽不是什么新鲜事物，但Ruby的实现充满了符合直觉和实用的特性。如此程度的抽象并没有为Ruby带来本质上的变化，真正点石成金的魔法还在后面。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/读书笔记：Ruby篇（二）.md","raw":"title: 读书笔记：Ruby篇（二）\ntags:\n  - Ruby\ncategories:\n  - Ruby\ndate: 2015-07-26 23:53:00\n---\n\n\n第一天对Ruby做了概述，第二天，你会亲身体验令Ruby大受欢迎的小魔法。你将学习对象、集合、类等基本构建单元的用法，还将学到代码块的基本要素。我在这里补充了Ruby中的一些基本知识。\n\n预备知识：\n\nRuby使用一种命名惯例来区分名称的用途：名称的第一个字符显示这个名称如何被使用。局部变量、方法参数和方法名称都必须以小写字母或下划线开始。全局变量以美元符号（$）为前缀，而实例变量以“at”（@）符号开始。类变量以两个“at”（@@）符号开始。最后，类名称、模块名称和常量都必须以一个大写字母开始。之后的字符可以是字母、数字和下划线的任意组合（但跟在@符号候命的符号不能是数字）。但是按照惯例，包含多个单词的实例变量名称在词与词之间使用下划线连接，包含多个单词的类变量名称使用混合大小写（每个单词首字母大写）。方法名称可以以?、!和=字符结束。还有一点：从定义一元运算符有 +（正）、 -（负）、 ~（位反）、 !（非）， 它们分别以 +@、 -@、 ~@、 !@ 为方法名进行方法的定义，调用时直接使用+、-、~、@。\n\n### 1．基本数据类型\n{% asset_img  图一.png 图一 %}\n<!--more-->\n1.1 Numeric（数值）\n\n数值类型包括：Integer（整数）、Float（浮点数）、Rational（有理数）和Complex（复数），其中Integer（整数）分为Fixnum（普通整数）和Bignum（大整数）。程序中用到的整数一般都是 Fixnum 类范围内的整数。 如果使用的整数超过了 Fixnum 的范围， Ruby 就会自动将其转换为 Bignum 类。 因此， 在写程序的时候， 我们几乎可以忽略上述整数类的区别。\n\nRational 对象用“Rational( 分子 , 分母 )”的形式定义：\n```ruby\na = Rational(2, 5)\np a #=> (2/5)\n```\nComplex 对象用“Complex( 实数 , 虚数 )”的形式定义：\n```ruby\nc = Complex(1, 2)\np c #=> (1+2i)\n```\nInteger 对象与 Float 对象的运算结果为 Float 对象。 Integer 对象之间、 Float 对象之间的运算结果分别为 Integer 对象、 Float 对象。\n\n将 Integer 对象转换为 Float 对象时， 可以使用 to_f 方法。 相反， 使用 to_i 方法则可以将 Float 对象转换为 Integer 对象（ Integer#to_i 方法和Float#to_f 方法返回与接收者一样的值） 。 另外， 也可以把字符串转换为数值，如：”123.45”.to_f。最后，还有一个新运算符**表示乘方。更多信息，请参考手册。\n\n1.2 Symbols符号\n符号是前面带有冒号的标识符，类似于:symbol的形式。符号与字符串之间的区别是：两个同值字符串在物理上是不同，但相同的符号却是同一物理对象。\n```ruby\n>> 'string'.object_id\n=> 10617408\n>> 'string'.object_id\n=> 18259680\n>> :string.object_id\n=> 160340\n>> :string.object_id\n=> 160340\n```\n1．3 Ranges（区间）\n除了用在条件表达式中expr..expr和expr…expr还能构成Range对象。两个点的形式是闭合区间，而三个点的形式是半开半闭的。\n1.4String（字符串），从略，更多信息，请参考手册。\n1.5 Arrays（数组）\n1．5．1 数组创建\n1）a = Array.new，有两个可选参数，第一个参数表示数组元素个数，默认值为0，第二个参数表示数组元素初始值，默认值是nil。\n\n2）使用%w或者%i\n\n创建不包含空白的字符串数组时， 可以使用 %w:\n```ruby\nlang = %w(Ruby Perl Python Scheme Pike REBOL)\np lang #=> [\"Ruby\", \"Perl\", \"Python\", \"Scheme\", \"Pike\", \"REBOL\"]\n```\nRuby2.0 还提供了创建符号（ Symbol） 数组的 %i：\n```ruby\nlang = %i(Ruby Perl Python Scheme Pike REBOL)\np lang #=> [:Ruby, :Perl, :Python, :Scheme, :Pike, :REBOL]\n```\n创建数组时使用了 () 将数组元素括了起来， 但实际上还可以使用如 <>、 ||、 !!、 @@、 AA 这样的任意字符。\n\n3）使用to_a方法\n很多类都定义了 to_a 方法， 该方法能把该类的对象转换为数组：\n```ruby\ncolor_table = {black: \"#000000\", white: \"#FFFFFF\"}\np color_table.to_a #=> [[:black, \"#000000\"],[:white, \"#FFFFFF\"]]\n```\n4）使用字符串的 split 方法。\n1．5．2通过 [] 指定索引， 获取元素\n（a） a [n]，n为非负整数，从数组的开头获取元素，如a[0]表示数组的第一个元素，n为负数，从数组的末尾获取元素，如a[-1]表示数组的最后一个元素，n大于元素个数返回nil；\n（b） a [n..m] 或者 a [n...m]，n..m(闭区间对象),n…m(左闭右开区间对象)，a[n..m]表示获取从 a [n] 到 a [m] 的元素， 然后用它们创建新数组并返回，a[n…m] 表示获取从 a [n] 到 a [m-1] 的元素， 然后用它们创建新数组并返回；\n（c） a [n, len] 表示从 a [n] 开始， 获取之后的 len 个元素， 用它们创建新数组并返回。\n1．5．3作为集合的数组\n交集：ary = ary1 & ary2\n并集：ary = ary1 | ary2\n集合的差：ary = ary1 - ary2\n```ruby\nary1 = [“a”,”b”,”c”]\nary2 = [“b”,”c”,”d”]\np (ary1 & ary2) #=>[“b”,”c”]\np (ary1 | ary2) #=>[“a”,”b”,”c”,”d”]\np (ary1 – ary2) #=>[“a”]\n```\n“|”与“+”的不同点:\n```ruby\nnum = [1, 2,3]\neven = [2, 4, 6]\np (num + even) #=> [1, 2, 3, 2, 4, 6]\np (num | even) #=> [1, 2, 3, 4, 6]\n```\n1.5.4作为列的数组,即将数组当作栈和队列使用\n1）push 方法和 pop 方法可以实现栈；\n2）push 方法和 shift 方法可以实现队列\n\n|          | 对数组开头的元素操作 | 对数组末尾的元素操作 |\n|:--------:|:------------------:|:-----------------:|\n|  追加元素 |      unshift       |         push      |\n|  删除元素 |      shift         |         pop       |\n|  引用元素 |      first         |         last      |\n\n关于数组的更多内容，请参考手册。\n\n1.6 Hashes（散列表）\n1．6．1 散列的创建\n1）使用 { 键 => 值}：\n```ruby\nh1 = {\"a\"=>\"b\", \"c\"=>\"d\"}\np h1[\"a\"] #=> \"b\"\n```\n2）使用{ 键: 值}：\n```ruby\nh2 = {a: \"b\", c: \"d\"}\np h2 #=> {:a=>\"b\", :c=>\"d\"}\n```\n3）使用 Hash.new：\nHash.new 是用来创建新的散列的方法。 若指定参数， 则该参数值为散列的默认值， 也就是指定不存在的键时所返回的值。 没指定参数时， 散列的默认值为nil。\n\n1．6．2对散列表键值的要求\n散列表键必须能够响应hash消息并返回一个散列码（hash code），并且某个键对应的散列码不能改变。散列表中使用的键也必须能使用eql？来比较。如果eql？在比较两个键是返回真，那么这两个键必定具有相同的散列码。这意味着某些类（例如数据和散列）不适合做键，因为他们的hash值可能会随着其内容而发生变化。\n\n1．6．3 键最好使用Symbols(符号)\n符号是前面带有冒号的标识符，类似于:symbol的形式。它在给事物和概念命名时非常好用。两个同值字符串在物理上是不同，但相同的符号却是同一物理对象。\n\n1．6．4散列的应用\nRuby虽然不支持命名参数， 但可以用散列表来模拟它。只要加进一颗小小的语法糖，你就能获得一些有趣的特性：\n```ruby\n>> def tell_the_truth(options={})\n>>    if options[:profession] == :lawyer\n>>       'it could be believed that this is almost certainly not false.'\n>>    else\n?>       true\n>>    end\n>> end\n=> :tell_the_truth\n>> tell_the_truth\n=> true\n>> tell_the_truth :profession=>:lawyer\n=> \"it could be believed that this is almost certainly not false.\"\n```\n该方法带一个可选参数。如果不传入该参数， options将设为空散列表，但如果传入:profession=>:lawyer，返回结果就有所不同。它不会返回true，但因为Ruby的求值机制将字符串也当作true处理，所以这和返回true几乎毫无差别。还需注意，这里的散列表不必用大括号括起来，因为将散列表用作函数的最后一个参数时，大括号可有可无。\n\n1．6．5 散列与数组的对比\n和数组相比，Hashes有一个突出的优点：几乎可以用任何对象做索引。然而它有一个突出的缺点：他的元素是无序的一次很难使用hash来实现栈和队列。\n\n1．7 Regexp（正则表达式）\n1．7．1 正则表达式对象的创建\n1）/模式/\n2）re = Regexp.new(“模式”)\n3）re = %r(模式)，()可以换成<>,||,!!等等。\n1．7．2正则表达式的模式与匹配\n1）正则表达式 =~ 字符串，=~ 方法是正则表达式中常用的方法， 可以用来判断正则表达式与指定字符串是否匹配。\n2）正则表达式 !~ 字符串，!~ 是=~的取反，来颠倒“真”与“假”。\n\n无趣的基础知识终于结束了。\n\n2.定义函数\n```ruby\n>> def say_hello(name)\n>>    puts \"hi,#{name}\"\n>> end\n=> :say_hello\n>> say_hello \"xxx\"\nhi,xxx\n=> nil\n```\n每个函数都会返回结果。如果你没有显式指定某个返回值，函数就将返回退出函数前最后处理的表达式的值。像所有其他事物一样，函数也是个对象。\n\n3.代码块和yield\n\n代码块是包括在花括号（习惯上，代码在一行时使用花括号）或者do/end（习惯上，多行代码使用do/end）对中的能与参数一起传递的多个处理的集合。看一下昨天的一个习题，看是怎么使用代码块的：\n```ruby\n>> (1..2).each {|i| puts \"This is sentence number #{i}\"}\nThis is sentence number 1\nThis is sentence number 2\n```\n这有点类似于C++中将一个函数指针传给一个方法，然后在方法中调用这个函数。那Ruby是怎样调用这个代码块的呢？让我们来自己来实现一个类似each方法my_each：\n```ruby\n>> (1..2).my_each { |x| p x }\nNoMethodError: undefined method `my_each' for 1..2:Range\nfrom (irb):1\nfrom d:/Ruby22/bin/irb:11:in `<main>'\n```\n在还没有为Range添加my_each实例方法前，会提示错误，下面为Range添加一个实例方法：\n```ruby\n>> class Range\n>>      def my_each\n>>         f = first\n>>         l = last\n>>         e = first\n>>         loop do\n?>             yield e\n>>             break self if e == l\n>>             e = e.succ\n>>         end\n>>      end\n>> end\n=> :my_each\n>> (1..2).my_each { |x| p x }\n1\n2\n```\n从这个例子可以看出，代码块的使用和调用方法，调用方法时将代码块紧接在方法之后，在方法中通过yield调用传过来的代码块。这个例子有个值得一提的地方，我们居然给一个基本数据类型Range添加了一个方法，这里面的奥秘以后再详细介绍。\n\n代码块能让你把可执行代码派发给其他方法。除此之外，代码块还有延迟执行等诸多作用。\n\n4.定义类\n根据以往的经验，面向对象编程意味着要将大量的时间用于定义类。在Java，C++等面向对象编程语言当中，类的定义只是在跟编译器签订契约，约定类的各种行为。此时，编译器其实并没有做什么实质性的工作，直到创建对象，然后调用方法才会有实际的工作。\n\nRuby于此有所不同，Ruby中的类在定义时就已经是实实在在的执行类中的代码了。\nRuby也支持继承，Ruby中的类只能继承自一个类。看代码：\n```ruby\n>> 4.class\n=> Fixnum\n>> 4.class.superclass\n=> Integer\n>> 4.class.superclass.superclass\n=> Numeric\n>> 4.class.superclass.superclass.superclass\n=> Object\n>> 4.class.superclass.superclass.superclass.superclass\n=> BasicObject\n>> 4.class.superclass.superclass.superclass.superclass.superclass\n=> nil\n```\n从这个继承关系，我们立刻就能得到Ruby中的继承关系图：\n{% asset_img 图二.png 图二 %}\n等等，再看看下面的代码：\n```ruby\n>> 4.class.class\n=> Class\n>> 4.class.class.superclass\n=> Module\n>> 4.class.class.superclass.superclass\n=> Object\n>> 4.class.class.superclass.superclass.superclass\n=> BasicObject\n>> 4.class.class.superclass.superclass.superclass.superclass\n=> nil\n```\n我们根据这个关系，又能得出如下关系图：\n{% asset_img  图三.jpg 图三 %}\n请注意第一句话，4.class.class，4.class是Fixnum：说明4是Fixnum的实例对象，4.class.class即Fixnum.class是Class（请注意这里的大小写），这里表示，Fixnum是Class的实例对象，什么鬼？一个类是另一个类的实例!!!这是要逆天吗？好吧，先来看看书上的继承图（图中少了BasicObject类， Ruby1.9之前是没有BasicObject）：\n{% asset_img 图四.png 图四 %}\n现在来解释解释：一切从我们的口号说起：一切都是对象。明白了吗，上面的东西都是对象，类也是对象，不信，请看看下面的代码：\n```ruby\n>> Object.class\n=> Class\n>> Module.class\n=> Class\n>> Class.class\n=> Class\n>> Numeric.class\n=> Class\n>> Integer.class\n=> Class\n>> Fixnum.class\n=> Class\n```\n这些类都是Class类的对象，就连Class本身也是Class的对象。现在就能解释的通定义类时，其实在实例化一个对象，所以它在执行类中的代码（注意方法中的代码是不会执行的）很正常。根据Ruby中的命名规则（常量、类和模块都是以大写字母开头），可以知道，其实类就是一个Class类的实例常量。用图总结如下：\n{% asset_img 图五.jpg 图五 %}\n\n5.编写Mixin\n类已经可以定义了，接下来解决继承问题，由于Ruby是单继承的，那要怎样同时继承自两个及以上的类呢？Java通过接口，C++本来就支持多继承，Ruby是通过Mixin（混入）来实现的。其实就是定义一个module，然后把这个module包含近类。那么module中的方法就继承过来了。看代码：\n```ruby\n>> module M\n>> def m_func\n>> puts \"in M\"\n>> end\n>> end\n=> :m_func\n>> class C\n>> include M\n>> def c_func\n>> puts \"in C\"\n>> end\n>> end\n=> :c_func\n>> obj = C.new\n=> #<C:0x2483010>\n>> obj.m_func\nin M\n=> nil\n>> obj.c_func\nin C\n=> nil\n```\n从这个例子可以看出，通过Mixin技术，就能解决多继承问题，而且这种依赖关系是隐式的，不像Java使用接口实现的多继承，在Java中继承接口，必须显式实现接口中的方法。\n\n6. 模块、可枚举和集合\nRuby有两个至关重要的mixin： 枚举（enumerable）和比较（comparable） 。如果想让类可枚举，必须实现each方法；如果想让类可比较，必须实现<=>操作符。 <=>被人们叫做太空船操作符，它比较a、 b两操作数， b较大返回1， a较大返回1，相等返回0。为避免方法实现之苦，集合已实现了许多便于使用的可枚举和可比较的方法。如：由于整数已通过Fixnum类实现了太空船操作符，因此可以调用sort方法排序，还可以调用min和max方法计算最小值和最大值。举个可枚举的例子：\n```ruby\n>> a = [1,2,3,4,5]\n=> [1, 2, 3, 4, 5]\n>> a.inject(0) do |sum,i|\n?>    puts \"sum: #{sum}     i: #{i}     sum + i: #{sum + i}\"\n>>    sum + i\n>> end\nsum: 0     i: 1     sum + i: 1\nsum: 1     i: 2     sum + i: 3\nsum: 3     i: 3     sum + i: 6\nsum: 6     i: 4     sum + i: 10\nsum: 10     i: 5     sum + i: 15\n=> 15\n```\n7.小结\n今天主要是简单介绍了一些关于基本数据类型、函数、代码块、类、模块和Mixin。集合简直太好用了：用得最多的两个集合都带有众多API。 Ruby关注的是程序员的效率，应用程序的效率是次要的。枚举模块让你品尝到Ruby良好设计的味道，单继承的面向对象结构虽不是什么新鲜事物，但Ruby的实现充满了符合直觉和实用的特性。如此程度的抽象并没有为Ruby带来本质上的变化，真正点石成金的魔法还在后面。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"读书笔记：Ruby篇（二）","published":1,"updated":"2016-07-15T10:24:57.683Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9svqi0001tkb9mzsbat3u"},{"title":"读书笔记：Ruby篇（三）","date":"2015-07-29T14:35:00.000Z","_content":"\n引用一位“名人”的话：“世界上唯一不变的，就是什麽都在变”作为今天的开始。一切的乐趣就是在这无穷的变化之中。还记得在培训那会儿，迪奥斯·乔说过一句让人深省的话：“不是不能理解，只是不能适应，这种强加而来的编程方式，一切都要按照这个框架来”。当时，乔刚刚熟练C语言，继而进入MFC的世界，这种不适感体现的相当明显。从相当自由，一切都由自己掌控的C，到一切都要按照MFC框架的各种规则行事，这确实让人难以接受。面对这种困境，我们有两种选择，一种是改变自己，让自己适应这种被别人安排好的命运。还有一种就是改变你周遭的事物，让其适应我们的习惯存在着。我相信大部分人会选择后者，因为我们心向自由。今天就让我们来改变一下Ruby，编写一个能写程序的程序——元编程。只有改变一门语言的本来面目和行为方式，你才算真正掌握了赋予编程无穷乐趣的魔法。\n\n1.对象模型\n\n什么是对象模型？对象模型是所有语言构件所存在的系统。那什么是语言构件呢？语言构件就是组成语言的各个部件，如：类、模块、对象、方法等等。说白了就是类似于现实世界的一个抽象世界，组成在个抽象世界的不是现实世界中鸡猫狗，而是类、模块、对象等等。讲对象模型，就是搞清楚这些组成部件之间的关系，及它们之间的相互影响，就像要了解真实社会就要了解人际关系一样。现在让我们进入对象模型的世界：\n<!--more-->\n1.1 类的定义\n\n前一天，简单的提了一下类的定义，但是我们并没有定义出一个具体的类，今天我们详细了解一下类。\n\n类的定义方法：\n```ruby\nclass 类名\n     ……\n     语句\n     ……\n     def 类方法\n          方法语句\n          ……\n     end\n     ……\nend\n```\n说明：\na）类名必须是一大写字母开头；\nb）方法定义与函数定义一样；\nc）类定义语句和其他语句没有本质区别，你可以在类定义中放置任意语句。\n\n对于第三点的进一步说明：\n```ruby\n3.times do\n    class MyClass\n        puts \"Hello\"\n    end\nend\nHello\nHello\nHello\n```\n输出了3次Hello，像执行其它代码一样，Ruby执行了类定义中的代码。有人或许会认为这里定义了三个同名的类。这是真的吗？请看代码：\n```ruby\nclass MyClass\n    def x; 'x'; end\nend\nclass MyClass\n    def y; 'y'; end\nend\nobj = MyClass.new\nobj.x\n=> \"x\"\nobj.y\n=> \"y\"\n```\n 从上面的例子中可以看出，它们是同一个类。第一次定义一个类时，类不存在，Ruby开始定义这个类，第二次定义这个类时，它已经存在，Ruby不再定义它，而是重新打开这个已存在的类，并为之添加新的定义。\n从某种意义上说关键字class更像是一个作用域操作符而不是类型声明语句，它的核心任务是把你带到类的上下文，让你可以在其中定义方法。昨天my_each这个例子其实就是这种情况。你总是可以重新打开已经存在的类并对它进行动态修改，这种技术称之为\"Open Class（开放类）\"。\n\n这项技术好像挺酷炫的，可以给任何类添加你想添加的功能。从这句话我们能清楚的听出，这是有问题的。当你给一个类添加一个新方法时，可能这个类已经有了这个方法，只是你不知道而已，这个时候，可能就会带来灾难。因此，有人给这种修订类的方式起了一个不太好听的名字：Monkeypatch（猴子补丁）。\n\n1.2 类的真相\n\n昨天，我通过分析得到类其就是对象这个结论，这点是毋庸置疑的。其实，在Java和C#中类也是名为Class类的实例，甚至在C#中有一种与Open Class功能相似的功能扩展方法，C#使用扩展方法为类添加新的方法。不过，在Java和C#中类的功能比对象的功能有限的多。\n\n既然一切都是对象，那我们先来分析一下对象，对象中有什么呢？上代码：\n```ruby\n>> class MyClass\n>>   def my_method\n>>     @v = 1\n>>   end\n>> end\n=> :my_method\n>> obj1 = MyClass.new\n=> #<MyClass:0x00000002f61330>\n>> obj1.my_method\n=> 1\n>> obj2 = MyClass.new\n=> #<MyClass:0x000000029bafa8>\n```\n说明：\na）定义了一个类MyClass，类中定义一个实例方法（my_method），和一个实例变量（@v）；\nb）通过类创建了两个对象obj1和obj2。\n\n在类中除了可以定实例方法、实例变量，还可以定义类方法、类变量，这些待会在介绍。通过这个例子我们可以知道在对象中应该是有实例变量和实例方法的。但是如果类中定义了实例变量，在对象中是否就一定有这个实例变量呢？代码说明一切：\n```ruby\n>> obj1.instance_variables\n=> [:@v]\n>> obj2.instance_variables\n=> []\n```\nobj1调用了my_method()方法，产生了@v实例变量，而obj2没有调用，它没有任何实例变量。这与静态语言（如Java）不一样的地方，在Ruby中对象的类和他的实例变量没有关系，当给实例变量赋值时，他们就生成了。因此，对于同一个类，你可以创建具有不同实例变量的对象。\n\n对象中除了有实例变量，还有方法。那方法存放在对象中吗？这个我们可以想象一下，每一个对象都有一份方法的拷贝，这明显不合理，存放在对象的类中，应该是最合理的选择，这样所有对象都可以共享代码。总结一下：一个对象的实例变量存放在对象本身，而一个对象的方法存放于对象所属的类，这就是为什么同一个类的对象共享方法，而不共享实例变量的原因。\n\n现在有一个问题：我们知道类也是对象，那么刚才的那些规则是否也同样适用于类呢？是否也有类似的变量和方法呢？答案是肯定的，我们根据对象的规则来推导一下类。每个对象都有自己的实例变量，而所有对象共享方法。上面例子中obj1是类MyClass的对象，而我们知道所有的类都是类Class的对象。我们用仿上面的代码看看结果：\n```ruby\n>> class Class\n>>   def my_method\n>>     @v = 1\n>>   end\n>> end\n=> :my_method\n>> class MyClass1\n>> end\n=> nil\n>> class MyClass2\n>> end\n=> nil\n>> MyClass1.my_method\n=> 1\n>> MyClass1.instance_variables\n=> [:@v]\n>> MyClass2.instance_variables\n=> []\n```\n与一般对象一样，一个对象的方法是它所属类的实例方法。这就意味着一个类的方法就是Class的实例方法：\n```ruby\n>> Class.instance_methods(false)\n=> [:allocate, :new, :superclass, :my_method]\n```\n看到刚刚我么添加进去的方法了吧，而且你可以看到还有一个我们非常熟悉的new()方法，这是每个类都具有的类方法，我们创建对象用的就是这个类方法。allocate()方法是用来支撑new()方法的。superclass()方法用来返回一个类的超类。根据昨天的分析，我们知道Class的超类是Module，也就是说一个类只不过是一个增强的Module，只是添加了三个方法——new()、allocate()和superclass()而已，所以适用于类的规则大部分同样适用于Module。同时，可以看出Module不能实例化，因为它没有new方法。普通的变量是通过一个变量来引用它，而类是用一个常量来引用而已。\n\n再来看看那个类的实例变量，这里要强调一下，这是类的实例变量，而不是类变量，昨天已经提到过，类变量是以@@开头的变量，现在我们所说的类实例变量是只有一个@符的变量，不要搞混了。类变量是可以被子类或者类的实例（即对象）所使用，类变量与Java中的静态成员更为相似。但是类变量有一个很不好的怪癖：\n```ruby\n>> @@v = 1\n(irb):1: warning: class variable access from toplevel\n=> 1\n>> class MyClass\n>>   @@v = 2\n>> end\n=> 2\n>> p @@v\n(irb):5: warning: class variable access from toplevel\n2\n=> 2\n```\n修改MyClass的类变量，顶级域下的一个类变量的值也发生了改变。具体原因，之后再解释。\n\n对象和类的小结：对象是一组实例变量外加一个指向其类的引用。对象的方法并不存在于对象本身，而是存在与对象的类中。在类中，这些方法成为类的实例方法。类是一个对象（Class类的一个实例）外加一组实例方法和一个对其超类的引用。Class类是Module类的子类，因此一个类也是一个模块。类和对象本质是一样的，都有自己的实例方法和实例变量，只是叫法不一样而已。跟其他对象一样，类必须通过引用进行访问，只不过对象是通过变量，而类是通过常量（即类名）而已。最后给出一张图归纳一下：\n{% asset_img 图一.png 图一 %}\n\n 1.3 Ruby调用一个方法时发生了什么\n\n当你使用obj1.my_method()调用方法时，Ruby是怎么做到的呢？答案其实很简单，Ruby只做了下面两件事，就实现了代码调用：\n\n1）找到这个方法。这个过程称为方法查找；\n\n2）执行这个方法。为了做到这点，Ruby需要一个叫做self的东西。\n\n1.3.1方法查找\n\n先来明确两个概念：接收者（receiver）和祖先链（ancestors chain）。接收者调用方法的那个对象，如：obj1.my_method()，obj1就是接收者。祖先链就是从对象所属类开始，逐个指向超类，直到BasicObject为止所形成的链路，如：从obj1的类MyClass开始，找到MyClass的超类Object，再找到Object的超类BasicObject，MyClass到Object再到BasicObject就是obj1的祖先链，这个定义有些问题，不过现在可以先这么理解。\n\n下面来看看怎么找到一个方法：\n```ruby\n>> class MyClass\n>>   def my_method;'my_method()';end\n>> end\n=> :my_method\n>> class MySubclass < MyClass\n>> end\n=> nil\n>> obj = MySubclass.new\n=> #<MySubclass:0x00000003392af8>\n>> obj.my_method()\n=> \"my_method()\"\n```\n补充一点知识：class MySubclass < MyClass表示MySubclass继承自MyClass。\n\n由于实例方法都保存在类中，所以当一个对象调用一个方法时，首先是找到对象所属的类，看看有没有要调用的方法，如果存在，则执行该方法；否则，则沿着祖先链向上找到该类的父类，在判断是否存在该方法，如果存在，则执行，否则，接着找，知道找到，并执行，如果整个祖先链都不存在，则报错。用这个方法分析一下我们的例子：从obj出发，找到obj所属类MySubclass，在MySubclass中没有找到my_method()方法，然后接着找MySubclass的超类MyClass，此时找到了my_method()方法，最后执行这个方法。\n\n上面是比较简单的一种情况，让我们考虑一下多继承：\n```ruby\n>> module M\n>>   def my_method\n>>     'M#my_method()'\n>>   end\n>> end\n>> class E\n>>   def my_method\n>>     'E#my_method()'\n>>   end\n>> end\n>> class F < E\n>>   include M\n>> end\n=> F\n>> F.new.my_method()\n=> \"M#my_method()\"\n```\nF类继承自E，同时通过Mixin方式include了模块M，而且此时E和M同时拥有一个my_method()方法。从最后的结果可以看出，F的对象调用my_method()最后找到的是模块M中的my_method()。这就是为什么说刚才的哪个祖先链的定义有问题，祖先链不仅仅只包含超类（也叫父类），还应该包含include进来的模块。而且他们寻找的顺序是：对象所属的类，对象所属类include进来的模块，而且如果有多个模块，那么查找顺序与include的顺序相反，然后才是超类，再后是超类include进来的模块，以此类推直到BasicObject。其实有一个很简单的方法可以查看祖先链：\n```ruby\n>> F.ancestors\n=> [F, M, E, Object, Kernel, BasicObject]\n```\n这里面的Kernel，应该是一个模块，因为我们使用Object.superclass发现是BasicObject，也就是说Kernel是在Object类中include进来的一个模块。这个模块提供了很多让我们在任意代码中调用的函数，比如：print()等。由于我们创建的对象都是Object的子类，所以，当你给Kernel模块添加方法，其实就相当于添加一个内核方法，我们创建的类都能调用，哪怕它是一个私有方法！这里面的原因后面会详解。最后用一张图来加深F对象的方法查找：\n{% asset_img 图二.png 图二 %}\n\n1.3.2 执行方法\n代码的执行使用代码本身和代码所处的上下文决定，例如：\n```ruby\n>> def my_method\n>>   x = \"Goodbye\"\n>>   yield(\"cruel\")\n>> end\n>> x = \"Hello\"\n>> my_method {|y| \"#{x}, #{y} world\"}\n=> \"Hello, cruel world\"\n```\n我们将这段代码拆解成代码和上下文，代码本事就是上面的定义和代码块，那上下文是什么么呢？简单点说就是执行这段代码时的环境，比如：引用的的是哪个变量及变量当时的值，调用方法时，该调用哪个类或者模块的方法等等。为了弄明白这些，先来看两个概念：作用域和生存期。作用域指的是变量的可见范围。看例子：\n```ruby\n>> v1 = 1\n>> class MyClass\n>>   v2 = 2\n>>   p local_variables\n>>   def my_method\n>>     v3 = 3\n>>     p local_variables\n>>   end\n>>   p local_variables\n>> end\n[:v2]\n[:v2]\n>> obj = MyClass.new\n>> obj.my_method\n[:v3]\n>> obj.my_method\n[:v3]\n>> p local_variables\n[:obj, :v1, :_]\n```\n在类定义中的局部变量是v2，v1和v3不可见，即类定义时，不是v1和v3的作用域；在class定义外的局部变量是obj和v1，此时不是v2和v3的作用域；在类定义中的实例方法的定义中的局部变量是v3，此时不是v1和v2的作用域。由此可以看出：在Ruby中作用域的分界是由class、def和module关键词分开的，这些关键字都是一个作用域门（Scope Gate），当遇到一个作用域门，都会进行作用域切换。而且，在Ruby中没有作用域嵌套，外层作用域的变量在内层作用域不可见，比如v2在方法中不可见。在class/module与def之间还有一点微妙的差别。在类和模块定义中的代码会立刻执行，而方法中的代码只会在调用时执行。\n\n再来看看生存期，变量的存在范围叫做生存期。拿刚才的哪个例子来说，局部变量v1在obj调用my_method时，作用域虽然进行了切换，在my_method中v1不可见，但是v1确实还存在，并没有被系统回收，当再次切换回之前的作用域时v1变量的有可见了。这就是生存期。\n\n这两个概念都弄明白了后，我们回到上下文。在上下文中有一个非常重要的对象self，每一行代码都会在一个对象中执行——这个对象就是所谓的当前对象，也就是self。\n\n<font color=red size=4>在给定时刻，只有一个对象能充当但前对象，但没有哪个对象能长期充当这一角色。特别地，当调用一个方法时，接收者就成为了self，当定义类或模块时，该类或者模块就是self。从这一刻起，所有的实例变量都是self的实例变量，所有没有指明接收者的方法都是在self上调用。当你调用其他对象的方法时，这个对象成为了self。</font>\n\n看代码：\n```ruby\n>> class C\n>> private\n>>   def my_private_method\n>>     p \"in C private method\"\n>>   end\n>> end\n>> class D < C\n>>   @v = 1\n>>   def D.my_class_method\n>>     p \"in D class method\"\n>>     p \"@v = #{@v}\"\n>>   end\n>>   def my_method\n>>     p \"in C method\"\n>>     p \"@v = #{@v}\"\n>>     my_private_method\n>>   end\n>> end\n>> obj = D.new\n>> obj.my_method\n\"in C method\"\n\"@v = \"\n\"in C private method\"\n>> D.my_class_method\n\"in D class method\"\n\"@v = 1\"\n```\n说明：\n\n1）当obj调用my_method时，这时obj对象就是self，所以在my_method中，@v就是对象obj的实例变量，由于@v没有初始化第一次使用，所以会输出\"@v = \"，有人会说不对，@v不是在在之前赋值了吗？不请注意作用域，赋值的那条语句是在类定义当中，而现在我们实在方法当中，它们的作用域不一样，有着不一样的self引用。\n\n2）在my_method对象实例方法中，还调用了my_private_method()方法，根据所有没有指明接收者的方法都是self调用，再根据方法的寻找规则，发现这个方法是超类的一个私有方法。这里先说明一下私有方法调用的唯一一条规则：不能明确指定一个接收者来调用一个私有方法，也就是说调用私有方法时，不能写成\"接收者.私有方法()\"，而是只能写成\"私有方法()\"，而Ruby还有一条规则：如果调用方法的接收者不是自己，则必须明确指明一个接收者。通过这两条规则得出：只能在自身中调用一个私有方法。这就是Ruby的私有方法所有要求，其他跟公有方法一样，这也就是说私有方法也是可以继承的，在子类中是可以调用父类的私有方法。但是，同一个类的两个对象x,y，x是不能调用y的私有方法的，例如：\n```ruby\n>> class Account\n>> private\n>> def balance\n>>   @balance\n>> end\n>> public\n>> def balance=(b)\n>>   @balance = b\n>> end\n>> def greater_balance_than(other)\n>>   return @balance > other.balance\n>> end\n>> end\n>> a = Account.new\n>> a.balance = 100\n>> b = Account.new\n>> b.balance = 200\n>> a.greater_balance_than(b)\nNoMethodError: private method `balance' called for #<Account:0x00000002f89e20 @balance=200>\n        from (irb):11:in `greater_balance_than'\n        from (irb):18\n        from d:/Ruby21-x64/bin/irb:11:in `<main>'\n```\n这就是Ruby中的私有方法，与Java和C#的处理方式截然不同。\n3）再来看看类方法my_class_method，我们已经知道类就是对象，也就是说调用my_class_method时的接收者就是D，此时self就是类D，而且类在定义时，self就是类本身：\n```ruby\n>> class C\n>> p self.object_id\n>> end\n24491100\n>> p C.object_id\n24491100\n```\n看到了吧，定义类事的self的对象ID和C的对象ID一样，也就是说self和C引用的是同一对象。所以，在类方法my_class_method中可以访问@v实例变量，因为它们同属一个对象。\n\n4）关于类方法的定义，根据前面的结论，我们知道所有类都是Class类的实例对象，只要在Class中添加一个实例方法就会为所有类添加一个类方法，但这显然是不合理的。从这个例子中我们知道可以在类定义中通过\"类名.方法名\"的方式来定义一个类方法。而且这个类方法只归这个类所有，要的就是这样一个效果。根据前面的经验，我们知道能应用于类的规则一般都能应用于对象，那是不是说我们也可以为对象添加一个只有某个对象特有的方法呢？答案还是肯定的，它就是单件方法。在进入单件方法之前，小结一下方法的执行：\n\n方法的执行主要是跟踪当前执行代码的上下文和上下文的切换，上下文中主要是一些变量、常量和self的状态，其中self的最为复杂，但是只要你记住上面关于self的规则，方法执行就很容易理解了。而上下文切换更简单，只要记住class、module和def这三个作用域门即可知道在什么时候切换，至于切换成到哪个上下文，还是要看方法的接收者（对象或者类）。\n\n1.3.3 Singleton Methods（单件方法）\n\n有的时候你可能会遇到这样一种尴尬的情况：\n```ruby\nclass Paragraph\n\n     def initialize(text)\n\n          @text = text\n\n     end\n\n     def title?; @text.upcase == @text; end\n\n     def reverse; @text.reverse;end\n\n     def upcase;@text.upcase;end\n\n     ……\n\nend\n```\nParagraph类对一个字符串进行了封装，然后所有的调用都代理到字符串中，仅仅除了title?()方法。当然，这个时候你可以让Paragraph继承自String或者不封装这一层，直接给String添加一个实例方法。无论封装还添加实例方法，都有不妥之处，封装吧，感觉多此一举，这个类用的根本不多，添加方法吧，让所有的字符串都添加这个方法，对库进行了污染。下面让我们来使用单件方法来为某个对象添加title?()方法，其实很简单：\n```ruby\n>> paragraph = \"this is a paragraph\"\n=> \"this is a paragraph\"\n>> def paragraph.title?\n>>   self.upcase == self\n>> end\n=> :title?\n>> paragraph.title?\n=> false\n>> str = \"this is a string\"\n=> \"this is a string\"\n>> str.title?\nNoMethodError: undefined method `title?' for \"this is a string\":String\n        from (irb):7\n        from d:/Ruby21-x64/bin/irb:11:in `<main>'\n```\n从上面的代码可以看出，只给paragraph添加了方法title?()，而且定义单件方法的格式是：\n\ndef 对象.单件方法\n\nend\n\n这和类的类方法定义是一模一样的（再重复一遍类就是对象），这就是单件方法。\n\n一切看上去是这么的简单，但是我们在这问一问题：这个单件方法存放在哪呢？我们知道对象的实例变量存放在对象本身，这样每个对象都有不一样的实例变量，而对象的实例方法存放在类中，所有对象共享这些方法。现在的问题是，单件方法是某个对象独有，所以它不能存放在类中，难道它是存放在对象中？答案是否定的，在Ruby中，对象是不存放方法的，那它到底存放在何处？让我们进入到对象模型的最后一角——Eigenclass。\n\n1.4 Eigenclass\n\n当你用对象.class()获得对象所属类的时候，它对你说谎了，它把一个对象的直接父类隐藏亲来了，而告诉了这个类的父类（或叫超类），这个被隐藏的类就称为这个对象的eigenclass。一般情况下我们是无法感知它的存在的，不过我们可以通过Ruby基于class关键字的特殊语法，进入到eigenclass的作用域：\n```ruby\nclass << an_object\n#代码\nend\n例如：\n>> obj = Object.new\n>> eigenclass = class << obj\n>> self\n>> end\n>> eigenclass.object_id\n=> 1822180\n>> obj.object_id\n=> 26132360\n>> obj.class.object_id\n=> 1563580\n>> eigenclass.superclass.object_id\n=> 1563580\n```\neigenclass和obj的对象id不一样，但是obj所属类的对象id和eigenclass父类的对象id一样，但这也只能说明eigenclass类是obj所属类的子类，并不能证明obj是eigenclass的实例。好吧，要证明这个对象是这个类的实例，我们只要往这个类中添加一个新方法(my_test_method)，如果是这个类的对象就应该可以调用这个方法，上代码验证一下：\n```ruby\n>> obj.my_test_method\nNoMethodError: undefined method `my_test_method' for #<Object:0x00000002b91840>\n        from (irb):5\n        from d:/Ruby21-x64/bin/irb:11:in `<main>'\n>> class << obj\n>>   def my_test_method\n>>     p 'in eigenclass test method'\n>>   end\n>> end\n>> obj.my_test_method\n\"in eigenclass test method\"\n```\n和我们的预想一致，在没有添加my_test_method方法前，obj调用该方法会提示没有定义，为eigenclass添加my_test_method方法后，obj就有了这个方法。有才可以得出：obj就是eigenclass的实例对象。\n\n说到这你有没有明白点什么呢？在eigenclass中添加一个方法，obj就有了这个方法，而在obj.class得到的类中是不存在这个方法的，也就是说我们的单件方法就是存在eigenclass中。上添加的my_test_method就是obj的单件方法，于是我们得到了第二种添加单件方法的方法。同理你知道怎么给类添加类方法吗？\n\n最后重新整理一下方法查找的路径（用\"#C\"表示C的eigenclass）：\n{% asset_img 图三.png 图三 %}\n\n关于类的eigenclass，这里就不重复了，虽然有点不一样，但原理差不多。\n\n1.5 总结\n\nRuby的对象模型真的是迷人，虽然里面有类、eigenclass、模块、实例方法、类方法和单件方法，但是它是如此的统一。如果把eigenclass、普通类和模块放到一起，Ruby对象模型可以总结为7条规则：\n\n1）只有一种对象——要买是普通对象，要买是模块；\n2）只有一种模块——可以是普通模块、类、eigenclass或者代理类；\n3）只有一个方法，他存在于一种模块中——通常是类中；\n4）每个对象（包括类）都有自己的“真正的类”——要么是普通类，要么是eigenclass；\n5）除了BasicObject类（在Ruby 1.8中是object类）无超类外，每个类都有且只有一个超类。这意味着从任何类只有一条向上直到BasicObject的祖先链；\n6）一个对象的eigenclass的超类是这个对象的类；一个类的eigenclass的超类是这个类的超类的eigenclass;\n7）当调用一个方法，Ruby先向进入接收者真正的类，然后进入祖先链，这就是Ruby查找方法的全部内容。\n\n这就是Ruby的对象模型的全部内容。接下来让我们用Ruby编写能够编写代码的代码。\n\n未完待续……","source":"_posts/读书笔记：Ruby篇（三）.md","raw":"title: 读书笔记：Ruby篇（三）\ntags:\n  - Ruby\ncategories:\n  - Ruby\ndate: 2015-07-29 22:35:00\n---\n\n引用一位“名人”的话：“世界上唯一不变的，就是什麽都在变”作为今天的开始。一切的乐趣就是在这无穷的变化之中。还记得在培训那会儿，迪奥斯·乔说过一句让人深省的话：“不是不能理解，只是不能适应，这种强加而来的编程方式，一切都要按照这个框架来”。当时，乔刚刚熟练C语言，继而进入MFC的世界，这种不适感体现的相当明显。从相当自由，一切都由自己掌控的C，到一切都要按照MFC框架的各种规则行事，这确实让人难以接受。面对这种困境，我们有两种选择，一种是改变自己，让自己适应这种被别人安排好的命运。还有一种就是改变你周遭的事物，让其适应我们的习惯存在着。我相信大部分人会选择后者，因为我们心向自由。今天就让我们来改变一下Ruby，编写一个能写程序的程序——元编程。只有改变一门语言的本来面目和行为方式，你才算真正掌握了赋予编程无穷乐趣的魔法。\n\n1.对象模型\n\n什么是对象模型？对象模型是所有语言构件所存在的系统。那什么是语言构件呢？语言构件就是组成语言的各个部件，如：类、模块、对象、方法等等。说白了就是类似于现实世界的一个抽象世界，组成在个抽象世界的不是现实世界中鸡猫狗，而是类、模块、对象等等。讲对象模型，就是搞清楚这些组成部件之间的关系，及它们之间的相互影响，就像要了解真实社会就要了解人际关系一样。现在让我们进入对象模型的世界：\n<!--more-->\n1.1 类的定义\n\n前一天，简单的提了一下类的定义，但是我们并没有定义出一个具体的类，今天我们详细了解一下类。\n\n类的定义方法：\n```ruby\nclass 类名\n     ……\n     语句\n     ……\n     def 类方法\n          方法语句\n          ……\n     end\n     ……\nend\n```\n说明：\na）类名必须是一大写字母开头；\nb）方法定义与函数定义一样；\nc）类定义语句和其他语句没有本质区别，你可以在类定义中放置任意语句。\n\n对于第三点的进一步说明：\n```ruby\n3.times do\n    class MyClass\n        puts \"Hello\"\n    end\nend\nHello\nHello\nHello\n```\n输出了3次Hello，像执行其它代码一样，Ruby执行了类定义中的代码。有人或许会认为这里定义了三个同名的类。这是真的吗？请看代码：\n```ruby\nclass MyClass\n    def x; 'x'; end\nend\nclass MyClass\n    def y; 'y'; end\nend\nobj = MyClass.new\nobj.x\n=> \"x\"\nobj.y\n=> \"y\"\n```\n 从上面的例子中可以看出，它们是同一个类。第一次定义一个类时，类不存在，Ruby开始定义这个类，第二次定义这个类时，它已经存在，Ruby不再定义它，而是重新打开这个已存在的类，并为之添加新的定义。\n从某种意义上说关键字class更像是一个作用域操作符而不是类型声明语句，它的核心任务是把你带到类的上下文，让你可以在其中定义方法。昨天my_each这个例子其实就是这种情况。你总是可以重新打开已经存在的类并对它进行动态修改，这种技术称之为\"Open Class（开放类）\"。\n\n这项技术好像挺酷炫的，可以给任何类添加你想添加的功能。从这句话我们能清楚的听出，这是有问题的。当你给一个类添加一个新方法时，可能这个类已经有了这个方法，只是你不知道而已，这个时候，可能就会带来灾难。因此，有人给这种修订类的方式起了一个不太好听的名字：Monkeypatch（猴子补丁）。\n\n1.2 类的真相\n\n昨天，我通过分析得到类其就是对象这个结论，这点是毋庸置疑的。其实，在Java和C#中类也是名为Class类的实例，甚至在C#中有一种与Open Class功能相似的功能扩展方法，C#使用扩展方法为类添加新的方法。不过，在Java和C#中类的功能比对象的功能有限的多。\n\n既然一切都是对象，那我们先来分析一下对象，对象中有什么呢？上代码：\n```ruby\n>> class MyClass\n>>   def my_method\n>>     @v = 1\n>>   end\n>> end\n=> :my_method\n>> obj1 = MyClass.new\n=> #<MyClass:0x00000002f61330>\n>> obj1.my_method\n=> 1\n>> obj2 = MyClass.new\n=> #<MyClass:0x000000029bafa8>\n```\n说明：\na）定义了一个类MyClass，类中定义一个实例方法（my_method），和一个实例变量（@v）；\nb）通过类创建了两个对象obj1和obj2。\n\n在类中除了可以定实例方法、实例变量，还可以定义类方法、类变量，这些待会在介绍。通过这个例子我们可以知道在对象中应该是有实例变量和实例方法的。但是如果类中定义了实例变量，在对象中是否就一定有这个实例变量呢？代码说明一切：\n```ruby\n>> obj1.instance_variables\n=> [:@v]\n>> obj2.instance_variables\n=> []\n```\nobj1调用了my_method()方法，产生了@v实例变量，而obj2没有调用，它没有任何实例变量。这与静态语言（如Java）不一样的地方，在Ruby中对象的类和他的实例变量没有关系，当给实例变量赋值时，他们就生成了。因此，对于同一个类，你可以创建具有不同实例变量的对象。\n\n对象中除了有实例变量，还有方法。那方法存放在对象中吗？这个我们可以想象一下，每一个对象都有一份方法的拷贝，这明显不合理，存放在对象的类中，应该是最合理的选择，这样所有对象都可以共享代码。总结一下：一个对象的实例变量存放在对象本身，而一个对象的方法存放于对象所属的类，这就是为什么同一个类的对象共享方法，而不共享实例变量的原因。\n\n现在有一个问题：我们知道类也是对象，那么刚才的那些规则是否也同样适用于类呢？是否也有类似的变量和方法呢？答案是肯定的，我们根据对象的规则来推导一下类。每个对象都有自己的实例变量，而所有对象共享方法。上面例子中obj1是类MyClass的对象，而我们知道所有的类都是类Class的对象。我们用仿上面的代码看看结果：\n```ruby\n>> class Class\n>>   def my_method\n>>     @v = 1\n>>   end\n>> end\n=> :my_method\n>> class MyClass1\n>> end\n=> nil\n>> class MyClass2\n>> end\n=> nil\n>> MyClass1.my_method\n=> 1\n>> MyClass1.instance_variables\n=> [:@v]\n>> MyClass2.instance_variables\n=> []\n```\n与一般对象一样，一个对象的方法是它所属类的实例方法。这就意味着一个类的方法就是Class的实例方法：\n```ruby\n>> Class.instance_methods(false)\n=> [:allocate, :new, :superclass, :my_method]\n```\n看到刚刚我么添加进去的方法了吧，而且你可以看到还有一个我们非常熟悉的new()方法，这是每个类都具有的类方法，我们创建对象用的就是这个类方法。allocate()方法是用来支撑new()方法的。superclass()方法用来返回一个类的超类。根据昨天的分析，我们知道Class的超类是Module，也就是说一个类只不过是一个增强的Module，只是添加了三个方法——new()、allocate()和superclass()而已，所以适用于类的规则大部分同样适用于Module。同时，可以看出Module不能实例化，因为它没有new方法。普通的变量是通过一个变量来引用它，而类是用一个常量来引用而已。\n\n再来看看那个类的实例变量，这里要强调一下，这是类的实例变量，而不是类变量，昨天已经提到过，类变量是以@@开头的变量，现在我们所说的类实例变量是只有一个@符的变量，不要搞混了。类变量是可以被子类或者类的实例（即对象）所使用，类变量与Java中的静态成员更为相似。但是类变量有一个很不好的怪癖：\n```ruby\n>> @@v = 1\n(irb):1: warning: class variable access from toplevel\n=> 1\n>> class MyClass\n>>   @@v = 2\n>> end\n=> 2\n>> p @@v\n(irb):5: warning: class variable access from toplevel\n2\n=> 2\n```\n修改MyClass的类变量，顶级域下的一个类变量的值也发生了改变。具体原因，之后再解释。\n\n对象和类的小结：对象是一组实例变量外加一个指向其类的引用。对象的方法并不存在于对象本身，而是存在与对象的类中。在类中，这些方法成为类的实例方法。类是一个对象（Class类的一个实例）外加一组实例方法和一个对其超类的引用。Class类是Module类的子类，因此一个类也是一个模块。类和对象本质是一样的，都有自己的实例方法和实例变量，只是叫法不一样而已。跟其他对象一样，类必须通过引用进行访问，只不过对象是通过变量，而类是通过常量（即类名）而已。最后给出一张图归纳一下：\n{% asset_img 图一.png 图一 %}\n\n 1.3 Ruby调用一个方法时发生了什么\n\n当你使用obj1.my_method()调用方法时，Ruby是怎么做到的呢？答案其实很简单，Ruby只做了下面两件事，就实现了代码调用：\n\n1）找到这个方法。这个过程称为方法查找；\n\n2）执行这个方法。为了做到这点，Ruby需要一个叫做self的东西。\n\n1.3.1方法查找\n\n先来明确两个概念：接收者（receiver）和祖先链（ancestors chain）。接收者调用方法的那个对象，如：obj1.my_method()，obj1就是接收者。祖先链就是从对象所属类开始，逐个指向超类，直到BasicObject为止所形成的链路，如：从obj1的类MyClass开始，找到MyClass的超类Object，再找到Object的超类BasicObject，MyClass到Object再到BasicObject就是obj1的祖先链，这个定义有些问题，不过现在可以先这么理解。\n\n下面来看看怎么找到一个方法：\n```ruby\n>> class MyClass\n>>   def my_method;'my_method()';end\n>> end\n=> :my_method\n>> class MySubclass < MyClass\n>> end\n=> nil\n>> obj = MySubclass.new\n=> #<MySubclass:0x00000003392af8>\n>> obj.my_method()\n=> \"my_method()\"\n```\n补充一点知识：class MySubclass < MyClass表示MySubclass继承自MyClass。\n\n由于实例方法都保存在类中，所以当一个对象调用一个方法时，首先是找到对象所属的类，看看有没有要调用的方法，如果存在，则执行该方法；否则，则沿着祖先链向上找到该类的父类，在判断是否存在该方法，如果存在，则执行，否则，接着找，知道找到，并执行，如果整个祖先链都不存在，则报错。用这个方法分析一下我们的例子：从obj出发，找到obj所属类MySubclass，在MySubclass中没有找到my_method()方法，然后接着找MySubclass的超类MyClass，此时找到了my_method()方法，最后执行这个方法。\n\n上面是比较简单的一种情况，让我们考虑一下多继承：\n```ruby\n>> module M\n>>   def my_method\n>>     'M#my_method()'\n>>   end\n>> end\n>> class E\n>>   def my_method\n>>     'E#my_method()'\n>>   end\n>> end\n>> class F < E\n>>   include M\n>> end\n=> F\n>> F.new.my_method()\n=> \"M#my_method()\"\n```\nF类继承自E，同时通过Mixin方式include了模块M，而且此时E和M同时拥有一个my_method()方法。从最后的结果可以看出，F的对象调用my_method()最后找到的是模块M中的my_method()。这就是为什么说刚才的哪个祖先链的定义有问题，祖先链不仅仅只包含超类（也叫父类），还应该包含include进来的模块。而且他们寻找的顺序是：对象所属的类，对象所属类include进来的模块，而且如果有多个模块，那么查找顺序与include的顺序相反，然后才是超类，再后是超类include进来的模块，以此类推直到BasicObject。其实有一个很简单的方法可以查看祖先链：\n```ruby\n>> F.ancestors\n=> [F, M, E, Object, Kernel, BasicObject]\n```\n这里面的Kernel，应该是一个模块，因为我们使用Object.superclass发现是BasicObject，也就是说Kernel是在Object类中include进来的一个模块。这个模块提供了很多让我们在任意代码中调用的函数，比如：print()等。由于我们创建的对象都是Object的子类，所以，当你给Kernel模块添加方法，其实就相当于添加一个内核方法，我们创建的类都能调用，哪怕它是一个私有方法！这里面的原因后面会详解。最后用一张图来加深F对象的方法查找：\n{% asset_img 图二.png 图二 %}\n\n1.3.2 执行方法\n代码的执行使用代码本身和代码所处的上下文决定，例如：\n```ruby\n>> def my_method\n>>   x = \"Goodbye\"\n>>   yield(\"cruel\")\n>> end\n>> x = \"Hello\"\n>> my_method {|y| \"#{x}, #{y} world\"}\n=> \"Hello, cruel world\"\n```\n我们将这段代码拆解成代码和上下文，代码本事就是上面的定义和代码块，那上下文是什么么呢？简单点说就是执行这段代码时的环境，比如：引用的的是哪个变量及变量当时的值，调用方法时，该调用哪个类或者模块的方法等等。为了弄明白这些，先来看两个概念：作用域和生存期。作用域指的是变量的可见范围。看例子：\n```ruby\n>> v1 = 1\n>> class MyClass\n>>   v2 = 2\n>>   p local_variables\n>>   def my_method\n>>     v3 = 3\n>>     p local_variables\n>>   end\n>>   p local_variables\n>> end\n[:v2]\n[:v2]\n>> obj = MyClass.new\n>> obj.my_method\n[:v3]\n>> obj.my_method\n[:v3]\n>> p local_variables\n[:obj, :v1, :_]\n```\n在类定义中的局部变量是v2，v1和v3不可见，即类定义时，不是v1和v3的作用域；在class定义外的局部变量是obj和v1，此时不是v2和v3的作用域；在类定义中的实例方法的定义中的局部变量是v3，此时不是v1和v2的作用域。由此可以看出：在Ruby中作用域的分界是由class、def和module关键词分开的，这些关键字都是一个作用域门（Scope Gate），当遇到一个作用域门，都会进行作用域切换。而且，在Ruby中没有作用域嵌套，外层作用域的变量在内层作用域不可见，比如v2在方法中不可见。在class/module与def之间还有一点微妙的差别。在类和模块定义中的代码会立刻执行，而方法中的代码只会在调用时执行。\n\n再来看看生存期，变量的存在范围叫做生存期。拿刚才的哪个例子来说，局部变量v1在obj调用my_method时，作用域虽然进行了切换，在my_method中v1不可见，但是v1确实还存在，并没有被系统回收，当再次切换回之前的作用域时v1变量的有可见了。这就是生存期。\n\n这两个概念都弄明白了后，我们回到上下文。在上下文中有一个非常重要的对象self，每一行代码都会在一个对象中执行——这个对象就是所谓的当前对象，也就是self。\n\n<font color=red size=4>在给定时刻，只有一个对象能充当但前对象，但没有哪个对象能长期充当这一角色。特别地，当调用一个方法时，接收者就成为了self，当定义类或模块时，该类或者模块就是self。从这一刻起，所有的实例变量都是self的实例变量，所有没有指明接收者的方法都是在self上调用。当你调用其他对象的方法时，这个对象成为了self。</font>\n\n看代码：\n```ruby\n>> class C\n>> private\n>>   def my_private_method\n>>     p \"in C private method\"\n>>   end\n>> end\n>> class D < C\n>>   @v = 1\n>>   def D.my_class_method\n>>     p \"in D class method\"\n>>     p \"@v = #{@v}\"\n>>   end\n>>   def my_method\n>>     p \"in C method\"\n>>     p \"@v = #{@v}\"\n>>     my_private_method\n>>   end\n>> end\n>> obj = D.new\n>> obj.my_method\n\"in C method\"\n\"@v = \"\n\"in C private method\"\n>> D.my_class_method\n\"in D class method\"\n\"@v = 1\"\n```\n说明：\n\n1）当obj调用my_method时，这时obj对象就是self，所以在my_method中，@v就是对象obj的实例变量，由于@v没有初始化第一次使用，所以会输出\"@v = \"，有人会说不对，@v不是在在之前赋值了吗？不请注意作用域，赋值的那条语句是在类定义当中，而现在我们实在方法当中，它们的作用域不一样，有着不一样的self引用。\n\n2）在my_method对象实例方法中，还调用了my_private_method()方法，根据所有没有指明接收者的方法都是self调用，再根据方法的寻找规则，发现这个方法是超类的一个私有方法。这里先说明一下私有方法调用的唯一一条规则：不能明确指定一个接收者来调用一个私有方法，也就是说调用私有方法时，不能写成\"接收者.私有方法()\"，而是只能写成\"私有方法()\"，而Ruby还有一条规则：如果调用方法的接收者不是自己，则必须明确指明一个接收者。通过这两条规则得出：只能在自身中调用一个私有方法。这就是Ruby的私有方法所有要求，其他跟公有方法一样，这也就是说私有方法也是可以继承的，在子类中是可以调用父类的私有方法。但是，同一个类的两个对象x,y，x是不能调用y的私有方法的，例如：\n```ruby\n>> class Account\n>> private\n>> def balance\n>>   @balance\n>> end\n>> public\n>> def balance=(b)\n>>   @balance = b\n>> end\n>> def greater_balance_than(other)\n>>   return @balance > other.balance\n>> end\n>> end\n>> a = Account.new\n>> a.balance = 100\n>> b = Account.new\n>> b.balance = 200\n>> a.greater_balance_than(b)\nNoMethodError: private method `balance' called for #<Account:0x00000002f89e20 @balance=200>\n        from (irb):11:in `greater_balance_than'\n        from (irb):18\n        from d:/Ruby21-x64/bin/irb:11:in `<main>'\n```\n这就是Ruby中的私有方法，与Java和C#的处理方式截然不同。\n3）再来看看类方法my_class_method，我们已经知道类就是对象，也就是说调用my_class_method时的接收者就是D，此时self就是类D，而且类在定义时，self就是类本身：\n```ruby\n>> class C\n>> p self.object_id\n>> end\n24491100\n>> p C.object_id\n24491100\n```\n看到了吧，定义类事的self的对象ID和C的对象ID一样，也就是说self和C引用的是同一对象。所以，在类方法my_class_method中可以访问@v实例变量，因为它们同属一个对象。\n\n4）关于类方法的定义，根据前面的结论，我们知道所有类都是Class类的实例对象，只要在Class中添加一个实例方法就会为所有类添加一个类方法，但这显然是不合理的。从这个例子中我们知道可以在类定义中通过\"类名.方法名\"的方式来定义一个类方法。而且这个类方法只归这个类所有，要的就是这样一个效果。根据前面的经验，我们知道能应用于类的规则一般都能应用于对象，那是不是说我们也可以为对象添加一个只有某个对象特有的方法呢？答案还是肯定的，它就是单件方法。在进入单件方法之前，小结一下方法的执行：\n\n方法的执行主要是跟踪当前执行代码的上下文和上下文的切换，上下文中主要是一些变量、常量和self的状态，其中self的最为复杂，但是只要你记住上面关于self的规则，方法执行就很容易理解了。而上下文切换更简单，只要记住class、module和def这三个作用域门即可知道在什么时候切换，至于切换成到哪个上下文，还是要看方法的接收者（对象或者类）。\n\n1.3.3 Singleton Methods（单件方法）\n\n有的时候你可能会遇到这样一种尴尬的情况：\n```ruby\nclass Paragraph\n\n     def initialize(text)\n\n          @text = text\n\n     end\n\n     def title?; @text.upcase == @text; end\n\n     def reverse; @text.reverse;end\n\n     def upcase;@text.upcase;end\n\n     ……\n\nend\n```\nParagraph类对一个字符串进行了封装，然后所有的调用都代理到字符串中，仅仅除了title?()方法。当然，这个时候你可以让Paragraph继承自String或者不封装这一层，直接给String添加一个实例方法。无论封装还添加实例方法，都有不妥之处，封装吧，感觉多此一举，这个类用的根本不多，添加方法吧，让所有的字符串都添加这个方法，对库进行了污染。下面让我们来使用单件方法来为某个对象添加title?()方法，其实很简单：\n```ruby\n>> paragraph = \"this is a paragraph\"\n=> \"this is a paragraph\"\n>> def paragraph.title?\n>>   self.upcase == self\n>> end\n=> :title?\n>> paragraph.title?\n=> false\n>> str = \"this is a string\"\n=> \"this is a string\"\n>> str.title?\nNoMethodError: undefined method `title?' for \"this is a string\":String\n        from (irb):7\n        from d:/Ruby21-x64/bin/irb:11:in `<main>'\n```\n从上面的代码可以看出，只给paragraph添加了方法title?()，而且定义单件方法的格式是：\n\ndef 对象.单件方法\n\nend\n\n这和类的类方法定义是一模一样的（再重复一遍类就是对象），这就是单件方法。\n\n一切看上去是这么的简单，但是我们在这问一问题：这个单件方法存放在哪呢？我们知道对象的实例变量存放在对象本身，这样每个对象都有不一样的实例变量，而对象的实例方法存放在类中，所有对象共享这些方法。现在的问题是，单件方法是某个对象独有，所以它不能存放在类中，难道它是存放在对象中？答案是否定的，在Ruby中，对象是不存放方法的，那它到底存放在何处？让我们进入到对象模型的最后一角——Eigenclass。\n\n1.4 Eigenclass\n\n当你用对象.class()获得对象所属类的时候，它对你说谎了，它把一个对象的直接父类隐藏亲来了，而告诉了这个类的父类（或叫超类），这个被隐藏的类就称为这个对象的eigenclass。一般情况下我们是无法感知它的存在的，不过我们可以通过Ruby基于class关键字的特殊语法，进入到eigenclass的作用域：\n```ruby\nclass << an_object\n#代码\nend\n例如：\n>> obj = Object.new\n>> eigenclass = class << obj\n>> self\n>> end\n>> eigenclass.object_id\n=> 1822180\n>> obj.object_id\n=> 26132360\n>> obj.class.object_id\n=> 1563580\n>> eigenclass.superclass.object_id\n=> 1563580\n```\neigenclass和obj的对象id不一样，但是obj所属类的对象id和eigenclass父类的对象id一样，但这也只能说明eigenclass类是obj所属类的子类，并不能证明obj是eigenclass的实例。好吧，要证明这个对象是这个类的实例，我们只要往这个类中添加一个新方法(my_test_method)，如果是这个类的对象就应该可以调用这个方法，上代码验证一下：\n```ruby\n>> obj.my_test_method\nNoMethodError: undefined method `my_test_method' for #<Object:0x00000002b91840>\n        from (irb):5\n        from d:/Ruby21-x64/bin/irb:11:in `<main>'\n>> class << obj\n>>   def my_test_method\n>>     p 'in eigenclass test method'\n>>   end\n>> end\n>> obj.my_test_method\n\"in eigenclass test method\"\n```\n和我们的预想一致，在没有添加my_test_method方法前，obj调用该方法会提示没有定义，为eigenclass添加my_test_method方法后，obj就有了这个方法。有才可以得出：obj就是eigenclass的实例对象。\n\n说到这你有没有明白点什么呢？在eigenclass中添加一个方法，obj就有了这个方法，而在obj.class得到的类中是不存在这个方法的，也就是说我们的单件方法就是存在eigenclass中。上添加的my_test_method就是obj的单件方法，于是我们得到了第二种添加单件方法的方法。同理你知道怎么给类添加类方法吗？\n\n最后重新整理一下方法查找的路径（用\"#C\"表示C的eigenclass）：\n{% asset_img 图三.png 图三 %}\n\n关于类的eigenclass，这里就不重复了，虽然有点不一样，但原理差不多。\n\n1.5 总结\n\nRuby的对象模型真的是迷人，虽然里面有类、eigenclass、模块、实例方法、类方法和单件方法，但是它是如此的统一。如果把eigenclass、普通类和模块放到一起，Ruby对象模型可以总结为7条规则：\n\n1）只有一种对象——要买是普通对象，要买是模块；\n2）只有一种模块——可以是普通模块、类、eigenclass或者代理类；\n3）只有一个方法，他存在于一种模块中——通常是类中；\n4）每个对象（包括类）都有自己的“真正的类”——要么是普通类，要么是eigenclass；\n5）除了BasicObject类（在Ruby 1.8中是object类）无超类外，每个类都有且只有一个超类。这意味着从任何类只有一条向上直到BasicObject的祖先链；\n6）一个对象的eigenclass的超类是这个对象的类；一个类的eigenclass的超类是这个类的超类的eigenclass;\n7）当调用一个方法，Ruby先向进入接收者真正的类，然后进入祖先链，这就是Ruby查找方法的全部内容。\n\n这就是Ruby的对象模型的全部内容。接下来让我们用Ruby编写能够编写代码的代码。\n\n未完待续……","slug":"读书笔记：Ruby篇（三）","published":1,"updated":"2016-07-15T10:54:27.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9svti0006tkb9fepb4qb4"},{"title":"读书笔记：Ruby篇（一）","date":"2015-07-19T08:05:55.000Z","_content":"\n\n1．Ruby简史\n        \nRuby是由日本的松本行弘大约在1993年发明，在2006年前后随着Rails框架崭露头而一鸣惊人。\n\nRuby的发明者Matz为让Ruby成为一门充满乐趣的编程语言，为此，他为Ruby加了一勺糖，一勺语法糖，这勺糖打破了一些语言常规，不仅为程序员提供更加好的体验，而且让代码更加容易理解。此外，Ruby并没有过多的担心编程语言的执行效率，而是把精力放在了提高程序员的编程效率上，于是Matz在简单性和安全性之间、编码效率和程序性能之间做了让步和折中。\n\n松本行弘访谈录\n\n问题一：你为什么要开发Ruby？\n总结Matz的回答：始于对编程语言的兴趣，受到Perl这门可以提高苦逼程序员生产力的语言的启发，最后开发出了Ruby，并受到了世界各地程序员的的喜爱。\n\n问题二：你喜欢它哪一点呢？\nMatz回答：喜欢它的寓教于乐的方式。在技术上，最喜欢的是“代码块（block）”，它是一种易于控制的高阶函数，也为领域特定语言及其他特性的实现提供了极大的灵活性。\n\n问题三：如果能让时光倒流，你想改变哪些特性？\nMatz回答：我想去掉线程，加入actor（参与者）或一些更高级的并发特性。\n<!--more-->\nRuby为何如此迷人，让我们来看看它到底是一门什么样的语言。Ruby是一门解释型、面向对象、动态类型的脚本语言。\n\n解释型：意味着Ruby代码由解释器而非编译器执行。\n面向对象：意味着Ruby支持封装、类继承、多态等特性。\n动态类型：意味着类型在运行时而非编译时绑定，但这并不意味着它就是弱类型语言，相反它是强类型语言。\n\n从解释型和动态类型可以看出Ruby采取的策略是在灵活性和运行时安全之间寻找平衡点。\n\n2．第一天：找个保姆\n\n作者把Ruby比作《欢乐满人间》中的仙女保姆Mary Poppins。要想了解Ruby的魅力，就要先了解这门语言能做什么，就像要想了解Mary Poppins的魔法，就得先了解保姆的工作一样，所以让我先找一个“保姆”。\n\n2．1 快速起步\n\nRuby的安装，请参考官网https://www.ruby-lang.org/zh_cn/downloads/，此处从略。\n\n2．2 从命令行执行Ruby\n\n我的环境是windows7，Ruby2.2.2。在命令行中输入irb进入Rubyshell。\n\n1）从hello，world说开去\n```ruby\nirb(main):001:0> puts \"hello,world\"\nhello,world\n=> nil\n```\n说明：\nirb(main):001:0>：是输入命令提示符；\nputs \"hello,world\"：Ruby代码；\nhello,world：puts函数输出；\n=> nil：函数puts的返回值。\n\n从这里可以看出，只有一行Ruby代码，并没有看其他语言中一直提到的入口函数Main，这就是为什么说Ruby是一门解释型语言，它是通过解释器，将Ruby代码逐行读入，然后解释执行。说它是解释型语言，更重要的依据是它没将代码编译成字节码再执行。\n\n2）变量\n```ruby\nirb(main):002:0> language = \"Ruby\"\n=> \"Ruby\"\nirb(main):003:0> puts \"hello, #{language}\"\nhello, Ruby\n=> nil\nirb(main):004:0> language = “Ruby”\n=> \"Ruby\"\nirb(main):005:0> puts 'hello, #{language}'\nhello, #{language}\n=> nil\n```\n请注意比较前五行和后五行！\n说明：\n1> Ruby是解释执行的。确切地说， Ruby几乎总是解释执行的，但也有开发者正着手开发虚拟机，想把Ruby代码编译成字节码再执行；\n2> 代码里没有声明任何变量，如：string language；\n3> 即使没让Ruby返回任何值，这几行代码也都具有各自的返回值。特别说明：每条Ruby代码都会返回某个值。\n4> 字符串的两种形式，一种是用单引号包含的字符串，这种字符串几乎是将字符串不加改动地直接解释，当然也有改动的例外：’\\’’（反斜线接单引号），解释为：’（单引号）；’\\\\’（两个反斜线），解释为：\\（一个反斜线）。另一种使用双引号包含的字符串，这种字符串支持更多的转义序列，最常见的是\\n。此外，#{expr}序列把任何Ruby代码的值放进字符串，如上面puts “hello, #{language}”，当然还可更复杂一些，如：\n```ruby\nputs \"#{\ndef get_name(who)\nwho\nend\nget_name('xxx')\n},good night”\n```\n当然字符的构建还有其他三种方法，%q，%Q和here document，如：\n%q<aaa>：表示’aaa’；\n%Q(bbb)，表示”bbb”；\n上面的<>可以换成{}、()、//、[]，\nhere document：\n```ruby\nstring=<<END_OF_STRING\nccc\nEND_OF_STRING\nstring=<<-STRING\nccc\n    STRING\n```\n第二行的最后一个换行符（\\n）也会包含在内\n第三行注意一定是在行的开头，不能有任何空格\n第四行注意这个地方有个负号\n第五行这一行的最后一个换行符（\\n）也会包含在内\n第六行这里允许有空格\n\n2．3 Ruby的编程模型\n\nRuby是一门纯面向对象语言。真的是一切皆对象，不像一些你现在正在使用的某些面向对象语言，他们大都带有过程式语言要素。先来看一些基本对象：\n```ruby\nirb(main):008:0> 5\n=> 5\nirb(main):009:0> 5.class\n=> Fixnum\nirb(main):015:0> 5.0.class\n=> Float\nirb(main):013:0> 5.methods\n=> [:to_s, :inspect, :-@, :+, :-, :*, :/, :div, :%,...]\nirb(main):007:0> -5.abs\n=> 5\nirb(main):012:0> 5.equal?4\n=> false\nirb(main):005:0> \"abc\".class\n=> String\nirb(main):006:0> \"abc\".length\n=> 3\nirb(main):014:0> true.class\n=> TrueClass\n```\n说明：\n1．数字，字符串，true和false都是对象，真正的一切皆对象，就连单独数字都不例外；\n2．对象方法的调用也是通过“对象.方法”的方式来调用，只不过用于限定方法参数列表界限的括号可以省略。\n3．Ruby数组是用[]来表示的，函数methods的返回值就是一个数组。\n4．还有一个很特别的方法——“equal?”这是什么鬼？原来在Ruby中方法名字中可以允许有?、!和=，这三个特殊字符，表示查询的方法名通常以“?”结尾，而且它们通常是返回true或者false；“危险的”或者会修改接收者对象的方法，通常以“!”结尾，例如：String提供的downcase和downcase!，第一个不会修改调用该方法的字符串对象的值，只是返回一个小写的字符串，而第二个会改变；可以被赋值的方法通常以“=”结尾，详情以后再说。\n\n2．4 判断\n\n要说判断首先要了解真值，表达式什么时候是真，什么时候是假？不多说上代码：\n```ruby\nirb(main):001:0> x = 4\n=> 4\nirb(main):002:0> x < 5\n=> true\nirb(main):003:0> x <= 4\n=> true\nirb(main):004:0> x > 4\n=> false\n```\n这些和其它语言是一样的，接着看：\n```ruby\nirb(main):001:0> x = 4\n=> 4\nirb(main):002:0> if x == 4\nirb(main):003:1> puts 'if x equal 4'\nirb(main):004:1> else\nirb(main):005:1* puts 'if x not equal 4'\nirb(main):006:1> end\nif x equal 4\n=> nil\nirb(main):007:0> unless x == 4\nirb(main):008:1> puts 'unless x equal 4'\nirb(main):009:1> else\nirb(main):010:1* puts 'unless x not equal 4'\nirb(main):011:1> end\nunless x not equal 4\n=> nil\n```\n说明：\n1>判断表达式有：\n```ruby\n1）\nif 条件 1 then\n    处理 1\nelsif 条件 2 then\n    处理 2\nelsif 条件 3 then\n    处理 3\nelse\n    处理 4\nend\n※ 可以省略 then\n2）\nunless 条件 then\n    处理 1\nelse\n    处理 2\nend\n※ 可以省略 then\nunless等价于 if not\n3）\ncase 比较对象\nwhen 值 1 then\n    处理 1\nwhen 值 2 then\n    处理 2\nwhen 值 3 then\n    处理 3\nelse\n    处理 4\nend\n※ 可以省略 then\n```\n注意：这里说的是判断表达式，为什么说它是表达式，是因为它是有返回值的。\n\n2>if和unless修饰符, 为了提高程序员的生产力，Matz还为if和unless提供了一种简便表达：\n```ruby\nirb(main):033:0> x = 4\n=> 4\nirb(main):034:0> puts 'This appears to be false.' unless x == 4\n=> nil\nirb(main):035:0> puts 'This appears to be true.' if x == 4\nThis appears to be true.\n=> nil\n```\n说明：\n1）格式:简单表达式 unless 条件\n2）格式:简单表达式 if 条件\n\n3>顺带说一下while和until循环表达式：\n```ruby\nwhile 条件\n    处理\nend\n条件为真时进行循环\nuntil 条件\n    处理\nend\n条件为真时跳出循环。\n它们也有修饰符，如 x = x + 1 while x < 10，x = x + 1 until x == 1。\n```\n再看看哪些值是真，哪些是假值？\n```ruby\nirb(main):001:0> puts 'true' if 1\ntrue\n=> nil\nirb(main):002:0> puts 'true' if 'aa'\n(irb):2: warning: string literal in condition\ntrue\n=> nil\nirb(main):003:0> puts 'true' if 0\ntrue\n=> nil\nirb(main):004:0> puts 'true' if true\ntrue\n=> nil\nirb(main):005:0> puts 'true' if false\n=> nil\nirb(main):006:0> puts 'true' if nil\n=> nil\n```\n说明：从上面可以看出来，除了nil和false之外，其他值都代表真，注意0也是true！，只有nil和false表示假。\n\n最后，看一下逻辑运算符（&&、||、!、and、or、not、&和|）：&&与and是等价的只是优先级不一样，||和or是等价的只是优先级不一样，并且这些与和或运算符都是有短路效应的，！和not是等价的只是优先级不一样，&和|也是与和或运算，只是它们没有短路效应。\n\n还有一点值得说一下：and，or，&&，||，&和|实际上是返回首个决定条件真伪的参数的值。\n\n比如说表达式” val1 and val2”，如果val1是false或者nil，那么就能判断整个表达式为假，所以整个表达式就返回val1的值，如果val1是除false和nil之外的其他值，那么还不能判断整个表达式的真伪，接着求val2的值，这时整个表达式的真伪完全依赖于val2，所以整个表达式返回val2的值。\n\n&和|还有一点要特别说明，由于它们的优先级过低，最好是用括号把两个操作数括起来，比如：(x == 4) | (p “lalala”)，否则很容出现错误提示。\n\n2．5 鸭子类型\n\n了解了语言模型，让我们来看看类型模型。\n\nRuby是动态类型语言，也就是说变量无需提前声明，直接就可以使用，这些变量都是在运行时进行类型检查和绑定。比如：前面的对象5，它并没有声明为Fixnum 5，而是直接使用。也就是说强类型语言，它会进行类型检查，在你使用错误类型时，你会得到一个错误。但是由于它是动态类型，所以进行类型检查是在运行时而非编译时。相对于在编译时进行类型检查和绑定的静态类型，Ruby获得的错误提前会少一些。这就是类型安全（在使用错误类型时，语言能在多大程度上给予保护）向简单性做出的让步和折中。这里有一个证明Ruby是运行进行类型检查的例子：\n```ruby\nirb(main):001:0> def add_them_up\nirb(main):002:1> 4 + 'four'\nirb(main):003:1> end\n=> :add_them_up\nirb(main):004:0> add_them_up\nTypeError: String can't be coerced into Fixnum\nfrom (irb):2:in `+'\nfrom (irb):2:in `add_them_up'\nfrom (irb):4\nfrom d:/Ruby22/bin/irb:11:in `<main>'\n```\n说明：\n函数定义中出现了错误，但是解释器并没有给出错误提示，直到调用函数时才给出错误提示。\n\n虽然Ruby在安全性上做出了让步，但是Ruby的类型系统也有自己的优势，由于只有在运行时才进行类型检查，于是即使多个类不必继承自相同的父类，就能以相同的方式使用：\n```ruby\nirb(main):001:0> i = 0\n=> 0\nirb(main):002:0> a = ['100',100.0]\n=> [\"100\", 100.0]\nirb(main):003:0> while i < 2\nirb(main):004:1> puts a[i].to_i\nirb(main):005:1> i = i + 1\nirb(main):006:1> end\n100\n100\n=> nil\n```\n说明：\n从上面的例子中可以看出，数组中包含了两个不同类型的元素，一个是String，另一个是Float，数组是相同数据类型的元素按一定顺序排列的集合，由于类型检查的宽松，在同一个数组中可以包含不同类型的元素，在转换成整数的时候，两个元素都支持to_i方法，这两个元素的外部表现完全一致，于是可以把它们看成是相同类型。这里就是鸭子类型：不在乎其内在类型可能是什么，只要他们有相同的处理方法，那么就可以看作是相同类型进行处理。也就是只要它像鸭子一样走路，像鸭子一样嘎嘎叫，那我们就可以认为它就是只鸭子，不管它是不是真的鸭子。鸭子类型其实就是在面向对象设计思想中的一个重要原则：对接口编码，不对实现编码。\n\n2.6第一天我们学到了什么\n\nRuby是一门解释型、动态类型、强类型、纯面向对象的脚本语言。\n\n2.7 第一天自习\n1）字符串\n```ruby\nirb(main):001:0> \"test\".size\n=> 4\nirb(main):002:0> \"test\".include?\"s\"\n=> true\nirb(main):003:0> \"test\".index \"s\"\n=> 2\nirb(main):004:0> \"test\".upcase\n=> \"TEST\"\nirb(main):005:0> \"this is a test\".split(\" \")\n=> [\"this\", \"is\", \"a\", \"test\"]\nirb(main):006:0> \"this is a test\".sub(\"this\",\"This\")\n=> \"This is a test\"\nirb(main):007:0> \"this is a test\".gsub(\"is\",\"IS\")\n=> \"thIS IS a test\"\nirb(main):008:0> \"this is a test\".gsub(/[aeiou]/,\"1\")\n=> \"th1s 1s 1 t1st\"\n```\n2）Ruby区间（range）\n```ruby\nirb(main):001:0> (0..9)\n=> 0..9\nirb(main):002:0> (0..9).size\n=> 10\nirb(main):003:0> (0..9).include?(3)\n=> true\nirb(main):004:0> (0..9).inject{|e,sum| sum += e}\n=> 45\n```\n3）打印字符串”Hello,world.”\n```ruby\nirb(main):005:0> puts \"Hello, world.\"\nHello, world.\n=> nil\n```\n4）在字符串”Hello,Ruby.”中，找出”Ruby.”所在下标\n```ruby\nirb(main):006:0> \"Hello,Ruby.\".index(\"Ruby\")\n=> 6\n```\n5）打印你的名字十遍\n```ruby\nirb(main):007:0> 10.times{ puts \"your name\" }\nyour name\nyour name\nyour name\nyour name\nyour name\nyour name\nyour name\nyour name\nyour name\nyour name\n```\n6）打印字符串”This is sentence number 1.”，其中的数字1会一直变化到10。\n```ruby\nirb(main):008:0> (1..10).each {|i| puts \"This is sentence number #{i}\"}\nThis is sentence number 1\nThis is sentence number 2\nThis is sentence number 3\nThis is sentence number 4\nThis is sentence number 5\nThis is sentence number 6\nThis is sentence number 7\nThis is sentence number 8\nThis is sentence number 9\nThis is sentence number 10\n```\n7）随机产生一个0~9之间的数，让玩家猜这个数是多少，并告玩家猜大了还是猜小了。\n在一个文件guess.rb输入如下代码：\n```ruby\nputs \"guess the num(0~9),enter q to exit\"\nnum = rand(10).to_i\nwhile getnum = gets.chomp\n    break if getnum == \"q\"\n    guess = getnum.to_i\n    if guess == num\n        puts \"you get the right num!\"\n        break\n    elsif guess > num\n        puts \"bigger!\"\n    else\n        puts \"smaller!\"\n    end\nend\n```\n在命令行定位到guess.rb文件所在位置，然后输入ruby guess.rb。","source":"_posts/读书笔记：Ruby篇（一）.md","raw":"title: 读书笔记：Ruby篇（一）\ntags:\n  - Ruby\ncategories:\n  - Ruby\ndate: 2015-07-19 16:05:55\n---\n\n\n1．Ruby简史\n        \nRuby是由日本的松本行弘大约在1993年发明，在2006年前后随着Rails框架崭露头而一鸣惊人。\n\nRuby的发明者Matz为让Ruby成为一门充满乐趣的编程语言，为此，他为Ruby加了一勺糖，一勺语法糖，这勺糖打破了一些语言常规，不仅为程序员提供更加好的体验，而且让代码更加容易理解。此外，Ruby并没有过多的担心编程语言的执行效率，而是把精力放在了提高程序员的编程效率上，于是Matz在简单性和安全性之间、编码效率和程序性能之间做了让步和折中。\n\n松本行弘访谈录\n\n问题一：你为什么要开发Ruby？\n总结Matz的回答：始于对编程语言的兴趣，受到Perl这门可以提高苦逼程序员生产力的语言的启发，最后开发出了Ruby，并受到了世界各地程序员的的喜爱。\n\n问题二：你喜欢它哪一点呢？\nMatz回答：喜欢它的寓教于乐的方式。在技术上，最喜欢的是“代码块（block）”，它是一种易于控制的高阶函数，也为领域特定语言及其他特性的实现提供了极大的灵活性。\n\n问题三：如果能让时光倒流，你想改变哪些特性？\nMatz回答：我想去掉线程，加入actor（参与者）或一些更高级的并发特性。\n<!--more-->\nRuby为何如此迷人，让我们来看看它到底是一门什么样的语言。Ruby是一门解释型、面向对象、动态类型的脚本语言。\n\n解释型：意味着Ruby代码由解释器而非编译器执行。\n面向对象：意味着Ruby支持封装、类继承、多态等特性。\n动态类型：意味着类型在运行时而非编译时绑定，但这并不意味着它就是弱类型语言，相反它是强类型语言。\n\n从解释型和动态类型可以看出Ruby采取的策略是在灵活性和运行时安全之间寻找平衡点。\n\n2．第一天：找个保姆\n\n作者把Ruby比作《欢乐满人间》中的仙女保姆Mary Poppins。要想了解Ruby的魅力，就要先了解这门语言能做什么，就像要想了解Mary Poppins的魔法，就得先了解保姆的工作一样，所以让我先找一个“保姆”。\n\n2．1 快速起步\n\nRuby的安装，请参考官网https://www.ruby-lang.org/zh_cn/downloads/，此处从略。\n\n2．2 从命令行执行Ruby\n\n我的环境是windows7，Ruby2.2.2。在命令行中输入irb进入Rubyshell。\n\n1）从hello，world说开去\n```ruby\nirb(main):001:0> puts \"hello,world\"\nhello,world\n=> nil\n```\n说明：\nirb(main):001:0>：是输入命令提示符；\nputs \"hello,world\"：Ruby代码；\nhello,world：puts函数输出；\n=> nil：函数puts的返回值。\n\n从这里可以看出，只有一行Ruby代码，并没有看其他语言中一直提到的入口函数Main，这就是为什么说Ruby是一门解释型语言，它是通过解释器，将Ruby代码逐行读入，然后解释执行。说它是解释型语言，更重要的依据是它没将代码编译成字节码再执行。\n\n2）变量\n```ruby\nirb(main):002:0> language = \"Ruby\"\n=> \"Ruby\"\nirb(main):003:0> puts \"hello, #{language}\"\nhello, Ruby\n=> nil\nirb(main):004:0> language = “Ruby”\n=> \"Ruby\"\nirb(main):005:0> puts 'hello, #{language}'\nhello, #{language}\n=> nil\n```\n请注意比较前五行和后五行！\n说明：\n1> Ruby是解释执行的。确切地说， Ruby几乎总是解释执行的，但也有开发者正着手开发虚拟机，想把Ruby代码编译成字节码再执行；\n2> 代码里没有声明任何变量，如：string language；\n3> 即使没让Ruby返回任何值，这几行代码也都具有各自的返回值。特别说明：每条Ruby代码都会返回某个值。\n4> 字符串的两种形式，一种是用单引号包含的字符串，这种字符串几乎是将字符串不加改动地直接解释，当然也有改动的例外：’\\’’（反斜线接单引号），解释为：’（单引号）；’\\\\’（两个反斜线），解释为：\\（一个反斜线）。另一种使用双引号包含的字符串，这种字符串支持更多的转义序列，最常见的是\\n。此外，#{expr}序列把任何Ruby代码的值放进字符串，如上面puts “hello, #{language}”，当然还可更复杂一些，如：\n```ruby\nputs \"#{\ndef get_name(who)\nwho\nend\nget_name('xxx')\n},good night”\n```\n当然字符的构建还有其他三种方法，%q，%Q和here document，如：\n%q<aaa>：表示’aaa’；\n%Q(bbb)，表示”bbb”；\n上面的<>可以换成{}、()、//、[]，\nhere document：\n```ruby\nstring=<<END_OF_STRING\nccc\nEND_OF_STRING\nstring=<<-STRING\nccc\n    STRING\n```\n第二行的最后一个换行符（\\n）也会包含在内\n第三行注意一定是在行的开头，不能有任何空格\n第四行注意这个地方有个负号\n第五行这一行的最后一个换行符（\\n）也会包含在内\n第六行这里允许有空格\n\n2．3 Ruby的编程模型\n\nRuby是一门纯面向对象语言。真的是一切皆对象，不像一些你现在正在使用的某些面向对象语言，他们大都带有过程式语言要素。先来看一些基本对象：\n```ruby\nirb(main):008:0> 5\n=> 5\nirb(main):009:0> 5.class\n=> Fixnum\nirb(main):015:0> 5.0.class\n=> Float\nirb(main):013:0> 5.methods\n=> [:to_s, :inspect, :-@, :+, :-, :*, :/, :div, :%,...]\nirb(main):007:0> -5.abs\n=> 5\nirb(main):012:0> 5.equal?4\n=> false\nirb(main):005:0> \"abc\".class\n=> String\nirb(main):006:0> \"abc\".length\n=> 3\nirb(main):014:0> true.class\n=> TrueClass\n```\n说明：\n1．数字，字符串，true和false都是对象，真正的一切皆对象，就连单独数字都不例外；\n2．对象方法的调用也是通过“对象.方法”的方式来调用，只不过用于限定方法参数列表界限的括号可以省略。\n3．Ruby数组是用[]来表示的，函数methods的返回值就是一个数组。\n4．还有一个很特别的方法——“equal?”这是什么鬼？原来在Ruby中方法名字中可以允许有?、!和=，这三个特殊字符，表示查询的方法名通常以“?”结尾，而且它们通常是返回true或者false；“危险的”或者会修改接收者对象的方法，通常以“!”结尾，例如：String提供的downcase和downcase!，第一个不会修改调用该方法的字符串对象的值，只是返回一个小写的字符串，而第二个会改变；可以被赋值的方法通常以“=”结尾，详情以后再说。\n\n2．4 判断\n\n要说判断首先要了解真值，表达式什么时候是真，什么时候是假？不多说上代码：\n```ruby\nirb(main):001:0> x = 4\n=> 4\nirb(main):002:0> x < 5\n=> true\nirb(main):003:0> x <= 4\n=> true\nirb(main):004:0> x > 4\n=> false\n```\n这些和其它语言是一样的，接着看：\n```ruby\nirb(main):001:0> x = 4\n=> 4\nirb(main):002:0> if x == 4\nirb(main):003:1> puts 'if x equal 4'\nirb(main):004:1> else\nirb(main):005:1* puts 'if x not equal 4'\nirb(main):006:1> end\nif x equal 4\n=> nil\nirb(main):007:0> unless x == 4\nirb(main):008:1> puts 'unless x equal 4'\nirb(main):009:1> else\nirb(main):010:1* puts 'unless x not equal 4'\nirb(main):011:1> end\nunless x not equal 4\n=> nil\n```\n说明：\n1>判断表达式有：\n```ruby\n1）\nif 条件 1 then\n    处理 1\nelsif 条件 2 then\n    处理 2\nelsif 条件 3 then\n    处理 3\nelse\n    处理 4\nend\n※ 可以省略 then\n2）\nunless 条件 then\n    处理 1\nelse\n    处理 2\nend\n※ 可以省略 then\nunless等价于 if not\n3）\ncase 比较对象\nwhen 值 1 then\n    处理 1\nwhen 值 2 then\n    处理 2\nwhen 值 3 then\n    处理 3\nelse\n    处理 4\nend\n※ 可以省略 then\n```\n注意：这里说的是判断表达式，为什么说它是表达式，是因为它是有返回值的。\n\n2>if和unless修饰符, 为了提高程序员的生产力，Matz还为if和unless提供了一种简便表达：\n```ruby\nirb(main):033:0> x = 4\n=> 4\nirb(main):034:0> puts 'This appears to be false.' unless x == 4\n=> nil\nirb(main):035:0> puts 'This appears to be true.' if x == 4\nThis appears to be true.\n=> nil\n```\n说明：\n1）格式:简单表达式 unless 条件\n2）格式:简单表达式 if 条件\n\n3>顺带说一下while和until循环表达式：\n```ruby\nwhile 条件\n    处理\nend\n条件为真时进行循环\nuntil 条件\n    处理\nend\n条件为真时跳出循环。\n它们也有修饰符，如 x = x + 1 while x < 10，x = x + 1 until x == 1。\n```\n再看看哪些值是真，哪些是假值？\n```ruby\nirb(main):001:0> puts 'true' if 1\ntrue\n=> nil\nirb(main):002:0> puts 'true' if 'aa'\n(irb):2: warning: string literal in condition\ntrue\n=> nil\nirb(main):003:0> puts 'true' if 0\ntrue\n=> nil\nirb(main):004:0> puts 'true' if true\ntrue\n=> nil\nirb(main):005:0> puts 'true' if false\n=> nil\nirb(main):006:0> puts 'true' if nil\n=> nil\n```\n说明：从上面可以看出来，除了nil和false之外，其他值都代表真，注意0也是true！，只有nil和false表示假。\n\n最后，看一下逻辑运算符（&&、||、!、and、or、not、&和|）：&&与and是等价的只是优先级不一样，||和or是等价的只是优先级不一样，并且这些与和或运算符都是有短路效应的，！和not是等价的只是优先级不一样，&和|也是与和或运算，只是它们没有短路效应。\n\n还有一点值得说一下：and，or，&&，||，&和|实际上是返回首个决定条件真伪的参数的值。\n\n比如说表达式” val1 and val2”，如果val1是false或者nil，那么就能判断整个表达式为假，所以整个表达式就返回val1的值，如果val1是除false和nil之外的其他值，那么还不能判断整个表达式的真伪，接着求val2的值，这时整个表达式的真伪完全依赖于val2，所以整个表达式返回val2的值。\n\n&和|还有一点要特别说明，由于它们的优先级过低，最好是用括号把两个操作数括起来，比如：(x == 4) | (p “lalala”)，否则很容出现错误提示。\n\n2．5 鸭子类型\n\n了解了语言模型，让我们来看看类型模型。\n\nRuby是动态类型语言，也就是说变量无需提前声明，直接就可以使用，这些变量都是在运行时进行类型检查和绑定。比如：前面的对象5，它并没有声明为Fixnum 5，而是直接使用。也就是说强类型语言，它会进行类型检查，在你使用错误类型时，你会得到一个错误。但是由于它是动态类型，所以进行类型检查是在运行时而非编译时。相对于在编译时进行类型检查和绑定的静态类型，Ruby获得的错误提前会少一些。这就是类型安全（在使用错误类型时，语言能在多大程度上给予保护）向简单性做出的让步和折中。这里有一个证明Ruby是运行进行类型检查的例子：\n```ruby\nirb(main):001:0> def add_them_up\nirb(main):002:1> 4 + 'four'\nirb(main):003:1> end\n=> :add_them_up\nirb(main):004:0> add_them_up\nTypeError: String can't be coerced into Fixnum\nfrom (irb):2:in `+'\nfrom (irb):2:in `add_them_up'\nfrom (irb):4\nfrom d:/Ruby22/bin/irb:11:in `<main>'\n```\n说明：\n函数定义中出现了错误，但是解释器并没有给出错误提示，直到调用函数时才给出错误提示。\n\n虽然Ruby在安全性上做出了让步，但是Ruby的类型系统也有自己的优势，由于只有在运行时才进行类型检查，于是即使多个类不必继承自相同的父类，就能以相同的方式使用：\n```ruby\nirb(main):001:0> i = 0\n=> 0\nirb(main):002:0> a = ['100',100.0]\n=> [\"100\", 100.0]\nirb(main):003:0> while i < 2\nirb(main):004:1> puts a[i].to_i\nirb(main):005:1> i = i + 1\nirb(main):006:1> end\n100\n100\n=> nil\n```\n说明：\n从上面的例子中可以看出，数组中包含了两个不同类型的元素，一个是String，另一个是Float，数组是相同数据类型的元素按一定顺序排列的集合，由于类型检查的宽松，在同一个数组中可以包含不同类型的元素，在转换成整数的时候，两个元素都支持to_i方法，这两个元素的外部表现完全一致，于是可以把它们看成是相同类型。这里就是鸭子类型：不在乎其内在类型可能是什么，只要他们有相同的处理方法，那么就可以看作是相同类型进行处理。也就是只要它像鸭子一样走路，像鸭子一样嘎嘎叫，那我们就可以认为它就是只鸭子，不管它是不是真的鸭子。鸭子类型其实就是在面向对象设计思想中的一个重要原则：对接口编码，不对实现编码。\n\n2.6第一天我们学到了什么\n\nRuby是一门解释型、动态类型、强类型、纯面向对象的脚本语言。\n\n2.7 第一天自习\n1）字符串\n```ruby\nirb(main):001:0> \"test\".size\n=> 4\nirb(main):002:0> \"test\".include?\"s\"\n=> true\nirb(main):003:0> \"test\".index \"s\"\n=> 2\nirb(main):004:0> \"test\".upcase\n=> \"TEST\"\nirb(main):005:0> \"this is a test\".split(\" \")\n=> [\"this\", \"is\", \"a\", \"test\"]\nirb(main):006:0> \"this is a test\".sub(\"this\",\"This\")\n=> \"This is a test\"\nirb(main):007:0> \"this is a test\".gsub(\"is\",\"IS\")\n=> \"thIS IS a test\"\nirb(main):008:0> \"this is a test\".gsub(/[aeiou]/,\"1\")\n=> \"th1s 1s 1 t1st\"\n```\n2）Ruby区间（range）\n```ruby\nirb(main):001:0> (0..9)\n=> 0..9\nirb(main):002:0> (0..9).size\n=> 10\nirb(main):003:0> (0..9).include?(3)\n=> true\nirb(main):004:0> (0..9).inject{|e,sum| sum += e}\n=> 45\n```\n3）打印字符串”Hello,world.”\n```ruby\nirb(main):005:0> puts \"Hello, world.\"\nHello, world.\n=> nil\n```\n4）在字符串”Hello,Ruby.”中，找出”Ruby.”所在下标\n```ruby\nirb(main):006:0> \"Hello,Ruby.\".index(\"Ruby\")\n=> 6\n```\n5）打印你的名字十遍\n```ruby\nirb(main):007:0> 10.times{ puts \"your name\" }\nyour name\nyour name\nyour name\nyour name\nyour name\nyour name\nyour name\nyour name\nyour name\nyour name\n```\n6）打印字符串”This is sentence number 1.”，其中的数字1会一直变化到10。\n```ruby\nirb(main):008:0> (1..10).each {|i| puts \"This is sentence number #{i}\"}\nThis is sentence number 1\nThis is sentence number 2\nThis is sentence number 3\nThis is sentence number 4\nThis is sentence number 5\nThis is sentence number 6\nThis is sentence number 7\nThis is sentence number 8\nThis is sentence number 9\nThis is sentence number 10\n```\n7）随机产生一个0~9之间的数，让玩家猜这个数是多少，并告玩家猜大了还是猜小了。\n在一个文件guess.rb输入如下代码：\n```ruby\nputs \"guess the num(0~9),enter q to exit\"\nnum = rand(10).to_i\nwhile getnum = gets.chomp\n    break if getnum == \"q\"\n    guess = getnum.to_i\n    if guess == num\n        puts \"you get the right num!\"\n        break\n    elsif guess > num\n        puts \"bigger!\"\n    else\n        puts \"smaller!\"\n    end\nend\n```\n在命令行定位到guess.rb文件所在位置，然后输入ruby guess.rb。","slug":"读书笔记：Ruby篇（一）","published":1,"updated":"2016-07-15T09:35:14.708Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9svu10009tkb9n66k5f61"},{"title":"计算机网络概述","date":"2015-11-26T12:51:27.000Z","_content":"\n\n### 基本原理\n\n在《也说“当你输入一个网址，实际会发生什么?”》中介绍到，一台电脑要跟另一台电脑进行通信（所谓通信就是进行数据交换，比如：从其他电脑上下载一个文件到自己电脑等等，如果没有网络，我们一般的做法是使用U盘、光盘等存储设备将文件从某电脑上拷贝到U盘或者刻录到光盘，然后再把U盘或者光盘的文件拷贝到自己电脑上），说道一个重要的步骤就是找到想进行通信的计算机的IP地址（使用DNS协议实现），只是这样就能通信了吗？我只能说小伙子你真是“too young too simple”。这只是万里长征的一小步，为了后面知识点介绍的方便和对网络通信有大局观，现在先简单的概括性的对网络进行介绍。  \n\n上篇日记中说到，在浏览器地址栏中输入www.baidu.com时，我们的计算机会把这个域名转换成IP地址，这个宏观过程就是之前讲过的DNS协议查询的那样，但是现在的问题是，本机也就是192.168.1.100去询问DNS服务器223.5.5.5 www.baidu.com的IP是多少时，本机和DNS服务器并不是用一根线直接相连的，而是通过网关和路由器间接相连，要把这个询问消息发送个DNS服务器，就必须要这些网关和路由器进行转发，使用ipconfig /all命令可以查看网关，如图：\n\n<!--more-->\n\n{% asset_img 图一.jpg 图一 %}  \n\n也就是说我先把信息发给网关或者路由器，如果只能使用IP来表示目标的话，那就只能先将目标设置为网关IP：192.168.1.100，但是当网关收到了这条消息后，网关不知道该怎么办，它该把这条消息发给谁呢？这显然是行不通的，当然这里可以使用广播，向与网关相连的所有的网关或这路由器都发送这条消息，其它机器使用同样的方法一直把消息传递给DNS服务器，然后DNS服务器使用同样的方法把响应回传。这种实现有一个很恐怖的地方，就拿网关A以及和网关A相连的另一个路由B来说，当网关把消息广播出去后，路由B会收到一条消息，然后路由B又将消息广播，此时网关A又会收到这条消息，然后A和B就传这条消息传到白头到老，地老天荒。如图：\n\n{% asset_img 图二.png 图二 %}  \n\n有人说这个比较容易解决，A传给B后，B传给除A外的其他机器，这样就不会出现这种传过来传回去的无限循环。传给出了除信息来源的其他机器，也就是说每传到一个机器后，要把信息里的源IP地址改变成机器自己的IP地址，这会出现当DNS服务器收到信息后不知道把信息回给谁？接着广播吗？就算这样行的通，这样真的能解决无限循环的问题吗？现在假设A将信息传给B，B传给除A外的其他机器，比如C，C收到信息，C将信息传给除B外的其他机器，比如A，又是一个天长地久，之前是两人的缠缠绵绵到天涯，现在是三人的纠葛漩涡。除此之外，这种方法带来的将是整个网络的瘫痪，进入流言满天飞，而且是永无停歇的境况。如图：\n\n{% asset_img 图三.png 图三 %}  \n\n这么看来这种方法是行不通的，那用什么办法可以解决呢？\n既然是因为目标IP和源IP在传递的过程中一直在变化，那可以再添加一个地址，套一层壳，每次只换壳，目标IP永远不变，有句歌词怎么唱来着：“洋装虽然穿在身 我心依然是中国心”。正所谓初心不改，奋勇向前，总有一天会达成目标的。看一看具体的流程，本机将DNS消息和目标IP和自己IP以及网关的一个地址（目标地址）和自己的一个地址（源地址）,根据网关的这个地址，把信息发个网关，网关收到消息，根据目标IP选择一个目标路由器或主机，将消息中的目标地址改成路由或者主机的地址，将源地址改为网关自己的地址，根据目标地址，将消息发给路由或主机，以此类推一直到目标IP主机收到这个消息。消息回复，使用同样的方法。这样就完成了两台电脑之间的通信。\n\n用什么地址可以唯一标识一台计算机呢？答案是MAC地址，每台计算机在生产的时候都会为其分配一个唯一的一个MAC地址。计算机之间的通信原理大致就是这样，具体细节，会在后面的文章中介绍。接下来，我们来大致理一理这个过程的稍微具体点的实现。\n\n我们分别看看各个计算机的职责：\n\n1. 发起通信的主机，主要职责：\n   * 准备好要发送的用户信息；\n   * 找到目标主机IP地址和本机的IP地址；\n   * 将目标主机的的IP地址添加为信息的目标IP，将自己的IP地址添加为源IP，将其作为一整体，当作一条新的信息；\n   * 找到网关的MAC地址和本机的MAC地址；\n   * 在新的信息上添加网关MAC地址作为目标MAC地址，添加本机MAC地址作为源MAC地址；\n   * 根据目标MAC地址，将消息发送出去。\n2. 网关或者路由，主要职责：\n   * 将收到的信息进行解析，取出目标MAC地址，对比看看是不是自己的MAC地址；\n   * 如果是，则取出目标IP地址，看看离这个IP最近且与自己直接相连的路由或者主机，找出它的MAC地址，并且和它相连的网络接口，将目标MAC地址修改为最近的路由或者主机的MAC地址，将源MAC地址修改为网关或者路由自己的MAC地址，将消息从找到的网络接口发送出去。\n   * 如果不是，将消息丢弃。\n3. 接收端的主机，主要职责：\n   * 将收到的信息进行解析，取出目标MAC地址，对比看看是不是自己的MAC地址；\n   * 如果是本机MAC地址，取出目标IP，检查是不是本机IP；\n   * 如果不是本机MAC地址，丢弃此信息，不作后面的解析；\n   * 如果是本机IP地址，则取出信息，进行相应处理；\n   * 如果不是本机IP地址，则丢弃此消息；\n\n从上面的职责，我们可以看出它们的主要职责有，用户信息处理，IP地址处理和MAC地址处理。源主机和目标主机这三个职责都有，只不过是过程向逆，三者都有的职责是IP地址处理和MAC地址处理。所以我们可以将这三个职责抽象出三个独立的处理模块，分别处理各自职责内的事情。将这三个模块组合起来就可以处理整个通信过程。而且从上面的过程可以明显的看出，这些处理过程有着层级关系，为了降低复杂性，我们对网络进行分层，将用户数据处理模块对应为应用层，IP地址处理模块对应为IP层，MAC地址处理模块对应为数据链路层。这就是计算机网络中的分层思想。\n\n小伙伴们看到这，是不是要着急了。计算机网络的书本上明明白白说了OSI参考模型是七层，TCP/IP参考模型是四层，这里只有三层，明显是博主学艺不精。至于OSI参考模型这里就不说了，这个只是参考模型，在实现中并没有采用。TCP/IP参考模型的四层，再加上一层物理层（就是各类物理硬件），我们说的就是这个模型，下面将另外两层补上。\n\n前面只是说到两台主机间的通信，我们忽略了物理设备这层（即各类硬件），把这层加上就足够两台主机通信了（当然这里可靠性之类的细节），也就是说，如果每台计算机只有一个使用网络的程序，那么理论上有这四层就能进行网络通信了，但是我们都知道，每台电脑上都有很多程序在使用网络，这就带了一个问题，计算机收到了来之网络上的信息，这条信息是要交给哪个应用程序的呢？我们可已使用上面的原理再加一层处理，网络分层也加一层，这一层处理的职责是在信息中添加一个ID标记（也就是端口）来标记这条消息是给哪个应用程序的，在接收端，根据这个ID（即端口）将信息交给对应的应用程序。加上这两层，就可以真真正正的实现通信了。\n\n---\n\n### 分层\n\n下面来看看分层：网络协议通常分不同层次进行开发，每一层分别\n负责不同的通信功能。这里不介绍物理层，这一层并非协议分层。\n\n1. 链路层：通常包括操作系统中的设备驱动程序及接口卡。\n2. 网络层：处理分组在网络中的活动，包括协议有：IP、ICMP和IGMP。\n3. 运输层：或者叫做传输层，主要是为两台主机的应用程序提供端到端的通信，包括协议有：TCP和UDP。\n4. 应用层：负责处理特定应用程序的细节，包括协议有：Telnet、FTP、HTTP和e-mail等。\n\n\n用一张图来表示一下TCP/IP协议族中不同层次的协议，协议详情，以后在详陈：\n\n{% asset_img 图四.png 图四 %}\n\n---\n\n### 封装\n\n借助图四中的协议之间的箭头，我们来看看数据的组装（即箭头方向是从上向下的过程）和解析（即箭头方向是从下向上的过程）过程，这里的组装就是现在要将的封装，下一小节要说的分用就是解析过程。\n\n封装过程如下：\n\n1. 用户输入数据给应用程序，比如使用FTP的PWD命令显示当前目录，此时的数据就是：PWD。\n2. FTP应用程序将此命令按FTP协议的规定将用户数据封装成FTP数据：PWD\\r\\r。\n3. FTP将FTP数据交给TCP层，TCP层按照TCP协议加上TCP头，形成新的数据：TCP头+FTP数据。\n4. TCP层将数据传给IP层，IP层按照IP协议加上IP头，形成新的数据：IP头+TCP头+FTP数据。\n5. IP层将数据交给链路层，链路层按照链路层上的协议（一般是以太网协议）加上链路层协议头和链路层尾部，形成新的数据：以太网协议头+IP头+TCP头+FTP数据+以太网尾部。\n\n如下图所示：\n\n{% asset_img 图五.png 图五 %}\n\n---\n\n### 分用\n\n分用正好是封装的逆过程，此过程就不赘述了，这里说一个题外话，由以太网尾部联想到身份证最后一位的含义，它们的作用是一样的，都是一个校验作用。现在就让我们来看看身份证末尾出现X是怎么一回事：\n\n公民身份号码是特征组合码，由十七位数字本体码和一位数字校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。\n\n前面的17位是可以根据地区、出生年月和顺序码确定下来，最有一位的计算方法如下：\n\n1. 将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。\n2. 将这17位数字和系数相乘的结果相加。\n3. 用加出来和除以11，看余数是多少？\n4. 余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。其分别对应的最后一位身份证的号码为1－0－X －9－8－7－6－5－4－3－2。\n\n从上面可以看出由于是对11取余数，所以有11个余数，而一位数只有10个，所以就出现了X。现在你可以用自己的身份证验证一下是不是这样的,如果你计算出来的结果与你身份证最后一位不一样，你的身份证就有问题了。还有一点：倒数第二数字，如果是奇数，则说明这个身份证号码是男性的，偶数则是女性的。\n\n---\n\n参考资料：\n\n1. 《TCP/IP详解：卷一》\n2. [居民身份证号码](http://baike.baidu.com/view/188003.htm)","source":"_posts/计算机网络概述.md","raw":"title: 计算机网络概述\ntags:\n  - 计算机网络\ncategories:\n  - 计算机网络\ndate: 2015-11-26 20:51:27\n---\n\n\n### 基本原理\n\n在《也说“当你输入一个网址，实际会发生什么?”》中介绍到，一台电脑要跟另一台电脑进行通信（所谓通信就是进行数据交换，比如：从其他电脑上下载一个文件到自己电脑等等，如果没有网络，我们一般的做法是使用U盘、光盘等存储设备将文件从某电脑上拷贝到U盘或者刻录到光盘，然后再把U盘或者光盘的文件拷贝到自己电脑上），说道一个重要的步骤就是找到想进行通信的计算机的IP地址（使用DNS协议实现），只是这样就能通信了吗？我只能说小伙子你真是“too young too simple”。这只是万里长征的一小步，为了后面知识点介绍的方便和对网络通信有大局观，现在先简单的概括性的对网络进行介绍。  \n\n上篇日记中说到，在浏览器地址栏中输入www.baidu.com时，我们的计算机会把这个域名转换成IP地址，这个宏观过程就是之前讲过的DNS协议查询的那样，但是现在的问题是，本机也就是192.168.1.100去询问DNS服务器223.5.5.5 www.baidu.com的IP是多少时，本机和DNS服务器并不是用一根线直接相连的，而是通过网关和路由器间接相连，要把这个询问消息发送个DNS服务器，就必须要这些网关和路由器进行转发，使用ipconfig /all命令可以查看网关，如图：\n\n<!--more-->\n\n{% asset_img 图一.jpg 图一 %}  \n\n也就是说我先把信息发给网关或者路由器，如果只能使用IP来表示目标的话，那就只能先将目标设置为网关IP：192.168.1.100，但是当网关收到了这条消息后，网关不知道该怎么办，它该把这条消息发给谁呢？这显然是行不通的，当然这里可以使用广播，向与网关相连的所有的网关或这路由器都发送这条消息，其它机器使用同样的方法一直把消息传递给DNS服务器，然后DNS服务器使用同样的方法把响应回传。这种实现有一个很恐怖的地方，就拿网关A以及和网关A相连的另一个路由B来说，当网关把消息广播出去后，路由B会收到一条消息，然后路由B又将消息广播，此时网关A又会收到这条消息，然后A和B就传这条消息传到白头到老，地老天荒。如图：\n\n{% asset_img 图二.png 图二 %}  \n\n有人说这个比较容易解决，A传给B后，B传给除A外的其他机器，这样就不会出现这种传过来传回去的无限循环。传给出了除信息来源的其他机器，也就是说每传到一个机器后，要把信息里的源IP地址改变成机器自己的IP地址，这会出现当DNS服务器收到信息后不知道把信息回给谁？接着广播吗？就算这样行的通，这样真的能解决无限循环的问题吗？现在假设A将信息传给B，B传给除A外的其他机器，比如C，C收到信息，C将信息传给除B外的其他机器，比如A，又是一个天长地久，之前是两人的缠缠绵绵到天涯，现在是三人的纠葛漩涡。除此之外，这种方法带来的将是整个网络的瘫痪，进入流言满天飞，而且是永无停歇的境况。如图：\n\n{% asset_img 图三.png 图三 %}  \n\n这么看来这种方法是行不通的，那用什么办法可以解决呢？\n既然是因为目标IP和源IP在传递的过程中一直在变化，那可以再添加一个地址，套一层壳，每次只换壳，目标IP永远不变，有句歌词怎么唱来着：“洋装虽然穿在身 我心依然是中国心”。正所谓初心不改，奋勇向前，总有一天会达成目标的。看一看具体的流程，本机将DNS消息和目标IP和自己IP以及网关的一个地址（目标地址）和自己的一个地址（源地址）,根据网关的这个地址，把信息发个网关，网关收到消息，根据目标IP选择一个目标路由器或主机，将消息中的目标地址改成路由或者主机的地址，将源地址改为网关自己的地址，根据目标地址，将消息发给路由或主机，以此类推一直到目标IP主机收到这个消息。消息回复，使用同样的方法。这样就完成了两台电脑之间的通信。\n\n用什么地址可以唯一标识一台计算机呢？答案是MAC地址，每台计算机在生产的时候都会为其分配一个唯一的一个MAC地址。计算机之间的通信原理大致就是这样，具体细节，会在后面的文章中介绍。接下来，我们来大致理一理这个过程的稍微具体点的实现。\n\n我们分别看看各个计算机的职责：\n\n1. 发起通信的主机，主要职责：\n   * 准备好要发送的用户信息；\n   * 找到目标主机IP地址和本机的IP地址；\n   * 将目标主机的的IP地址添加为信息的目标IP，将自己的IP地址添加为源IP，将其作为一整体，当作一条新的信息；\n   * 找到网关的MAC地址和本机的MAC地址；\n   * 在新的信息上添加网关MAC地址作为目标MAC地址，添加本机MAC地址作为源MAC地址；\n   * 根据目标MAC地址，将消息发送出去。\n2. 网关或者路由，主要职责：\n   * 将收到的信息进行解析，取出目标MAC地址，对比看看是不是自己的MAC地址；\n   * 如果是，则取出目标IP地址，看看离这个IP最近且与自己直接相连的路由或者主机，找出它的MAC地址，并且和它相连的网络接口，将目标MAC地址修改为最近的路由或者主机的MAC地址，将源MAC地址修改为网关或者路由自己的MAC地址，将消息从找到的网络接口发送出去。\n   * 如果不是，将消息丢弃。\n3. 接收端的主机，主要职责：\n   * 将收到的信息进行解析，取出目标MAC地址，对比看看是不是自己的MAC地址；\n   * 如果是本机MAC地址，取出目标IP，检查是不是本机IP；\n   * 如果不是本机MAC地址，丢弃此信息，不作后面的解析；\n   * 如果是本机IP地址，则取出信息，进行相应处理；\n   * 如果不是本机IP地址，则丢弃此消息；\n\n从上面的职责，我们可以看出它们的主要职责有，用户信息处理，IP地址处理和MAC地址处理。源主机和目标主机这三个职责都有，只不过是过程向逆，三者都有的职责是IP地址处理和MAC地址处理。所以我们可以将这三个职责抽象出三个独立的处理模块，分别处理各自职责内的事情。将这三个模块组合起来就可以处理整个通信过程。而且从上面的过程可以明显的看出，这些处理过程有着层级关系，为了降低复杂性，我们对网络进行分层，将用户数据处理模块对应为应用层，IP地址处理模块对应为IP层，MAC地址处理模块对应为数据链路层。这就是计算机网络中的分层思想。\n\n小伙伴们看到这，是不是要着急了。计算机网络的书本上明明白白说了OSI参考模型是七层，TCP/IP参考模型是四层，这里只有三层，明显是博主学艺不精。至于OSI参考模型这里就不说了，这个只是参考模型，在实现中并没有采用。TCP/IP参考模型的四层，再加上一层物理层（就是各类物理硬件），我们说的就是这个模型，下面将另外两层补上。\n\n前面只是说到两台主机间的通信，我们忽略了物理设备这层（即各类硬件），把这层加上就足够两台主机通信了（当然这里可靠性之类的细节），也就是说，如果每台计算机只有一个使用网络的程序，那么理论上有这四层就能进行网络通信了，但是我们都知道，每台电脑上都有很多程序在使用网络，这就带了一个问题，计算机收到了来之网络上的信息，这条信息是要交给哪个应用程序的呢？我们可已使用上面的原理再加一层处理，网络分层也加一层，这一层处理的职责是在信息中添加一个ID标记（也就是端口）来标记这条消息是给哪个应用程序的，在接收端，根据这个ID（即端口）将信息交给对应的应用程序。加上这两层，就可以真真正正的实现通信了。\n\n---\n\n### 分层\n\n下面来看看分层：网络协议通常分不同层次进行开发，每一层分别\n负责不同的通信功能。这里不介绍物理层，这一层并非协议分层。\n\n1. 链路层：通常包括操作系统中的设备驱动程序及接口卡。\n2. 网络层：处理分组在网络中的活动，包括协议有：IP、ICMP和IGMP。\n3. 运输层：或者叫做传输层，主要是为两台主机的应用程序提供端到端的通信，包括协议有：TCP和UDP。\n4. 应用层：负责处理特定应用程序的细节，包括协议有：Telnet、FTP、HTTP和e-mail等。\n\n\n用一张图来表示一下TCP/IP协议族中不同层次的协议，协议详情，以后在详陈：\n\n{% asset_img 图四.png 图四 %}\n\n---\n\n### 封装\n\n借助图四中的协议之间的箭头，我们来看看数据的组装（即箭头方向是从上向下的过程）和解析（即箭头方向是从下向上的过程）过程，这里的组装就是现在要将的封装，下一小节要说的分用就是解析过程。\n\n封装过程如下：\n\n1. 用户输入数据给应用程序，比如使用FTP的PWD命令显示当前目录，此时的数据就是：PWD。\n2. FTP应用程序将此命令按FTP协议的规定将用户数据封装成FTP数据：PWD\\r\\r。\n3. FTP将FTP数据交给TCP层，TCP层按照TCP协议加上TCP头，形成新的数据：TCP头+FTP数据。\n4. TCP层将数据传给IP层，IP层按照IP协议加上IP头，形成新的数据：IP头+TCP头+FTP数据。\n5. IP层将数据交给链路层，链路层按照链路层上的协议（一般是以太网协议）加上链路层协议头和链路层尾部，形成新的数据：以太网协议头+IP头+TCP头+FTP数据+以太网尾部。\n\n如下图所示：\n\n{% asset_img 图五.png 图五 %}\n\n---\n\n### 分用\n\n分用正好是封装的逆过程，此过程就不赘述了，这里说一个题外话，由以太网尾部联想到身份证最后一位的含义，它们的作用是一样的，都是一个校验作用。现在就让我们来看看身份证末尾出现X是怎么一回事：\n\n公民身份号码是特征组合码，由十七位数字本体码和一位数字校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。\n\n前面的17位是可以根据地区、出生年月和顺序码确定下来，最有一位的计算方法如下：\n\n1. 将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。\n2. 将这17位数字和系数相乘的结果相加。\n3. 用加出来和除以11，看余数是多少？\n4. 余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。其分别对应的最后一位身份证的号码为1－0－X －9－8－7－6－5－4－3－2。\n\n从上面可以看出由于是对11取余数，所以有11个余数，而一位数只有10个，所以就出现了X。现在你可以用自己的身份证验证一下是不是这样的,如果你计算出来的结果与你身份证最后一位不一样，你的身份证就有问题了。还有一点：倒数第二数字，如果是奇数，则说明这个身份证号码是男性的，偶数则是女性的。\n\n---\n\n参考资料：\n\n1. 《TCP/IP详解：卷一》\n2. [居民身份证号码](http://baike.baidu.com/view/188003.htm)","slug":"计算机网络概述","published":1,"updated":"2015-11-27T01:48:56.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9svv6000ctkb90cxeprm1"},{"title":"手电筒的启示","date":"2015-03-12T13:27:55.000Z","_content":"\n\n昨天我们说到了各种社会活动都是进行信息交流，要交流就必须要对信息进行编码，使其成为一种大家都能理解的形式展现出来。之所以说是大家都能理解的形式，是因为我们说各类载体对信息的表达是等价的，而不是等效的。比如：你对一个农村老太太说网络语，她就完全无法理解你的意思，因为当年的你妹已经不再是你妹，同志也不再是那个同志了。下面就让我们去探寻一下电报机和人都能懂的语言，让我们和电报机能畅通的进行交流。\n \n\n昨天，我们探究计算机问题，然后我们只谈信息传递，今天，本来是说电报机的，那咱不说电报机，说手电筒。据说手电筒是为了能让小朋友躲在被窝看小人书的一项伟大发明。不过，像我这种大朋友就没那么幼稚，怎么能这么浪费资源能呢，我要拿它来吹牛，骗妹子，这才是正确的使用方式。回到昨天的情景：“土鳖”成东青与苏梅相恋了，正巧他们住在相邻且相距500米的两栋宿舍楼内，寝室也刚好正对着。长夜漫漫，实难入睡，土鳖想着女神，女神想着土鳖。第二天，两人决定把这段时间好好地利用起来，商量着晚上使用手电筒来进行交流，这样既可以避免喊话而打扰别人休息。晚上，土鳖站在阳台，打开手电筒，一横一竖的比划着要说的话，女神看了半天没明白他在瞎哔哔啥，反而引来了其他寝室的抱怨（光线亮瞎了其他寝室的美眉们）。\n<!--more-->\n第二天，土鳖痛定思痛，决定对方案进行改良，于是使用类似于摩尔斯电码的方法对文字进行编码，这样就不用在阳台上指手划脚了，也不会影响其他妹子休息，只要对着对面阳台开关手电筒就行了。用短闪表示点，用长亮表示划，这样就可以进行交流了。经过实践证明，这个方法是可行了，可是好景并不长，转眼间到了冬天，外面冰天雪地，你丫叫妹子站在阳台陪你聊天，我只能说：“佛祖，收了这妖猴吧！”。但俗话又说了：“再怎么样也要谈恋爱，直到世界充满爱”。土鳖再次对通话装置进行改良，把手电筒的灯泡放到妹子的被窝里面去，开关放在自己的被窝里，把导线变长，这样这个问题不就解决了吗，同理妹子那头再用一个这样的装置就可以实现互聊了，这才是神器的正确使用方式。这里给出一张电路图以便理解：\n{% asset_img 图一.png 图一 %}\n上图可以简化为：\n{% asset_img 图二.png 图二 %}\n时光荏苒，一眨眼就要毕业了，土鳖与女神无情地分配到了两个不同的城市，那么神器还能使用么？当然能用，把导线再变长一些，光这样还是不够的，因为这个时候，导线变长，电阻变大，电压不够了，电流就无法到达另一个城市，这时你应该要换一个大电池。土鳖心想：费劲千辛万苦，才把这个装置发明了出来，如果能把这个装置推广开来，应该能赚很多钱，出任CEO，迎娶白富美，走向人生巅峰，指日可待了，心里甚是激动啊。心动不如行动，于是与当地政府和企业合作成功的推广了这个装置。但是，这里有个非常郁闷的问题，如果两地相隔非常远，这个大电池要非常大才行，这都不是问题，问题是大电池就代表了大电压，电压高到足以用一个警示牌标明：高压危险，闲杂人等请勿靠近。人都不能靠近，还用个p呀，看来装置还得改善。怎么改善呢？土鳖想了好久没有想到好办法，只能将信息传给适当距离的一个中间人，然后让中间人再传给目标，使用多个短距离传递来完成远距离传递。这下总算可以安心的使用了。\n\n将以上的装置稍作改动，就是电报机了，在很多抗战题材电影和电视剧中都有出现，发报员带着耳机，一只手拿着要发送出去的内容，另一只手不停地按着电报机的电键，同时伴随有哔哔叭叭的声音。通过电使其他装置发声，然后根据声音转换成摩尔斯电码，再根据摩尔斯电码转换成字母，这就是电报机的原理。先上一张电报机的电路图：\n{% asset_img 图三.png 图三 %}\n左边的那个东西是电键，其实就是一个开关，右边这个装置比较有意思，电线绕在一个铁棒上，这就是电磁铁，电磁铁的上方有一个横杆，左端固定在一个柱子上，右端可以在“发生器”的凹槽内上下活动。当电键按下时，电路导通，电磁铁磁化，吸引上面的横杆向下移动，此时发生器发出“滴”的声音，松开电键，电磁铁磁性消失，横杆弹回到原来的位置，此时发生器发出“嗒”的声音。根据“滴——嗒”声的长短来判断是点还是划。\n电报机同样会有远距离传递信息的困境，这个时候就得请一个人专门作为转接员来解决这个问题。这样做似乎是可行的，但是有一个人在中间中转，土鳖发的那些肉麻的话（肉麻还好，如果是恶心到了，那就真的是罪过呀），不就全部被这个中转员知道了吗，隐私何在（你可以使用自定义编码避免这个问题）。我们来分析一下这个中转站的功能，如果你就是那个中转员，你中转速度够快的话，当接收到一个“滴”的时候，应该立马按下另一个电报机的电键，把“滴”转发出去；当收到“嗒”的时候，应该立刻松开电键，把“嗒”转发出去。让我们再来看一看那个横杆是怎么运动的，“滴”向下，“嗒”向上，那么如果我们把横杆连接到另一个电报机的电键上（如下图），是不是就是上面立即转发的一个过程呢？答案很明显，就是同一个过程，这么一来什么问题都解决了。这个装置其实就是一个继电器。\n{% asset_img 图四.png 图四 %}\n将继电器简化一下，整个电路图如下：\n{% asset_img 图五.png 图五 %}\n从上图中可以看出继电器其实就是一个由电磁铁代替人控制开关的装置，同时实现了电流放大的效果。请记住这个装置，它的意义非凡。\n\n从上面的故事我可以看出来，电报机是靠电将信息传递出去的，从摩尔斯电码到电的转换是通过开关实现的，而将电转换成摩尔斯电码是通过响铃实现的。机器并无理解能力，控制权还在你手里，只能帮忙传递电流，只不过是通过开关的开和关，正好能用电通过响铃表现出摩尔斯电码，但对其中的含义它是完全不知晓的。如果你将字符“A”让电报机原样地发给别人，它会给你一个白眼，并且会抱怨说“我TMD连那个糟心的裙子是白金色还是蓝黑色都分辨不出，你给我这么一个字符，我只能说我已经瞎了”。至此，我们可以说这类机器的语言是电，那除了摩尔斯电码之外，它有没有其它什么信息载体能通过机器的语言——电——传递出去呢？\n\n来总结一下：一个土鳖泡妹子的技能，引发的科技进步。有人可能就要拍砖了：“神你妹呀，我从小就帅，所以书读得不多，你千万不要骗我”。你可以再改造一下这个手电筒，把长长的导线去掉，让空气充当信息传递的介质，把灯泡变成一个能自动解码的显示屏，把开关变成自动编码的按键（物理或触屏按键）。这就是你每天埋头苦看的手机，你说它是不是神器呢？\n\n未完待续……","source":"_posts/手电筒的启示.md","raw":"title: 手电筒的启示\ntags:\n  - 信息编码\ncategories:\n  - 信息编码\ndate: 2015-03-12 21:27:55\n---\n\n\n昨天我们说到了各种社会活动都是进行信息交流，要交流就必须要对信息进行编码，使其成为一种大家都能理解的形式展现出来。之所以说是大家都能理解的形式，是因为我们说各类载体对信息的表达是等价的，而不是等效的。比如：你对一个农村老太太说网络语，她就完全无法理解你的意思，因为当年的你妹已经不再是你妹，同志也不再是那个同志了。下面就让我们去探寻一下电报机和人都能懂的语言，让我们和电报机能畅通的进行交流。\n \n\n昨天，我们探究计算机问题，然后我们只谈信息传递，今天，本来是说电报机的，那咱不说电报机，说手电筒。据说手电筒是为了能让小朋友躲在被窝看小人书的一项伟大发明。不过，像我这种大朋友就没那么幼稚，怎么能这么浪费资源能呢，我要拿它来吹牛，骗妹子，这才是正确的使用方式。回到昨天的情景：“土鳖”成东青与苏梅相恋了，正巧他们住在相邻且相距500米的两栋宿舍楼内，寝室也刚好正对着。长夜漫漫，实难入睡，土鳖想着女神，女神想着土鳖。第二天，两人决定把这段时间好好地利用起来，商量着晚上使用手电筒来进行交流，这样既可以避免喊话而打扰别人休息。晚上，土鳖站在阳台，打开手电筒，一横一竖的比划着要说的话，女神看了半天没明白他在瞎哔哔啥，反而引来了其他寝室的抱怨（光线亮瞎了其他寝室的美眉们）。\n<!--more-->\n第二天，土鳖痛定思痛，决定对方案进行改良，于是使用类似于摩尔斯电码的方法对文字进行编码，这样就不用在阳台上指手划脚了，也不会影响其他妹子休息，只要对着对面阳台开关手电筒就行了。用短闪表示点，用长亮表示划，这样就可以进行交流了。经过实践证明，这个方法是可行了，可是好景并不长，转眼间到了冬天，外面冰天雪地，你丫叫妹子站在阳台陪你聊天，我只能说：“佛祖，收了这妖猴吧！”。但俗话又说了：“再怎么样也要谈恋爱，直到世界充满爱”。土鳖再次对通话装置进行改良，把手电筒的灯泡放到妹子的被窝里面去，开关放在自己的被窝里，把导线变长，这样这个问题不就解决了吗，同理妹子那头再用一个这样的装置就可以实现互聊了，这才是神器的正确使用方式。这里给出一张电路图以便理解：\n{% asset_img 图一.png 图一 %}\n上图可以简化为：\n{% asset_img 图二.png 图二 %}\n时光荏苒，一眨眼就要毕业了，土鳖与女神无情地分配到了两个不同的城市，那么神器还能使用么？当然能用，把导线再变长一些，光这样还是不够的，因为这个时候，导线变长，电阻变大，电压不够了，电流就无法到达另一个城市，这时你应该要换一个大电池。土鳖心想：费劲千辛万苦，才把这个装置发明了出来，如果能把这个装置推广开来，应该能赚很多钱，出任CEO，迎娶白富美，走向人生巅峰，指日可待了，心里甚是激动啊。心动不如行动，于是与当地政府和企业合作成功的推广了这个装置。但是，这里有个非常郁闷的问题，如果两地相隔非常远，这个大电池要非常大才行，这都不是问题，问题是大电池就代表了大电压，电压高到足以用一个警示牌标明：高压危险，闲杂人等请勿靠近。人都不能靠近，还用个p呀，看来装置还得改善。怎么改善呢？土鳖想了好久没有想到好办法，只能将信息传给适当距离的一个中间人，然后让中间人再传给目标，使用多个短距离传递来完成远距离传递。这下总算可以安心的使用了。\n\n将以上的装置稍作改动，就是电报机了，在很多抗战题材电影和电视剧中都有出现，发报员带着耳机，一只手拿着要发送出去的内容，另一只手不停地按着电报机的电键，同时伴随有哔哔叭叭的声音。通过电使其他装置发声，然后根据声音转换成摩尔斯电码，再根据摩尔斯电码转换成字母，这就是电报机的原理。先上一张电报机的电路图：\n{% asset_img 图三.png 图三 %}\n左边的那个东西是电键，其实就是一个开关，右边这个装置比较有意思，电线绕在一个铁棒上，这就是电磁铁，电磁铁的上方有一个横杆，左端固定在一个柱子上，右端可以在“发生器”的凹槽内上下活动。当电键按下时，电路导通，电磁铁磁化，吸引上面的横杆向下移动，此时发生器发出“滴”的声音，松开电键，电磁铁磁性消失，横杆弹回到原来的位置，此时发生器发出“嗒”的声音。根据“滴——嗒”声的长短来判断是点还是划。\n电报机同样会有远距离传递信息的困境，这个时候就得请一个人专门作为转接员来解决这个问题。这样做似乎是可行的，但是有一个人在中间中转，土鳖发的那些肉麻的话（肉麻还好，如果是恶心到了，那就真的是罪过呀），不就全部被这个中转员知道了吗，隐私何在（你可以使用自定义编码避免这个问题）。我们来分析一下这个中转站的功能，如果你就是那个中转员，你中转速度够快的话，当接收到一个“滴”的时候，应该立马按下另一个电报机的电键，把“滴”转发出去；当收到“嗒”的时候，应该立刻松开电键，把“嗒”转发出去。让我们再来看一看那个横杆是怎么运动的，“滴”向下，“嗒”向上，那么如果我们把横杆连接到另一个电报机的电键上（如下图），是不是就是上面立即转发的一个过程呢？答案很明显，就是同一个过程，这么一来什么问题都解决了。这个装置其实就是一个继电器。\n{% asset_img 图四.png 图四 %}\n将继电器简化一下，整个电路图如下：\n{% asset_img 图五.png 图五 %}\n从上图中可以看出继电器其实就是一个由电磁铁代替人控制开关的装置，同时实现了电流放大的效果。请记住这个装置，它的意义非凡。\n\n从上面的故事我可以看出来，电报机是靠电将信息传递出去的，从摩尔斯电码到电的转换是通过开关实现的，而将电转换成摩尔斯电码是通过响铃实现的。机器并无理解能力，控制权还在你手里，只能帮忙传递电流，只不过是通过开关的开和关，正好能用电通过响铃表现出摩尔斯电码，但对其中的含义它是完全不知晓的。如果你将字符“A”让电报机原样地发给别人，它会给你一个白眼，并且会抱怨说“我TMD连那个糟心的裙子是白金色还是蓝黑色都分辨不出，你给我这么一个字符，我只能说我已经瞎了”。至此，我们可以说这类机器的语言是电，那除了摩尔斯电码之外，它有没有其它什么信息载体能通过机器的语言——电——传递出去呢？\n\n来总结一下：一个土鳖泡妹子的技能，引发的科技进步。有人可能就要拍砖了：“神你妹呀，我从小就帅，所以书读得不多，你千万不要骗我”。你可以再改造一下这个手电筒，把长长的导线去掉，让空气充当信息传递的介质，把灯泡变成一个能自动解码的显示屏，把开关变成自动编码的按键（物理或触屏按键）。这就是你每天埋头苦看的手机，你说它是不是神器呢？\n\n未完待续……","slug":"手电筒的启示","published":1,"updated":"2016-07-15T09:34:44.060Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9svy8000htkb9b6pmn211"},{"title":"常见面试题复习：字符串(二)","date":"2015-09-09T15:19:00.000Z","_content":"\n题目一：字符串长度\n题目描述\n给定一个由字母组成的字符串求字符串的长度？\n实现函数size_t strlen(const char *str)\n\n乍一看，这是一道送分题，4行代码解决问题：\n``` c\nsize_t strlen(const char * str) {\n     size_t length = 0 ;\n     while (*str++ )\n         ++ length;\n     return  length;\n}\n```\n这是一个普遍的做法，下面看看一个更高效的做法：\n``` c\nsize_t strlen(const char *str)\n{\n  const char *char_ptr;\n  const unsigned long int *longword_ptr;\n  unsigned long int longword, himagic, lomagic;\n\n  /* Handle the first few characters by reading one character at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = str; ((unsigned long int) char_ptr\n\t\t\t& (sizeof (longword) - 1)) != 0;\n       ++char_ptr)\n    if (*char_ptr == '\\0')\n      return char_ptr - str;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to 8-byte longwords.  */\n\n  longword_ptr = (unsigned long int *) char_ptr;\n\n  himagic = 0x80808080L;\n  lomagic = 0x01010101L;\n  if (sizeof (longword) > 4)\n    {\n      /* 64-bit version of the magic.  */\n      /* Do the shift in two steps to avoid a warning if long has 32 bits.  */\n      himagic = ((himagic << 16) << 16) | himagic;\n      lomagic = ((lomagic << 16) << 16) | lomagic;\n    }\n  if (sizeof (longword) > 8)\n    abort ();\n\n  /* Instead of the traditional loop which tests each character,\n     we will test a longword at a time.  The tricky part is testing\n     if *any of the four* bytes in the longword in question are zero.  */\n  for (;;)\n    {\n      longword = *longword_ptr++;\n\n      if (((longword - lomagic) & ~longword & himagic) != 0)\n\t{\n\t  /* Which of the bytes was the zero?  If none of them were, it was\n\t     a misfire; continue the search.  */\n\n\t  const char *cp = (const char *) (longword_ptr - 1);\n\n\t  if (cp[0] == 0)\n\t    return cp - str;\n\t  if (cp[1] == 0)\n\t    return cp - str + 1;\n\t  if (cp[2] == 0)\n\t    return cp - str + 2;\n\t  if (cp[3] == 0)\n\t    return cp - str + 3;\n\t  if (sizeof (longword) > 4)\n\t    {\n\t      if (cp[4] == 0)\n\t\treturn cp - str + 4;\n\t      if (cp[5] == 0)\n\t\treturn cp - str + 5;\n\t      if (cp[6] == 0)\n\t\treturn cp - str + 6;\n\t      if (cp[7] == 0)\n\t\treturn cp - str + 7;\n\t    }\n\t}\n    }\n}\n```\n<!--more-->\n方法一使用遍历每个字节的方法进行计算长度，而方法二利用字节对齐，使得cpu有存取数据更高效。\n方法二的思路：\n(1) 一次判断一个字符直到内存对齐，如果在内存对齐之前就遇到\"\\0\"则直接return，否则到(2)；\n(2) 一次读入并判断一个字，如果此字中没有为0的字节，则继续下一个字，否则到(3)；\n(3) 到这里则说明字中至少有一个字节为0，剩下的就是找出第一个为0的字节的位置然后return。\n\n代码分析：\n``` c\nfor (char_ptr = str; ((unsigned long int) char_ptr \n\t\t& (sizeof (longword) - 1)) != 0;\n       ++char_ptr)\n\tif (*char_ptr == '\\0')\n\t\treturn char_ptr - str;\n```\n找到字符串的中与字对齐的位置，如果在字对齐前就遇到'\\0',直接放回长度，否则，char_ptr记录的就是字节对齐的其实位置，进入下面的代码：\n``` c\n\tlongword_ptr = (unsigned long int *) char_ptr;\n\t\n\thimagic = 0x80808080L;\n\tlomagic = 0x01010101L;\n\t\n\tif (sizeof (longword) > 4)\n\t{\n\t\t/* 64-bit version of the magic.  */\n\t\t/* Do the shift in two steps to avoid a warning if long has 32 bits.  */\n\t\thimagic = ((himagic << 16) << 16) | himagic;\n\t\tlomagic = ((lomagic << 16) << 16) | lomagic;\n\t}\n\tif (sizeof (longword) > 8)\n\t\tabort ();\n\n\n```\n这里给出了8字节之内的两个魔数，himagic表示每个字节最高位为1其他位为0的一个数，lomagic表示每个字节最低位为1其他位为0的一个数，这两个数待会儿有妙用。\n{% asset_img 图一.jpg 图一 %}\n``` c\nfor (;;)\n{\n\tlongword = *longword_ptr++;\n\t\n\tif (((longword - lomagic) & ~longword & himagic) != 0)\n\t{\n\t  \t...\n\t}\n}\n/*\n                b3      b2       b1       b0\n              31------------------------------->0\n  longword:   0XXXXXXX 0XXXXXXX 0XXXXXXX 0XXXXXXX\n    himagic:  10000000 10000000 10000000 10000000\n    lomagic:  00000001 00000001 00000001 00000001\n*/\n```\n分析这几句代码（以4字节为一个字为例），longword是对齐后的一个字的值，如果字符串不包含'\\0'，也就是b3，b2，b1，b0，每一个字节的中都至少有一位是1，那么(longword - lomagic) 结果的每个字节的最高位还是0，即0XXXXXXX 0XXXXXXX 0XXXXXXX 0XXXXXXX，(longword - lomagic)&~longword结果的每个字节的最高位还是0，即0XXXXXXX 0XXXXXXX 0XXXXXXX 0XXXXXXX，((longword - lomagic) & ~longword & himagic)结果一定是0，即00000000 00000000 00000000 00000000；否则，如果字符串包含'\\0'，也就是b3，b2，b1，b0，某个字节的中的位全是0，即0XXXXXXX 0XXXXXXX 00000000 0XXXXXXX，那么(longword - lomagic) 结果的至少某个字节的最高位是1，即0XXXXXXX 0XXXXXXX 11111111 0XXXXXXX，(longword - lomagic)&~longword结果的某个字节的最高位还是1，即0XXXXXXX 0XXXXXXX 11111111 0XXXXXXX，((longword - lomagic) & ~longword & himagic)结果一定不为0。当结果不为0，进入思路的第3个步骤：\n``` c\n\tconst char *cp = (const char *) (longword_ptr - 1);\n\n\tif (cp[0] == 0)\n\t\treturn cp - str;\n\tif (cp[1] == 0)\n\t\treturn cp - str + 1;\n\tif (cp[2] == 0)\n\t\treturn cp - str + 2;\n\tif (cp[3] == 0)\n\t\treturn cp - str + 3;\n\tif (sizeof (longword) > 4)\n\t{\n\t\tif (cp[4] == 0)\n\t\t\treturn cp - str + 4;\n\t\tif (cp[5] == 0)\n\t\t\treturn cp - str + 5;\n\t\tif (cp[6] == 0)\n\t\t\treturn cp - str + 6;\n\t\tif (cp[7] == 0)\n\t\t\treturn cp - str + 7;\n\t}\n```\n方法二要比方法一更高效，方法二来自glibc库中。\n\n题目二：字符串包含\n题目描述\n给定两个由字母组成的字符串A和B，串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\n为了讨论方便，我们假设字符串只包含大写英文字母，实现函数bool contains(string &A, string &B)\n比如：\n串A：ABCDE\n串B：BADB\n返回true，即B里的字母在A里都存在；\n串A：ABCDE\n串B：BFDD\n返回false，即B里的某些字母在A里不存在。\n\n上来是还用简单粗暴的方式，用网上的话说就是：“别说话，吻我”。不罗嗦了，翠花，上代码：\n``` c\nbool contains(string &LongStr, string &ShortStr)\n{\n       for(int i = 0; i < ShortStr.length(); i++){\n              int j = 0;\n              for(; j < LongStr.length();j++){\n                     if(LongStr[j] == ShortStr[i]){\n                            break;\n                     }\n              }\n              if(j == LongStr.length()){\n                     return false;\n              }\n       }\n       return true;\n}\n```\n简单分析LongStr的长度为n，ShortStr的长度为m，时间复杂度为O(m*n)。\n\n上面的方法一次次的遍历LongStr，查找ShortStr中的每个字符是不是也在LongStr中出现，这种做法的最大槽点是你每次去核实一个字符的时候都要去遍历一遍LongStr字符串，这就好像是，你去图书馆借书，你问管理员，我要借《沟通的艺术》、《批判性思维》、《国富论》、《凯恩斯传》、《三体》、《程序员的自我修养》这些书，你能帮我查一下它们在不在馆吗？这时管理员拿着你的书单，在图书馆里转悠一遍，回来告诉你：《凯恩斯传》没有馆藏了。如是这般我不知道管理员会不会累死，借书的人会不会等的花儿都谢了。解决这个问题其实也很简单，只要管理员维护一份图书馆的书单，对书籍进行编号，有一个标记注明某书是不是在馆就行了，下次有人来咨询，管理员就可以通过查表很快回答他了。同理，将此法运用于本算法，用一个数组（或者数字）来标识哪些字母在LongStr出现（相当于哪些书籍在馆），然后遍历ShortStr，得出字符是不是在LongStr中。\n\n主要思路：\n1）由于只考虑大写字母，也就是说总共有26个字符需要标记，用一个32位的整数的第0位到第25位来标识“A……Z”这26个字符。第0位是1表明A在LongStr中，0表示A不再LongStr中；\n2）遍历ShortStr，查看字母对应位置的标识是不是1，如果是，表明该字符在LongStr中，否则，不在，返回false；\n3）如果遍历完ShortStr，都在LongStr中，那么返回true。\n\n代码：\n``` c\nbool contains(string &LongStr, string &ShortStr)\n{\n       int bithash = 0;\n       for(int i = 0;i < LongStr.length(); i++){\n              bithash |= 1 << (LongStr[i] - 'A');\n       }\n       for(int i = 0;i < ShortStr.length(); i++){\n              if(!(bithash & (1 << (ShortStr[i] - 'A')))){\n                     return false;\n              }\n       }\n       return true;\n}\n```\n这个算法很容易看出时间复杂度是O(n)+O(m)=O(m+n)，空间复杂度是O(1)。\n\n某天看到一篇博客：[一个从四秒到10毫秒，花了1年的算法问题？](http://www.cnblogs.com/asxinyu/p/dotnet_Algorithm_SamplePrograrm_Time.html)，这完全就是这个算法的应用，开始的时候使用的就是暴力，最后用的就是优化后的算法。\n\n题目三：字符串转换成整数\n题目描述\n输入一个由数字组成的字符串，把它转换成整数并输出。例如：输入字符串\"123\"，输出整数123。\n给定函数原型int StrToInt(const char *str) ，实现字符串转换成整数的功能，不能使用库函数atoi。\n通过字符串转整数的公式：n = n*10 + str[i] - '0'即可完成此题，代码：\n``` c\nint StrToInt(const char *str)\n{\n       int n = 0;\n       while(str != NULL && *str != '\\0'){\n              n = n*10 + *str - '0';\n              str++;\n       }\n       return n;\n}\n```\n看上去好像还缺点什么，要转换负数呢？改代码：\n``` c\nint StrToInt(const char *str)\n{\n       if(str == NULL )\n              return 0;\n\n       int n = 0;\n       int sign = 1;\n       if(*str == '-' || *str == '+'){\n              if(*str == '-')\n                     sign = -1;\n              str++;\n       }\n\n       while(*str != '\\0'){\n              n = n*10 + *str - '0';\n              str++;\n       }\n       return sign == 1 ? n : -n;\n}\n```\n看上去还是有问题，如果前面有空格或者里面有非数字呢？再改代码：\n``` c\nint StrToInt(const char *str)\n{\n       if(str == NULL )\n              return 0;\n\n       int n = 0;\n       int sign = 1;\n       while(isspace(*str))\n              ++str;\n       if(*str == '-' || *str == '+'){\n              if(*str == '-')\n                     sign = -1;\n              ++str;\n       }\n       while(isdigit(*str)){\n              n = n*10 + *str - '0';\n              ++str;\n       }\n       return sign == 1 ? n : -n;\n}\n```\n看上去一切都大功告成了，但是如果你要转换的数大于最大的整数，也就是溢出，那就会出问题。这种情况下，我们返回最大整数，或者最小的整数，再改代码：\n``` c\nint StrToInt(const char *str)\n{\n       static const int MAX_INT = (int)((unsigned)~0 >> 1);\n       static const int MIN_INT = -MAX_INT - 1;\n\n       if(str == NULL )\n              return 0;\n       int n = 0;\n       int sign = 1;\n       while(isspace(*str))\n              ++str;\n       if(*str == '-' || *str == '+'){\n              if(*str == '-')\n                     sign = -1;\n              ++str;\n       }\n       while(isdigit(*str)){\n              int m = *str - '0';\n              if(sign > 0 && n > (MAX_INT - m) / 10){\n                     return n = MAX_INT;\n              }\n              if(sign < 0 && n > ((unsigned)MAX_INT - m) / 10){\n                     return MIN_INT;\n              }\n              n = n*10 + m;\n              ++str;\n       }\n       return sign > 0 ? n : -n;\n}\n```\n差不多了，这道题到此结束。\n题目四： 0-1交换\n题目描述\n把一个0-1串（只包含0和1的串）进行排序，你可以交换任意两个位置，问最少交换的次数？\n这问题比较简单，使用两头扫，很快能解决，直接上代码：\n``` c\nint swaptimes(char *str)\n{\n       if (NULL == str){\n              return 0;\n       }\n\n       int result = 0;\n       int len = strlen(str);\n       for(int i = 0,j = len - 1;i < j;i++,j--){\n              while(str[i] == '0') i++;\n              while(str[j] == '1') j--;\n              if(i < j) result++;\n       }\n       return result;\n}\n```\n题目五：判断子串变位词\n题目描述\n给定两个串a和b，问b是否是a的子串的变位词。例如输入a = hello, b = lel, lle, ello都是true,但是b = elo是false。\n\n此题可以使用移动窗口方法来解决，窗口的长度是b的长度，如：b的长度是3，我们考察a[0..2], [1..3],[2..4]是否和b是变位词。但是我们如果每次在窗口内进行轮询，效率会很低。因为我们在中间做了很多重复性工作，因为上一个窗口的第2个字符到窗口结束处的字符，在下一个窗口中依然出现了，再次轮询是做了大量的重复工作，如果我们能保存住这段字符对结果的影响的话，我们只需要在前一个窗口的基础上去掉最前面一个字符对结果的影响，再加上窗口下一个字符对结果的影响，就可以得到下一个窗口的结果。我们这里考虑的仅仅是0-255范围的字符。具体如下：\n\n1）把b串中包含的字符用一个数组来标记并记录重复出现的次数，同时遍历第一个窗口，将窗口中出现的字符对应的出现次数减1，和窗口中的字符比较完成后，如果数组中都是0则，b是a的子串变位词，为了不每次遍历数组是否都是0，可以用一个变量nonZero来记录数组中非0值的个数，nonZero为0，说明b是a的子串变位词，否则，不是;\n\n2）从第二个窗口开始，只是把头字符丢弃，此时，要把在上一个窗口中减掉的此字符出现的次数加回来，从而消除丢弃这个字符的对结果的影响，同时更行nonZero。再把窗口下一个字符加进来，同时把加进来的字符对结果的影响反映到数组中，也就是把这个字符的出现次数减1，同时更新nonZero。如果nonZero为0，说明b是a的子串变位词，否则，不是;\n代码：\n``` c\nbool Compare(string long_str, string short_str)\n{\n       int llen = long_str.length();\n       int slen = short_str.length();\n       if(slen > llen){\n              return false;\n       }\n       const int LENGTH = 256;\n       int bithash[LENGTH] = {0};\n       int nonZero = 0;\n       for(int i = 0; i < slen; i++){\n              int m = bithash[short_str[i]]++;\n              if(m == 1) nonZero++;\n       }\n       for(int i = 0; i < slen; i++){\n              int m = bithash[long_str[i]]--;\n              if(m == 0) nonZero--;\n              if(m == -1) nonZero++;\n       }\n       if(nonZero == 0) return true;\n       for(int i = slen; i < llen; i++){\n              int m = bithash[long_str[i-slen]]++;\n              if(m == 0) nonZero--;\n              if(m == 1) nonZero++;\n              m = bithash[long_str[i]]--;\n              if(m == 0) nonZero--;\n              if(m == -1) nonZero++;\n              if(nonZero == 0) return true;\n       }\n       return false;\n}\n```\n可以看到这个算法的时间复杂对是线性的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/常见面试题复习：字符串-二.md","raw":"title: 常见面试题复习：字符串(二)\ntags:\n  - 字符串\n  - 笔试题\ncategories:\n  - 笔试\ndate: 2015-09-09 23:19:00\n---\n\n题目一：字符串长度\n题目描述\n给定一个由字母组成的字符串求字符串的长度？\n实现函数size_t strlen(const char *str)\n\n乍一看，这是一道送分题，4行代码解决问题：\n``` c\nsize_t strlen(const char * str) {\n     size_t length = 0 ;\n     while (*str++ )\n         ++ length;\n     return  length;\n}\n```\n这是一个普遍的做法，下面看看一个更高效的做法：\n``` c\nsize_t strlen(const char *str)\n{\n  const char *char_ptr;\n  const unsigned long int *longword_ptr;\n  unsigned long int longword, himagic, lomagic;\n\n  /* Handle the first few characters by reading one character at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = str; ((unsigned long int) char_ptr\n\t\t\t& (sizeof (longword) - 1)) != 0;\n       ++char_ptr)\n    if (*char_ptr == '\\0')\n      return char_ptr - str;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to 8-byte longwords.  */\n\n  longword_ptr = (unsigned long int *) char_ptr;\n\n  himagic = 0x80808080L;\n  lomagic = 0x01010101L;\n  if (sizeof (longword) > 4)\n    {\n      /* 64-bit version of the magic.  */\n      /* Do the shift in two steps to avoid a warning if long has 32 bits.  */\n      himagic = ((himagic << 16) << 16) | himagic;\n      lomagic = ((lomagic << 16) << 16) | lomagic;\n    }\n  if (sizeof (longword) > 8)\n    abort ();\n\n  /* Instead of the traditional loop which tests each character,\n     we will test a longword at a time.  The tricky part is testing\n     if *any of the four* bytes in the longword in question are zero.  */\n  for (;;)\n    {\n      longword = *longword_ptr++;\n\n      if (((longword - lomagic) & ~longword & himagic) != 0)\n\t{\n\t  /* Which of the bytes was the zero?  If none of them were, it was\n\t     a misfire; continue the search.  */\n\n\t  const char *cp = (const char *) (longword_ptr - 1);\n\n\t  if (cp[0] == 0)\n\t    return cp - str;\n\t  if (cp[1] == 0)\n\t    return cp - str + 1;\n\t  if (cp[2] == 0)\n\t    return cp - str + 2;\n\t  if (cp[3] == 0)\n\t    return cp - str + 3;\n\t  if (sizeof (longword) > 4)\n\t    {\n\t      if (cp[4] == 0)\n\t\treturn cp - str + 4;\n\t      if (cp[5] == 0)\n\t\treturn cp - str + 5;\n\t      if (cp[6] == 0)\n\t\treturn cp - str + 6;\n\t      if (cp[7] == 0)\n\t\treturn cp - str + 7;\n\t    }\n\t}\n    }\n}\n```\n<!--more-->\n方法一使用遍历每个字节的方法进行计算长度，而方法二利用字节对齐，使得cpu有存取数据更高效。\n方法二的思路：\n(1) 一次判断一个字符直到内存对齐，如果在内存对齐之前就遇到\"\\0\"则直接return，否则到(2)；\n(2) 一次读入并判断一个字，如果此字中没有为0的字节，则继续下一个字，否则到(3)；\n(3) 到这里则说明字中至少有一个字节为0，剩下的就是找出第一个为0的字节的位置然后return。\n\n代码分析：\n``` c\nfor (char_ptr = str; ((unsigned long int) char_ptr \n\t\t& (sizeof (longword) - 1)) != 0;\n       ++char_ptr)\n\tif (*char_ptr == '\\0')\n\t\treturn char_ptr - str;\n```\n找到字符串的中与字对齐的位置，如果在字对齐前就遇到'\\0',直接放回长度，否则，char_ptr记录的就是字节对齐的其实位置，进入下面的代码：\n``` c\n\tlongword_ptr = (unsigned long int *) char_ptr;\n\t\n\thimagic = 0x80808080L;\n\tlomagic = 0x01010101L;\n\t\n\tif (sizeof (longword) > 4)\n\t{\n\t\t/* 64-bit version of the magic.  */\n\t\t/* Do the shift in two steps to avoid a warning if long has 32 bits.  */\n\t\thimagic = ((himagic << 16) << 16) | himagic;\n\t\tlomagic = ((lomagic << 16) << 16) | lomagic;\n\t}\n\tif (sizeof (longword) > 8)\n\t\tabort ();\n\n\n```\n这里给出了8字节之内的两个魔数，himagic表示每个字节最高位为1其他位为0的一个数，lomagic表示每个字节最低位为1其他位为0的一个数，这两个数待会儿有妙用。\n{% asset_img 图一.jpg 图一 %}\n``` c\nfor (;;)\n{\n\tlongword = *longword_ptr++;\n\t\n\tif (((longword - lomagic) & ~longword & himagic) != 0)\n\t{\n\t  \t...\n\t}\n}\n/*\n                b3      b2       b1       b0\n              31------------------------------->0\n  longword:   0XXXXXXX 0XXXXXXX 0XXXXXXX 0XXXXXXX\n    himagic:  10000000 10000000 10000000 10000000\n    lomagic:  00000001 00000001 00000001 00000001\n*/\n```\n分析这几句代码（以4字节为一个字为例），longword是对齐后的一个字的值，如果字符串不包含'\\0'，也就是b3，b2，b1，b0，每一个字节的中都至少有一位是1，那么(longword - lomagic) 结果的每个字节的最高位还是0，即0XXXXXXX 0XXXXXXX 0XXXXXXX 0XXXXXXX，(longword - lomagic)&~longword结果的每个字节的最高位还是0，即0XXXXXXX 0XXXXXXX 0XXXXXXX 0XXXXXXX，((longword - lomagic) & ~longword & himagic)结果一定是0，即00000000 00000000 00000000 00000000；否则，如果字符串包含'\\0'，也就是b3，b2，b1，b0，某个字节的中的位全是0，即0XXXXXXX 0XXXXXXX 00000000 0XXXXXXX，那么(longword - lomagic) 结果的至少某个字节的最高位是1，即0XXXXXXX 0XXXXXXX 11111111 0XXXXXXX，(longword - lomagic)&~longword结果的某个字节的最高位还是1，即0XXXXXXX 0XXXXXXX 11111111 0XXXXXXX，((longword - lomagic) & ~longword & himagic)结果一定不为0。当结果不为0，进入思路的第3个步骤：\n``` c\n\tconst char *cp = (const char *) (longword_ptr - 1);\n\n\tif (cp[0] == 0)\n\t\treturn cp - str;\n\tif (cp[1] == 0)\n\t\treturn cp - str + 1;\n\tif (cp[2] == 0)\n\t\treturn cp - str + 2;\n\tif (cp[3] == 0)\n\t\treturn cp - str + 3;\n\tif (sizeof (longword) > 4)\n\t{\n\t\tif (cp[4] == 0)\n\t\t\treturn cp - str + 4;\n\t\tif (cp[5] == 0)\n\t\t\treturn cp - str + 5;\n\t\tif (cp[6] == 0)\n\t\t\treturn cp - str + 6;\n\t\tif (cp[7] == 0)\n\t\t\treturn cp - str + 7;\n\t}\n```\n方法二要比方法一更高效，方法二来自glibc库中。\n\n题目二：字符串包含\n题目描述\n给定两个由字母组成的字符串A和B，串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\n为了讨论方便，我们假设字符串只包含大写英文字母，实现函数bool contains(string &A, string &B)\n比如：\n串A：ABCDE\n串B：BADB\n返回true，即B里的字母在A里都存在；\n串A：ABCDE\n串B：BFDD\n返回false，即B里的某些字母在A里不存在。\n\n上来是还用简单粗暴的方式，用网上的话说就是：“别说话，吻我”。不罗嗦了，翠花，上代码：\n``` c\nbool contains(string &LongStr, string &ShortStr)\n{\n       for(int i = 0; i < ShortStr.length(); i++){\n              int j = 0;\n              for(; j < LongStr.length();j++){\n                     if(LongStr[j] == ShortStr[i]){\n                            break;\n                     }\n              }\n              if(j == LongStr.length()){\n                     return false;\n              }\n       }\n       return true;\n}\n```\n简单分析LongStr的长度为n，ShortStr的长度为m，时间复杂度为O(m*n)。\n\n上面的方法一次次的遍历LongStr，查找ShortStr中的每个字符是不是也在LongStr中出现，这种做法的最大槽点是你每次去核实一个字符的时候都要去遍历一遍LongStr字符串，这就好像是，你去图书馆借书，你问管理员，我要借《沟通的艺术》、《批判性思维》、《国富论》、《凯恩斯传》、《三体》、《程序员的自我修养》这些书，你能帮我查一下它们在不在馆吗？这时管理员拿着你的书单，在图书馆里转悠一遍，回来告诉你：《凯恩斯传》没有馆藏了。如是这般我不知道管理员会不会累死，借书的人会不会等的花儿都谢了。解决这个问题其实也很简单，只要管理员维护一份图书馆的书单，对书籍进行编号，有一个标记注明某书是不是在馆就行了，下次有人来咨询，管理员就可以通过查表很快回答他了。同理，将此法运用于本算法，用一个数组（或者数字）来标识哪些字母在LongStr出现（相当于哪些书籍在馆），然后遍历ShortStr，得出字符是不是在LongStr中。\n\n主要思路：\n1）由于只考虑大写字母，也就是说总共有26个字符需要标记，用一个32位的整数的第0位到第25位来标识“A……Z”这26个字符。第0位是1表明A在LongStr中，0表示A不再LongStr中；\n2）遍历ShortStr，查看字母对应位置的标识是不是1，如果是，表明该字符在LongStr中，否则，不在，返回false；\n3）如果遍历完ShortStr，都在LongStr中，那么返回true。\n\n代码：\n``` c\nbool contains(string &LongStr, string &ShortStr)\n{\n       int bithash = 0;\n       for(int i = 0;i < LongStr.length(); i++){\n              bithash |= 1 << (LongStr[i] - 'A');\n       }\n       for(int i = 0;i < ShortStr.length(); i++){\n              if(!(bithash & (1 << (ShortStr[i] - 'A')))){\n                     return false;\n              }\n       }\n       return true;\n}\n```\n这个算法很容易看出时间复杂度是O(n)+O(m)=O(m+n)，空间复杂度是O(1)。\n\n某天看到一篇博客：[一个从四秒到10毫秒，花了1年的算法问题？](http://www.cnblogs.com/asxinyu/p/dotnet_Algorithm_SamplePrograrm_Time.html)，这完全就是这个算法的应用，开始的时候使用的就是暴力，最后用的就是优化后的算法。\n\n题目三：字符串转换成整数\n题目描述\n输入一个由数字组成的字符串，把它转换成整数并输出。例如：输入字符串\"123\"，输出整数123。\n给定函数原型int StrToInt(const char *str) ，实现字符串转换成整数的功能，不能使用库函数atoi。\n通过字符串转整数的公式：n = n*10 + str[i] - '0'即可完成此题，代码：\n``` c\nint StrToInt(const char *str)\n{\n       int n = 0;\n       while(str != NULL && *str != '\\0'){\n              n = n*10 + *str - '0';\n              str++;\n       }\n       return n;\n}\n```\n看上去好像还缺点什么，要转换负数呢？改代码：\n``` c\nint StrToInt(const char *str)\n{\n       if(str == NULL )\n              return 0;\n\n       int n = 0;\n       int sign = 1;\n       if(*str == '-' || *str == '+'){\n              if(*str == '-')\n                     sign = -1;\n              str++;\n       }\n\n       while(*str != '\\0'){\n              n = n*10 + *str - '0';\n              str++;\n       }\n       return sign == 1 ? n : -n;\n}\n```\n看上去还是有问题，如果前面有空格或者里面有非数字呢？再改代码：\n``` c\nint StrToInt(const char *str)\n{\n       if(str == NULL )\n              return 0;\n\n       int n = 0;\n       int sign = 1;\n       while(isspace(*str))\n              ++str;\n       if(*str == '-' || *str == '+'){\n              if(*str == '-')\n                     sign = -1;\n              ++str;\n       }\n       while(isdigit(*str)){\n              n = n*10 + *str - '0';\n              ++str;\n       }\n       return sign == 1 ? n : -n;\n}\n```\n看上去一切都大功告成了，但是如果你要转换的数大于最大的整数，也就是溢出，那就会出问题。这种情况下，我们返回最大整数，或者最小的整数，再改代码：\n``` c\nint StrToInt(const char *str)\n{\n       static const int MAX_INT = (int)((unsigned)~0 >> 1);\n       static const int MIN_INT = -MAX_INT - 1;\n\n       if(str == NULL )\n              return 0;\n       int n = 0;\n       int sign = 1;\n       while(isspace(*str))\n              ++str;\n       if(*str == '-' || *str == '+'){\n              if(*str == '-')\n                     sign = -1;\n              ++str;\n       }\n       while(isdigit(*str)){\n              int m = *str - '0';\n              if(sign > 0 && n > (MAX_INT - m) / 10){\n                     return n = MAX_INT;\n              }\n              if(sign < 0 && n > ((unsigned)MAX_INT - m) / 10){\n                     return MIN_INT;\n              }\n              n = n*10 + m;\n              ++str;\n       }\n       return sign > 0 ? n : -n;\n}\n```\n差不多了，这道题到此结束。\n题目四： 0-1交换\n题目描述\n把一个0-1串（只包含0和1的串）进行排序，你可以交换任意两个位置，问最少交换的次数？\n这问题比较简单，使用两头扫，很快能解决，直接上代码：\n``` c\nint swaptimes(char *str)\n{\n       if (NULL == str){\n              return 0;\n       }\n\n       int result = 0;\n       int len = strlen(str);\n       for(int i = 0,j = len - 1;i < j;i++,j--){\n              while(str[i] == '0') i++;\n              while(str[j] == '1') j--;\n              if(i < j) result++;\n       }\n       return result;\n}\n```\n题目五：判断子串变位词\n题目描述\n给定两个串a和b，问b是否是a的子串的变位词。例如输入a = hello, b = lel, lle, ello都是true,但是b = elo是false。\n\n此题可以使用移动窗口方法来解决，窗口的长度是b的长度，如：b的长度是3，我们考察a[0..2], [1..3],[2..4]是否和b是变位词。但是我们如果每次在窗口内进行轮询，效率会很低。因为我们在中间做了很多重复性工作，因为上一个窗口的第2个字符到窗口结束处的字符，在下一个窗口中依然出现了，再次轮询是做了大量的重复工作，如果我们能保存住这段字符对结果的影响的话，我们只需要在前一个窗口的基础上去掉最前面一个字符对结果的影响，再加上窗口下一个字符对结果的影响，就可以得到下一个窗口的结果。我们这里考虑的仅仅是0-255范围的字符。具体如下：\n\n1）把b串中包含的字符用一个数组来标记并记录重复出现的次数，同时遍历第一个窗口，将窗口中出现的字符对应的出现次数减1，和窗口中的字符比较完成后，如果数组中都是0则，b是a的子串变位词，为了不每次遍历数组是否都是0，可以用一个变量nonZero来记录数组中非0值的个数，nonZero为0，说明b是a的子串变位词，否则，不是;\n\n2）从第二个窗口开始，只是把头字符丢弃，此时，要把在上一个窗口中减掉的此字符出现的次数加回来，从而消除丢弃这个字符的对结果的影响，同时更行nonZero。再把窗口下一个字符加进来，同时把加进来的字符对结果的影响反映到数组中，也就是把这个字符的出现次数减1，同时更新nonZero。如果nonZero为0，说明b是a的子串变位词，否则，不是;\n代码：\n``` c\nbool Compare(string long_str, string short_str)\n{\n       int llen = long_str.length();\n       int slen = short_str.length();\n       if(slen > llen){\n              return false;\n       }\n       const int LENGTH = 256;\n       int bithash[LENGTH] = {0};\n       int nonZero = 0;\n       for(int i = 0; i < slen; i++){\n              int m = bithash[short_str[i]]++;\n              if(m == 1) nonZero++;\n       }\n       for(int i = 0; i < slen; i++){\n              int m = bithash[long_str[i]]--;\n              if(m == 0) nonZero--;\n              if(m == -1) nonZero++;\n       }\n       if(nonZero == 0) return true;\n       for(int i = slen; i < llen; i++){\n              int m = bithash[long_str[i-slen]]++;\n              if(m == 0) nonZero--;\n              if(m == 1) nonZero++;\n              m = bithash[long_str[i]]--;\n              if(m == 0) nonZero--;\n              if(m == -1) nonZero++;\n              if(nonZero == 0) return true;\n       }\n       return false;\n}\n```\n可以看到这个算法的时间复杂对是线性的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"常见面试题复习：字符串-二","published":1,"updated":"2016-07-21T07:51:05.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9svz0000mtkb9x2fziv6c"},{"title":"常见面试题复习：字符串(一)","date":"2015-09-08T10:25:00.000Z","_content":"\n\n好久没有写代码了，趁现在有时间敲几行代码，培养一下手感。\n\n题目一：左旋转字符串\n题目描述：\n定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部，如把字符串abcdef左旋转2位得到字符串cdefab。\n请实现字符串左旋转的函数，要求对长度为n的字符串操作的时间复杂度为O(n)，空间复杂度为O(1)。\n\n这个问题最容易想到的是暴力移位或者再用一个数组来存放前面m个元素（此法空间复杂度显然不满足要求），下面看一下暴力移位，代码如下：\n``` c\nvoid leftshiftone(char *s,int n)\n{\n    char temp = *s;\n    for (int i = 1; i < n; i++){\n        s[i-1] = s[i];\n    }\n    s[n - 1] = temp;\n}\nvoid rightshiftone(char *s,int n)\n{\n    char temp = s[n - 1];\n    for (int i = n - 1; i > 0; i--){\n        s[i] = s[i - 1];\n    }\n    s[0] = temp;\n}\nvoid shift(char *s,int n,int m)\n{\n    if(NULL == s || n <=0 || m <= 0)\n        return ;\n    m %= n;\n    if (m > n /2){\n        m = n - m;\n        while(m--){\n            rightshiftone(s,n);\n        }\n    }\n    else{\n        while(m--){\n            leftshiftone(s,n);\n        }\n    }\n}\n```\n<!--more-->\n从这里可以看出数组的一个缺点：在进行移位、插入和删除某个元素是，数组将移动大量的数据。这个算法不符合时间复杂度为O(n)的要求，其时间复杂度为O(m*n)，空间复杂度是O(1)，空间复杂度满足要求。\n\n说道这个例子，就不得不提三步翻转法，因为这个问题是《编程珠玑》上的一个例题。\n\n将具有10个元素的数组向上旋转5个位置，即：将123456789A(这里为了表示方便用A代替10）翻转成6789A123456，看图：\n{% asset_img 图一.png 图一 %}\n\n这就是三步翻转法，下面来看一个字符串的例子：将abcdef翻转成cdefab，用A^T表示A的逆序，如：A=abc，A^T=cba。下面来实现一下这个翻转：\n1）将字符串abcdef分成两部分：A=ab，B=cdef；\n2）分别将A和B进行翻转得A^T=ba，B^T=fedc，生成行的字符串A^TB^T=bafedc；\n3）将A^TB^T进行翻转得：(A^TB^T)^T=cdefab，得到答案。\n\n将上面的方法转换成代码如下：\n``` c\nvoid reverse(char *s,int from,int to)\n{\n    while(from < to){\n        char temp = s[from];\n        s[from++] = s[to];\n        s[to--] = temp;\n    }\n}\nvoid shift(char *s,int n,int m)\n{\n    if(NULL == s || n <=0 || m <= 0)\n        return ;\n    m %= n;\n    reverse(s,0,m - 1);\n    reverse(s,m,n - 1);\n    reverse(s,0,n - 1);\n}\n```\n很容易看出这个算法是满足题目要求的，此法虽然满足要求，但是我们还是可以看到它还是做出了一些多余的交换，有没有一种方法能够实现交换的次数更少的算法呢？我可以这样去想象一下，如果有一种方法在一次赋值后就有一个字符到达了翻转后的最终位置，那么有n个字符需要去到它最终的位置，加上第一个腾出位置的字符放到最终位置进行的赋值，那么它一共就进行了n+1次赋值操作（注意是赋值）。下面来个简单点例子：将字符串A=abcde向左旋转3个字符，即：翻转成B=deabc。\n\n我们来分析一下：\n1）将源字符串A的第一字符（0号位置）a腾出来：\\_bcde，temp=a；\n2）找到第一个字符（0号位置，字符的位置从0开始编号）最终要放置的字符，通过字符串B知道，第一个位置最终的字符是d，它在字符串A的3号位置。把d放到A串的0号位置那么3号位置又被腾空出来，得字符串：A=dbc\\_e；\n3）3号位置已经腾空，现在找出3号位置最终的字符，并将其放置到3号位置，通过B串我们可以知道这个字符是b，b在A串的1号位置。把b放到3号位置得：A=d\\_cbe;\n4）步骤同步骤3），此时4号位置的e放到了1号位置，4号位置腾空：A=decb\\_;\n5）步骤同步骤3），此时2号位置的c放到了4号位置，2号位置腾空：A=de\\_bc；\n6）最后一步，将temp保存的字符a放置到2号位置，得到字符串B=deabc。\n\n这个过程最难的是确定j号位置腾空后，由哪号位置的字符来填充，如果能确定这个位置，这个问题就能解了，下面就来分析一下这个位置到底有什么规律。\n\n我们知道将长度为n的字符串左旋转m个字符，其实就是将字符串的前m个字符全部腾空，然后将第m+1位置（也就是m号字符）之后的所有字符向左边移动m个位置。\n{% asset_img 图二.png 图二 %}\n\n也就是说当j号位置后面还有m个字符的时候，j号位置放置的是j+m号位置的字符。但是当j号位置后面没有m个字符时，怎么办呢？其实很简单，把开头的这m个元素映射到最后一个字符后面的m个位置上去，如图：\n{% asset_img 图三.png 图三 %}\n\n开头的m个字符通过函数f(x)=x + n，映射到虚拟字符的位置，那么除虚拟字符的最后m个字符也可以用：j号位置放置j+m号位置的字符。此时也就有：j+m = x+n，也就有j+m-n=x。如果你对取余运算比较熟悉的话，可以通过(j+m)%n来统一上面两种情况：j+m<n时，说明j后面还有m个字符，此时 (j+m)%n= j+m；当j+m>=n时，说明j后面没有m个字符了，此时(j+m)%n=( j+m)-n=x。因此，我们可以得出结论，当j号位置放置的是(j+m)%n号位置的字符就能够解决这个问题。于是有下面的代码：\n``` c\nvoid shift(char *s,int n,int m)\n{\n    if(NULL == s || n <=0 || m <= 0)\n        return ;\n    m %= n;\n    char temp = s[0];\n    int j = 0;\n    for(; (j+m)%n != 0; j =(j+m)%n){\n        s[j]=s[(j+m)%n];\n    }\n    s[j] = temp;\n}\n```\n试一下：当s=abcde，m=3，得出结果：deabc，结果正确，但是如果s=abcd，m=2时，得到结果：cbad。怎么回事，怎么会这样，难道我们前面的推导有问题吗，为什么有时正确，有时错误呢，这是什么情况？\n\n不卖关子了，问题出在j的身上。在错误的情况下，a和c的位置是对的，只是b和d没有变动，也就是说j并没有遍历所有的位置，看一下j的变化，j=(j+m)%n，看到这个等式，不知道大家有什么感想。还记的我之前写过的一篇关于[分水问题](http://hanhaichensha.coding.me/blog/2015/02/02/RSA系类（二）：分水问题/)的日记吗？如果你忘了，你可以去看看。有一个m升的容器和一个n升的容器，j就是要分出来的水，现在的问题是j能取哪些值？答案是当m和n互质时，j能取遍0到n-1（这里假设m<n），对于这一点不清楚的小伙伴可以回去看看那篇分水的日记。这就能解释为什么有时能得到正确答案，有时不能。那该怎么样才能让它取遍0到n-1所有的值呢？分水问题有一个结论：只能取出m和n的最大公约数的整数倍的水，如m=4，n=6，那么它们的最大公约数是2，也就说用4升和6升的桶只能取出0，2，4升的水，1，3，5升的水是取不出来的。现在，将整个字符串分成gcd(m,n)（最大公约数）组，每一组的数值都是可以用能取出水的那组数值平移得到（组中成员同时加上一个常数得到），也就是说存在函数f(x*gcd(m,n))=x*gcd(m,n) + C，其中C是取值[0, gcd(m,n) -1]常数，x的取值范围是[0,n/gcd(m,n)-1]，如下图，按照箭头步骤对两个分组进行赋值，就能得到结果：\n{% asset_img 图四.png 图四 %}\n根据上面的分析得到代码：\n``` c\nint gcd(int n,int m)\n{\n    if(n <= 0 || m <= 0)\n        return 0;\n    int r=0;\n    while((r = m % n) != 0){\n        m = n;\n        n = r;\n    }\n    return n;\n}\nvoid shift(char *s,int n,int m)\n{\n    if(NULL == s || n <=0 || m <= 0)\n        return ;\n    m %= n;\n    int group = gcd(m,n);\n    for(int i = 0; i < group; i++){\n        char temp = s[i];\n        int j = i;\n        for(; (j+m)%n != i; j =(j+m)%n){\n            s[j] = s[(j+m)%n];\n        }\n        s[j] = temp;\n    }\n}\n```\n这个方法虽然也满足题目要求（不要以为有两个for循环，时间复杂度就是O(n2)），交换也变少了，但是这里面使用了取模运算，我们知道除法运算是比较耗时的，这也是这个算法的一个不足之处。\n\n前面说的方法无非就是要把字符一次到位的移动到最终位置，那我们还是可以使用下面的方法来进行求解（方法类似辗转相除法）：设字符串A=abcdefghijk，m=3，n=length(A)=11，left是最左边还没有交换的编号，right是最右边还没有交换的编号。\n1）如果，right - left >=2\\*m - 1时，将left到left+m-1号位置上的字符和left+m到left+2\\*m-1号位置上的字符进行交换，实现从左向右移动，如：def<font color=red>abc</font>ghijk；\n2）一直进行1）操作，直到right - left <2\\*m - 1，此时，由于要移到尾部的这m字符后面少于m个字符跟它交换。此时，前面的字符已经移动到了正确位置，现在只要考虑没有到正确位置的字符串，调整字符串长度n=right-left+1，m=n-m，如果m等于0退出，否则进入3）；\n3）此时可以将这m个字符后面的字符用类似1）的方法从右向左移动，如：将字符串defghi<font color=red>abc</font>jk的jk从右向左移动，得：defghi<font color=red>a</font><font color=blue>jk</font><font color=red>bc</font>；\n4）一直进行3）操作，直到right - left <2\\*m - 1，此时，由于要移到头部的这m字符前面少于m个字符跟它交换。此时，前面的字符已经移动到了正确位置，现在只要考虑没有到正确位置的字符串，调整字符串长度n=right-left+1，m=n-m，如果m等于0退出，否则进入1）；\n\n过程如图：\n{% asset_img 图五.png 图五 %}\n 代码如下：\n``` c\nvoid swap(char *s,char *d)\n{\n    char temp = *s;\n    *s=*d;\n    *d=temp;\n}\nvoid blockswap(char *s,int count,int flag)\n{\n    int step = count * flag;\n    while (count--){\n        swap(s,s+step);\n        s += flag;\n    }\n}\nvoid shift(char *s,int n,int m)\n{\n    int left = 0;\n    int right = n - 1;\n    int flag = 1; //1表示从左向右交换，-1表示从右向左交换。\n    m %= n;\n    while(m != 0){\n        while(right-left >= 2*m - 1){\n            if(flag == 1){\n                blockswap(s+left,m,flag);\n                left += m;\n            }else{\n                blockswap(s+right,m,flag);\n                right -= m;\n            }\n        }\n        n = right-left + 1;\n        m = n - m;\n        flag = flag == -1 ? 1 : -1;\n    }\n}\n```\n从上面的分析可以知道，此算法也是满足题目要求。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/常见面试题复习：字符串-一.md","raw":"title: 常见面试题复习：字符串(一)\ntags:\n  - 字符串\n  - 笔试题\ncategories:\n  - 笔试\ndate: 2015-09-08 18:25:00\n---\n\n\n好久没有写代码了，趁现在有时间敲几行代码，培养一下手感。\n\n题目一：左旋转字符串\n题目描述：\n定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部，如把字符串abcdef左旋转2位得到字符串cdefab。\n请实现字符串左旋转的函数，要求对长度为n的字符串操作的时间复杂度为O(n)，空间复杂度为O(1)。\n\n这个问题最容易想到的是暴力移位或者再用一个数组来存放前面m个元素（此法空间复杂度显然不满足要求），下面看一下暴力移位，代码如下：\n``` c\nvoid leftshiftone(char *s,int n)\n{\n    char temp = *s;\n    for (int i = 1; i < n; i++){\n        s[i-1] = s[i];\n    }\n    s[n - 1] = temp;\n}\nvoid rightshiftone(char *s,int n)\n{\n    char temp = s[n - 1];\n    for (int i = n - 1; i > 0; i--){\n        s[i] = s[i - 1];\n    }\n    s[0] = temp;\n}\nvoid shift(char *s,int n,int m)\n{\n    if(NULL == s || n <=0 || m <= 0)\n        return ;\n    m %= n;\n    if (m > n /2){\n        m = n - m;\n        while(m--){\n            rightshiftone(s,n);\n        }\n    }\n    else{\n        while(m--){\n            leftshiftone(s,n);\n        }\n    }\n}\n```\n<!--more-->\n从这里可以看出数组的一个缺点：在进行移位、插入和删除某个元素是，数组将移动大量的数据。这个算法不符合时间复杂度为O(n)的要求，其时间复杂度为O(m*n)，空间复杂度是O(1)，空间复杂度满足要求。\n\n说道这个例子，就不得不提三步翻转法，因为这个问题是《编程珠玑》上的一个例题。\n\n将具有10个元素的数组向上旋转5个位置，即：将123456789A(这里为了表示方便用A代替10）翻转成6789A123456，看图：\n{% asset_img 图一.png 图一 %}\n\n这就是三步翻转法，下面来看一个字符串的例子：将abcdef翻转成cdefab，用A^T表示A的逆序，如：A=abc，A^T=cba。下面来实现一下这个翻转：\n1）将字符串abcdef分成两部分：A=ab，B=cdef；\n2）分别将A和B进行翻转得A^T=ba，B^T=fedc，生成行的字符串A^TB^T=bafedc；\n3）将A^TB^T进行翻转得：(A^TB^T)^T=cdefab，得到答案。\n\n将上面的方法转换成代码如下：\n``` c\nvoid reverse(char *s,int from,int to)\n{\n    while(from < to){\n        char temp = s[from];\n        s[from++] = s[to];\n        s[to--] = temp;\n    }\n}\nvoid shift(char *s,int n,int m)\n{\n    if(NULL == s || n <=0 || m <= 0)\n        return ;\n    m %= n;\n    reverse(s,0,m - 1);\n    reverse(s,m,n - 1);\n    reverse(s,0,n - 1);\n}\n```\n很容易看出这个算法是满足题目要求的，此法虽然满足要求，但是我们还是可以看到它还是做出了一些多余的交换，有没有一种方法能够实现交换的次数更少的算法呢？我可以这样去想象一下，如果有一种方法在一次赋值后就有一个字符到达了翻转后的最终位置，那么有n个字符需要去到它最终的位置，加上第一个腾出位置的字符放到最终位置进行的赋值，那么它一共就进行了n+1次赋值操作（注意是赋值）。下面来个简单点例子：将字符串A=abcde向左旋转3个字符，即：翻转成B=deabc。\n\n我们来分析一下：\n1）将源字符串A的第一字符（0号位置）a腾出来：\\_bcde，temp=a；\n2）找到第一个字符（0号位置，字符的位置从0开始编号）最终要放置的字符，通过字符串B知道，第一个位置最终的字符是d，它在字符串A的3号位置。把d放到A串的0号位置那么3号位置又被腾空出来，得字符串：A=dbc\\_e；\n3）3号位置已经腾空，现在找出3号位置最终的字符，并将其放置到3号位置，通过B串我们可以知道这个字符是b，b在A串的1号位置。把b放到3号位置得：A=d\\_cbe;\n4）步骤同步骤3），此时4号位置的e放到了1号位置，4号位置腾空：A=decb\\_;\n5）步骤同步骤3），此时2号位置的c放到了4号位置，2号位置腾空：A=de\\_bc；\n6）最后一步，将temp保存的字符a放置到2号位置，得到字符串B=deabc。\n\n这个过程最难的是确定j号位置腾空后，由哪号位置的字符来填充，如果能确定这个位置，这个问题就能解了，下面就来分析一下这个位置到底有什么规律。\n\n我们知道将长度为n的字符串左旋转m个字符，其实就是将字符串的前m个字符全部腾空，然后将第m+1位置（也就是m号字符）之后的所有字符向左边移动m个位置。\n{% asset_img 图二.png 图二 %}\n\n也就是说当j号位置后面还有m个字符的时候，j号位置放置的是j+m号位置的字符。但是当j号位置后面没有m个字符时，怎么办呢？其实很简单，把开头的这m个元素映射到最后一个字符后面的m个位置上去，如图：\n{% asset_img 图三.png 图三 %}\n\n开头的m个字符通过函数f(x)=x + n，映射到虚拟字符的位置，那么除虚拟字符的最后m个字符也可以用：j号位置放置j+m号位置的字符。此时也就有：j+m = x+n，也就有j+m-n=x。如果你对取余运算比较熟悉的话，可以通过(j+m)%n来统一上面两种情况：j+m<n时，说明j后面还有m个字符，此时 (j+m)%n= j+m；当j+m>=n时，说明j后面没有m个字符了，此时(j+m)%n=( j+m)-n=x。因此，我们可以得出结论，当j号位置放置的是(j+m)%n号位置的字符就能够解决这个问题。于是有下面的代码：\n``` c\nvoid shift(char *s,int n,int m)\n{\n    if(NULL == s || n <=0 || m <= 0)\n        return ;\n    m %= n;\n    char temp = s[0];\n    int j = 0;\n    for(; (j+m)%n != 0; j =(j+m)%n){\n        s[j]=s[(j+m)%n];\n    }\n    s[j] = temp;\n}\n```\n试一下：当s=abcde，m=3，得出结果：deabc，结果正确，但是如果s=abcd，m=2时，得到结果：cbad。怎么回事，怎么会这样，难道我们前面的推导有问题吗，为什么有时正确，有时错误呢，这是什么情况？\n\n不卖关子了，问题出在j的身上。在错误的情况下，a和c的位置是对的，只是b和d没有变动，也就是说j并没有遍历所有的位置，看一下j的变化，j=(j+m)%n，看到这个等式，不知道大家有什么感想。还记的我之前写过的一篇关于[分水问题](http://hanhaichensha.coding.me/blog/2015/02/02/RSA系类（二）：分水问题/)的日记吗？如果你忘了，你可以去看看。有一个m升的容器和一个n升的容器，j就是要分出来的水，现在的问题是j能取哪些值？答案是当m和n互质时，j能取遍0到n-1（这里假设m<n），对于这一点不清楚的小伙伴可以回去看看那篇分水的日记。这就能解释为什么有时能得到正确答案，有时不能。那该怎么样才能让它取遍0到n-1所有的值呢？分水问题有一个结论：只能取出m和n的最大公约数的整数倍的水，如m=4，n=6，那么它们的最大公约数是2，也就说用4升和6升的桶只能取出0，2，4升的水，1，3，5升的水是取不出来的。现在，将整个字符串分成gcd(m,n)（最大公约数）组，每一组的数值都是可以用能取出水的那组数值平移得到（组中成员同时加上一个常数得到），也就是说存在函数f(x*gcd(m,n))=x*gcd(m,n) + C，其中C是取值[0, gcd(m,n) -1]常数，x的取值范围是[0,n/gcd(m,n)-1]，如下图，按照箭头步骤对两个分组进行赋值，就能得到结果：\n{% asset_img 图四.png 图四 %}\n根据上面的分析得到代码：\n``` c\nint gcd(int n,int m)\n{\n    if(n <= 0 || m <= 0)\n        return 0;\n    int r=0;\n    while((r = m % n) != 0){\n        m = n;\n        n = r;\n    }\n    return n;\n}\nvoid shift(char *s,int n,int m)\n{\n    if(NULL == s || n <=0 || m <= 0)\n        return ;\n    m %= n;\n    int group = gcd(m,n);\n    for(int i = 0; i < group; i++){\n        char temp = s[i];\n        int j = i;\n        for(; (j+m)%n != i; j =(j+m)%n){\n            s[j] = s[(j+m)%n];\n        }\n        s[j] = temp;\n    }\n}\n```\n这个方法虽然也满足题目要求（不要以为有两个for循环，时间复杂度就是O(n2)），交换也变少了，但是这里面使用了取模运算，我们知道除法运算是比较耗时的，这也是这个算法的一个不足之处。\n\n前面说的方法无非就是要把字符一次到位的移动到最终位置，那我们还是可以使用下面的方法来进行求解（方法类似辗转相除法）：设字符串A=abcdefghijk，m=3，n=length(A)=11，left是最左边还没有交换的编号，right是最右边还没有交换的编号。\n1）如果，right - left >=2\\*m - 1时，将left到left+m-1号位置上的字符和left+m到left+2\\*m-1号位置上的字符进行交换，实现从左向右移动，如：def<font color=red>abc</font>ghijk；\n2）一直进行1）操作，直到right - left <2\\*m - 1，此时，由于要移到尾部的这m字符后面少于m个字符跟它交换。此时，前面的字符已经移动到了正确位置，现在只要考虑没有到正确位置的字符串，调整字符串长度n=right-left+1，m=n-m，如果m等于0退出，否则进入3）；\n3）此时可以将这m个字符后面的字符用类似1）的方法从右向左移动，如：将字符串defghi<font color=red>abc</font>jk的jk从右向左移动，得：defghi<font color=red>a</font><font color=blue>jk</font><font color=red>bc</font>；\n4）一直进行3）操作，直到right - left <2\\*m - 1，此时，由于要移到头部的这m字符前面少于m个字符跟它交换。此时，前面的字符已经移动到了正确位置，现在只要考虑没有到正确位置的字符串，调整字符串长度n=right-left+1，m=n-m，如果m等于0退出，否则进入1）；\n\n过程如图：\n{% asset_img 图五.png 图五 %}\n 代码如下：\n``` c\nvoid swap(char *s,char *d)\n{\n    char temp = *s;\n    *s=*d;\n    *d=temp;\n}\nvoid blockswap(char *s,int count,int flag)\n{\n    int step = count * flag;\n    while (count--){\n        swap(s,s+step);\n        s += flag;\n    }\n}\nvoid shift(char *s,int n,int m)\n{\n    int left = 0;\n    int right = n - 1;\n    int flag = 1; //1表示从左向右交换，-1表示从右向左交换。\n    m %= n;\n    while(m != 0){\n        while(right-left >= 2*m - 1){\n            if(flag == 1){\n                blockswap(s+left,m,flag);\n                left += m;\n            }else{\n                blockswap(s+right,m,flag);\n                right -= m;\n            }\n        }\n        n = right-left + 1;\n        m = n - m;\n        flag = flag == -1 ? 1 : -1;\n    }\n}\n```\n从上面的分析可以知道，此算法也是满足题目要求。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"常见面试题复习：字符串-一","published":1,"updated":"2016-07-21T07:51:05.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9svzl000ttkb9lq0iaq7x"},{"title":"博客名字的来由","date":"2015-02-01T05:41:50.000Z","_content":"\n\n近来脑袋发热，想经营一下博客，看看自己能写出点啥鬼东西。同时，我也想知道自己对一件事情能坚持多久。在此写下开博声明，一来用来告诫自己：“自己吹过的牛，就算糗死，也要吹下去”；二来激励身边更多的小伙伴加入进来。\n\n<!--more-->\n\n---\n\n正事已经说完，现在来聊一聊名字的问题，这么怪异的名字来源与简书中**凤红邪**的一篇短诗：[《史上最中二爆表的四首诗！·郁》](http://www.jianshu.com/p/cc326f492bff)。全诗如下：\n>谁人手中诛心剑，\n>\n>借我斩此纷绪乱。\n>\n>凝悲噎泪为佳人，\n>\n>颦笑盈盈牵肠断。\n>\n>苟活碌碌计得失，\n>\n>诟我赞我如何辨。\n>\n>但恨吾生之已入凡人道，\n>\n>美色声名萦怀抱。\n>\n>困此牢笼不得脱，\n>\n>安共猪狗无为老。\n>\n>撕胸剖腹问此心，\n>\n>生我何用难欢笑。\n>\n>君不见世人多为尘关锁，\n>\n>随欲绝忧能几个。\n>\n>吾独叛世逆众人，\n>\n>礼法陈规皆斩破。\n>\n>命数非天当由我，\n>\n>但求逍遥宁执错。\n>\n>狂歌痛饮日西斜，\n>\n>携酒一壶走天涯。\n>\n>散发赤脚从人谩，\n>\n>醉来眠处即为家。\n>\n>待得沧桑都历尽，\n>\n>心若止水看浮华。\n>\n>却问谁人能自在，\n>\n>皆是<font color=#0099ff size=5 face=\"黑体\">翰海一尘沙。</font>\n\n---\n博客名字就是取自最后一句“却问谁人能自在，皆是翰海一尘沙”。各位看官，以后请不要问我为什么要取这个名字，不为什么，就是恰巧看到了这首诗而已，没有特别的意义。如果非得说有什么意义的话，那就是写这篇博客来练一练Markdown语法。","source":"_posts/博客名字的由来.md","raw":"title: 博客名字的来由\ndate: 2015-02-01 13:41:50\ntags:\n- 杂谈\n- 关于博客\ncategories:\n- 杂谈\n---\n\n\n近来脑袋发热，想经营一下博客，看看自己能写出点啥鬼东西。同时，我也想知道自己对一件事情能坚持多久。在此写下开博声明，一来用来告诫自己：“自己吹过的牛，就算糗死，也要吹下去”；二来激励身边更多的小伙伴加入进来。\n\n<!--more-->\n\n---\n\n正事已经说完，现在来聊一聊名字的问题，这么怪异的名字来源与简书中**凤红邪**的一篇短诗：[《史上最中二爆表的四首诗！·郁》](http://www.jianshu.com/p/cc326f492bff)。全诗如下：\n>谁人手中诛心剑，\n>\n>借我斩此纷绪乱。\n>\n>凝悲噎泪为佳人，\n>\n>颦笑盈盈牵肠断。\n>\n>苟活碌碌计得失，\n>\n>诟我赞我如何辨。\n>\n>但恨吾生之已入凡人道，\n>\n>美色声名萦怀抱。\n>\n>困此牢笼不得脱，\n>\n>安共猪狗无为老。\n>\n>撕胸剖腹问此心，\n>\n>生我何用难欢笑。\n>\n>君不见世人多为尘关锁，\n>\n>随欲绝忧能几个。\n>\n>吾独叛世逆众人，\n>\n>礼法陈规皆斩破。\n>\n>命数非天当由我，\n>\n>但求逍遥宁执错。\n>\n>狂歌痛饮日西斜，\n>\n>携酒一壶走天涯。\n>\n>散发赤脚从人谩，\n>\n>醉来眠处即为家。\n>\n>待得沧桑都历尽，\n>\n>心若止水看浮华。\n>\n>却问谁人能自在，\n>\n>皆是<font color=#0099ff size=5 face=\"黑体\">翰海一尘沙。</font>\n\n---\n博客名字就是取自最后一句“却问谁人能自在，皆是翰海一尘沙”。各位看官，以后请不要问我为什么要取这个名字，不为什么，就是恰巧看到了这首诗而已，没有特别的意义。如果非得说有什么意义的话，那就是写这篇博客来练一练Markdown语法。","slug":"博客名字的由来","published":1,"updated":"2016-07-13T07:03:57.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw04000xtkb9jwye7ybb"},{"title":"单击微信文章进入原文的方法","date":"2016-03-06T06:05:55.000Z","_content":"昨天，一朋友因为我去年帮了她一点小忙而请吃了一顿豪华早茶，表示受之有愧，想想还是将这个方法分享一下。\n\n需求：当公众号向订阅用户推送一篇文章后，用户单击文章直接进入文章的原文，而不是进入微信的一个页面，然后再单击阅读原文才能进入到原文的页面，（这样对于一个有动画效果的H5页面，直接进入原文，可以直接看到动画效果，否则，有些用户点开后进入到微信的一个页面，没有单击阅读原文，从而不会看到动画效果，而且大部分用户都不会点击阅读原文）。如图：\n\n---\n#### 正常的流程：\n第一步：点击阅读原文\n\n{% asset_img 图一.png 图一 %} \n\n<!--more-->\n\n第二步：点击阅读原文\n\n{% asset_img 图二.png 图二 %}  \n\n第三步：到达原网页\n\n{% asset_img 图三.png 图三 %}\n  \n---\n#### 期望流程\n\n第一步：点击阅读原文\n\n{% asset_img 图四.png 图四 %}  \n\n第二步：到达原网页\n\n{% asset_img 图五.png 图五 %}  \n\n---\n\n期望的流程其实在2014年之前注册的公众号是有这个功能的，不过后来腾讯把公众号的好多功能都给限制了，至于其中缘由，我不清楚，也不想知道。那现在的公众号要怎样实现这个功能呢？通过分析有这种效果的公众号文章，发现这是一种“news”类型的消息，但是在微信开发文档的群发接口中：[http://mp.weixin.qq.com/wiki/15/40b6865b893947b764e2de8e4a1fb55f.html](http://mp.weixin.qq.com/wiki/15/40b6865b893947b764e2de8e4a1fb55f.html)，并没有真正的这种类型的消息，虽然有一种返回结果叫作“news”的东西，但是它并不是我们所期望的东西，还有一种叫作“mpnews”的消息，也不是我们期望的。后来在客服接口[http://mp.weixin.qq.com/wiki/11/c88c270ae8935291626538f9c64bd123.html](http://mp.weixin.qq.com/wiki/11/c88c270ae8935291626538f9c64bd123.html)中发现了这种类型的消息，抱着试一试的心态，居然成功了，当然了现在说起来很简单，但是在探索的阶段，它可是一个磨人的小妖精。\n\n---\n\n下面是用php实现此功能的代码：\n\n```php\n<?php\t\n\tset_time_limit(0);\n\n\tfunction encode2json($str) {\n\t\treturn urldecode(json_encode(url_encode($str)));\t\n\t}\n\n\tfunction url_encode($str) {\n\t\tif(is_array($str)) {\n\t\t\tforeach($str as $key=>$value) {\n\t\t\t\t$str[urlencode($key)] = url_encode($value);\n\t\t\t}\n\t\t} else {\n\t\t\t$str = urlencode($str);\n\t\t}\n\t\t\n\t\treturn $str;\n\t}\n\t\n\tfunction get_curl($url)\n\t{\n\t\tif (!extension_loaded('curl')) {\n            throw new Exception('cURL library is not loaded');\n        }\n\t\t$curl = curl_init();       \n\t\tcurl_setopt($curl, CURLOPT_URL, $url);       \n\t\tcurl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);\n\t\tcurl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 2);\n\t\tcurl_setopt($curl, CURLOPT_TIMEOUT, 30); \n\t\tcurl_setopt($curl, CURLOPT_RETURNTRANSFER, true); \n\t\t\n\t\treturn $curl;\n\t}\n\tfunction https_get($url)\n\t{       \n\t\ttry{\n\t\t\t$curl = get_curl($url);\n\t\t}catch(Exception $e){\n\t\t\tdie($e->getMessage());\n\t\t}\n\t\t$data = curl_exec($curl);       \n\t\tif (curl_errno($curl)) {\n\t\t\t$data = encode2json(array('error' => curl_error($curl)));\n\t\t}       \n\t\tcurl_close($curl);       \n\t\treturn $data;\n\t}\n\tfunction https_post($url, $data) {\n\t\ttry{\n\t\t\t$curl = get_curl($url);\n\t\t}catch(Exception $e){\n\t\t\tdie($e->getMessage());\n\t\t}\n\t\t$data_string = encode2json($data);\n\t\tcurl_setopt($curl, CURLOPT_POST, 1);\n\t\tcurl_setopt($curl, CURLOPT_POSTFIELDS, $data_string);\n\t\tcurl_setopt($curl, CURLOPT_HTTPHEADER, array(\n\t\t\t'Content-Type: application/json; charset=utf-8',\n\t\t\t'Content-Length: ' . strlen($data_string))\n\t\t);\n\t\t$data = curl_exec($curl);       \n\t\tif (curl_errno($curl)) {\n\t\t\t$data = encode2json(array('error' => curl_error($curl)));\n\t\t}       \n\t\tcurl_close($curl);       \n\t\treturn $data;\n\t}\n\t\n\t//参考文档：http://mp.weixin.qq.com/wiki/14/9f9c82c1af308e3b14ba9b973f99a8ba.html\n\tfunction get_wechat_token()\n\t{\n\t\t$appid = \"xxxxxxxxxxxxxxxxxx\";\n\t\t$appsecret = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\";\n\t\t\n\t\t$url = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=$appid&secret=$appsecret\";\n\t\t\n\t\t$result = json_decode(https_get($url));\n\t\tif(property_exists($result,'error')){\n\t\t\tdie($result->error);\n\t\t}\n\t\t\n\t\tif(!property_exists($result,'access_token')){\n\t\t\tdie('Get wechat token failed!');\n\t\t}\n\t\t\n\t\tprint_r($result);\n\t\techo \"<br />\";\n\t\treturn $result->access_token;\n\t}\n\t\n\t//参考文档：http://mp.weixin.qq.com/wiki/12/54773ff6da7b8bdc95b7d2667d84b1d4.html\n\tfunction get_brocast_user($token)\n\t{\n\t\t$url = \"https://api.weixin.qq.com/cgi-bin/user/get?access_token=$token&next_openid=\";\n\t\t$result = json_decode(https_get($url));\n\t\tif(property_exists($result,'error')){\n\t\t\tdie($result->error);\n\t\t}\n\t\tif(!property_exists($result,'data')){\n\t\t\tdie('Get wechat user failed!');\n\t\t}\n\t\t\t \n\t\treturn $result->data->openid;\t\t// 获得所有用户的Openid\n\t}\n\t\n\t//参考文档：\n\t//\t\t1、接口文档：http://mp.weixin.qq.com/wiki/15/40b6865b893947b764e2de8e4a1fb55f.html\n\t//\t\t2、news类型的消息（即：'msgtype'=>'news'）参考文档：\t\n\t//\t\t\t\thttp://mp.weixin.qq.com/wiki/11/c88c270ae8935291626538f9c64bd123.html\n\tfunction send_news($access_token,$arr)\n\t{\n\t\t$url  = \"https://api.weixin.qq.com/cgi-bin/message/mass/send?access_token=$access_token\";\n\t\t$data = array(\n\t\t\t\t\t'touser'=>$arr,\n\t\t\t\t\t'msgtype'=>'news',\n\t\t\t\t\t'news'=>array(\n\t\t\t\t\t\t'articles'=>array(\n\t\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t\t'title'=>'单击微信文章进入原文的方法',\n\t\t\t\t\t\t\t\t'description'=>'微信公众号文章无需单击阅读原文直接进入到原文的方法',\n\t\t\t\t\t\t\t\t'url'=>'http://t.cn/RGQwXwp',\n\t\t\t\t\t\t\t\t'picurl'=>'http://t.cn/RGQwaVW'\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t); \n\n\t\t$return_content = https_post($url, $data);\n\t\tprint_r($return_content);\n\t\techo \"<br />\";\n\t}\n\t\n\t$access_token = get_wechat_token();\n\t$users = get_brocast_user($access_token);\n\tsend_news($access_token,$users);\n?>\n\n```\n\n代码中的$appid = \"xxxxxxxxxxxxxxxxxx\";$appsecret = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\";可以从微信公众平台的后台的“开发”菜单下的“基本配置”中得到，如图：\n\n{% asset_img 图六.png 图六 %}  \n\n","source":"_posts/单击微信文章进入原文的方法.md","raw":"title: 单击微信文章进入原文的方法\ntags:\n  - 微信开发\ncategories:\n  - 微信开发\ndate: 2016-03-06 14:05:55\n---\n昨天，一朋友因为我去年帮了她一点小忙而请吃了一顿豪华早茶，表示受之有愧，想想还是将这个方法分享一下。\n\n需求：当公众号向订阅用户推送一篇文章后，用户单击文章直接进入文章的原文，而不是进入微信的一个页面，然后再单击阅读原文才能进入到原文的页面，（这样对于一个有动画效果的H5页面，直接进入原文，可以直接看到动画效果，否则，有些用户点开后进入到微信的一个页面，没有单击阅读原文，从而不会看到动画效果，而且大部分用户都不会点击阅读原文）。如图：\n\n---\n#### 正常的流程：\n第一步：点击阅读原文\n\n{% asset_img 图一.png 图一 %} \n\n<!--more-->\n\n第二步：点击阅读原文\n\n{% asset_img 图二.png 图二 %}  \n\n第三步：到达原网页\n\n{% asset_img 图三.png 图三 %}\n  \n---\n#### 期望流程\n\n第一步：点击阅读原文\n\n{% asset_img 图四.png 图四 %}  \n\n第二步：到达原网页\n\n{% asset_img 图五.png 图五 %}  \n\n---\n\n期望的流程其实在2014年之前注册的公众号是有这个功能的，不过后来腾讯把公众号的好多功能都给限制了，至于其中缘由，我不清楚，也不想知道。那现在的公众号要怎样实现这个功能呢？通过分析有这种效果的公众号文章，发现这是一种“news”类型的消息，但是在微信开发文档的群发接口中：[http://mp.weixin.qq.com/wiki/15/40b6865b893947b764e2de8e4a1fb55f.html](http://mp.weixin.qq.com/wiki/15/40b6865b893947b764e2de8e4a1fb55f.html)，并没有真正的这种类型的消息，虽然有一种返回结果叫作“news”的东西，但是它并不是我们所期望的东西，还有一种叫作“mpnews”的消息，也不是我们期望的。后来在客服接口[http://mp.weixin.qq.com/wiki/11/c88c270ae8935291626538f9c64bd123.html](http://mp.weixin.qq.com/wiki/11/c88c270ae8935291626538f9c64bd123.html)中发现了这种类型的消息，抱着试一试的心态，居然成功了，当然了现在说起来很简单，但是在探索的阶段，它可是一个磨人的小妖精。\n\n---\n\n下面是用php实现此功能的代码：\n\n```php\n<?php\t\n\tset_time_limit(0);\n\n\tfunction encode2json($str) {\n\t\treturn urldecode(json_encode(url_encode($str)));\t\n\t}\n\n\tfunction url_encode($str) {\n\t\tif(is_array($str)) {\n\t\t\tforeach($str as $key=>$value) {\n\t\t\t\t$str[urlencode($key)] = url_encode($value);\n\t\t\t}\n\t\t} else {\n\t\t\t$str = urlencode($str);\n\t\t}\n\t\t\n\t\treturn $str;\n\t}\n\t\n\tfunction get_curl($url)\n\t{\n\t\tif (!extension_loaded('curl')) {\n            throw new Exception('cURL library is not loaded');\n        }\n\t\t$curl = curl_init();       \n\t\tcurl_setopt($curl, CURLOPT_URL, $url);       \n\t\tcurl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);\n\t\tcurl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 2);\n\t\tcurl_setopt($curl, CURLOPT_TIMEOUT, 30); \n\t\tcurl_setopt($curl, CURLOPT_RETURNTRANSFER, true); \n\t\t\n\t\treturn $curl;\n\t}\n\tfunction https_get($url)\n\t{       \n\t\ttry{\n\t\t\t$curl = get_curl($url);\n\t\t}catch(Exception $e){\n\t\t\tdie($e->getMessage());\n\t\t}\n\t\t$data = curl_exec($curl);       \n\t\tif (curl_errno($curl)) {\n\t\t\t$data = encode2json(array('error' => curl_error($curl)));\n\t\t}       \n\t\tcurl_close($curl);       \n\t\treturn $data;\n\t}\n\tfunction https_post($url, $data) {\n\t\ttry{\n\t\t\t$curl = get_curl($url);\n\t\t}catch(Exception $e){\n\t\t\tdie($e->getMessage());\n\t\t}\n\t\t$data_string = encode2json($data);\n\t\tcurl_setopt($curl, CURLOPT_POST, 1);\n\t\tcurl_setopt($curl, CURLOPT_POSTFIELDS, $data_string);\n\t\tcurl_setopt($curl, CURLOPT_HTTPHEADER, array(\n\t\t\t'Content-Type: application/json; charset=utf-8',\n\t\t\t'Content-Length: ' . strlen($data_string))\n\t\t);\n\t\t$data = curl_exec($curl);       \n\t\tif (curl_errno($curl)) {\n\t\t\t$data = encode2json(array('error' => curl_error($curl)));\n\t\t}       \n\t\tcurl_close($curl);       \n\t\treturn $data;\n\t}\n\t\n\t//参考文档：http://mp.weixin.qq.com/wiki/14/9f9c82c1af308e3b14ba9b973f99a8ba.html\n\tfunction get_wechat_token()\n\t{\n\t\t$appid = \"xxxxxxxxxxxxxxxxxx\";\n\t\t$appsecret = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\";\n\t\t\n\t\t$url = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=$appid&secret=$appsecret\";\n\t\t\n\t\t$result = json_decode(https_get($url));\n\t\tif(property_exists($result,'error')){\n\t\t\tdie($result->error);\n\t\t}\n\t\t\n\t\tif(!property_exists($result,'access_token')){\n\t\t\tdie('Get wechat token failed!');\n\t\t}\n\t\t\n\t\tprint_r($result);\n\t\techo \"<br />\";\n\t\treturn $result->access_token;\n\t}\n\t\n\t//参考文档：http://mp.weixin.qq.com/wiki/12/54773ff6da7b8bdc95b7d2667d84b1d4.html\n\tfunction get_brocast_user($token)\n\t{\n\t\t$url = \"https://api.weixin.qq.com/cgi-bin/user/get?access_token=$token&next_openid=\";\n\t\t$result = json_decode(https_get($url));\n\t\tif(property_exists($result,'error')){\n\t\t\tdie($result->error);\n\t\t}\n\t\tif(!property_exists($result,'data')){\n\t\t\tdie('Get wechat user failed!');\n\t\t}\n\t\t\t \n\t\treturn $result->data->openid;\t\t// 获得所有用户的Openid\n\t}\n\t\n\t//参考文档：\n\t//\t\t1、接口文档：http://mp.weixin.qq.com/wiki/15/40b6865b893947b764e2de8e4a1fb55f.html\n\t//\t\t2、news类型的消息（即：'msgtype'=>'news'）参考文档：\t\n\t//\t\t\t\thttp://mp.weixin.qq.com/wiki/11/c88c270ae8935291626538f9c64bd123.html\n\tfunction send_news($access_token,$arr)\n\t{\n\t\t$url  = \"https://api.weixin.qq.com/cgi-bin/message/mass/send?access_token=$access_token\";\n\t\t$data = array(\n\t\t\t\t\t'touser'=>$arr,\n\t\t\t\t\t'msgtype'=>'news',\n\t\t\t\t\t'news'=>array(\n\t\t\t\t\t\t'articles'=>array(\n\t\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t\t'title'=>'单击微信文章进入原文的方法',\n\t\t\t\t\t\t\t\t'description'=>'微信公众号文章无需单击阅读原文直接进入到原文的方法',\n\t\t\t\t\t\t\t\t'url'=>'http://t.cn/RGQwXwp',\n\t\t\t\t\t\t\t\t'picurl'=>'http://t.cn/RGQwaVW'\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t); \n\n\t\t$return_content = https_post($url, $data);\n\t\tprint_r($return_content);\n\t\techo \"<br />\";\n\t}\n\t\n\t$access_token = get_wechat_token();\n\t$users = get_brocast_user($access_token);\n\tsend_news($access_token,$users);\n?>\n\n```\n\n代码中的$appid = \"xxxxxxxxxxxxxxxxxx\";$appsecret = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\";可以从微信公众平台的后台的“开发”菜单下的“基本配置”中得到，如图：\n\n{% asset_img 图六.png 图六 %}  \n\n","slug":"单击微信文章进入原文的方法","published":1,"updated":"2016-03-23T03:43:05.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw090014tkb986wtxzd8"},{"title":"别样的进制","date":"2016-06-05T16:09:05.000Z","_content":"\n\n在[《别样的整数表示和运算》](http://t.cn/R5qdeVp)中遗留了一个问题——进制转换问题。在进入今天的主题前，先给一个趣题让大家思考一下：\n\n{% blockquote 知乎老鼠与毒药问题 https://www.zhihu.com/question/19676641%}\n\n老鼠与毒药升级版：有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有三星期的时间进行实验，在某轮实验中死掉的老鼠，无法继续参与之后的实验。为了从 1000 个瓶子中找出毒药，你最少需要几只老鼠？\n\n{% endblockquote %}\n\n<!--more-->\n\n### 1、从十进制说起\n\n什么叫进制，进制又叫[进位制(下面定义来自中文维基百科)](https://zh.wikipedia.org/wiki/进位制)是一种记数方式，亦称进位计数法或位值计数法。利用这种记数法，可以使用有限种数字符号来表示所有的数值。一种进位制中可以使用的数字符号的数目称为这种进位制的基数或底数。若一个进位制的基数为n，即可称之为n进位制，简称n进制。现在最常用的进位制是十进制，这种进位制通常使用10个阿拉伯数字（即0-9）进行记数。\n\n我们可以用不同的进位制来表示同一个数。比如：十进数57(10)，可以用二进制表示为111001(2)，也可以用五进制表示为212(5)，同时也可以用八进制表示为71(8)、亦可用十六进制表示为39(16)，它们所代表的数值都是一样的。\n\n在10进制中有10个数字(0 - 9)，比如\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle 2506=2\\times 10^{3}+5\\times 10^{2}+0\\times 10^{1}+6\\times 10^{0}} \" type=\"image/svg+xml\" />\n\n在16进制中有16个数字(0–9 和 A–F)，比如\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle 171B=1\\times 16^{3}+7\\times 16^{2}+1\\times 16^{1}+B\\times 16^{0}}\" type=\"image/svg+xml\" />\n\n  (这里用字符B表示数字11)\n一般说来，b进制有b个数字，如果<embed src=\"http://latex.codecogs.com/svg.latex? {\\displaystyle a_{3},a_{2},a_{1},a_{0}}\" type=\"image/svg+xml\" /> 是其中四个数字，那么就有\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle a_{3}a_{2}a_{1}a_{0}=a_{3}\\times b^{3}+a_{2}\\times b^{2}+a_{1}\\times b^{1}+a_{0}\\times b^{0}}\" type=\"image/svg+xml\" />(注意，<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle a_{3}a_{2}a_{1}a_{0}}\" type=\"image/svg+xml\" /> 表示一个数字序列, 而不是数字的相乘)\n\n\n看完上面的定义，我不禁想到，所谓进位制，其实就是跟数表示与数字所在位置有关，在不同的位置上的数字代表了不同量级的大小。这与我们最开始的掰手指不同，掰手指无论你从左边掰到右边，还是从右边掰到左边，我们都是把所有手指代表的大小认为是相等的，且为1，然后用加法一个一个加起来，得到用掰手指代表的数。这就是在进位制出现之前，我们的祖先使用的计数方法，这是对数的一个初级抽象，这种例子还有很多，比如罗马人用I代表1，用V代表5，X代表10，L代表50，C代表100，D代表500，M代表1000，再往上就没了，罗马人要表示2就是用II，要表示100万的话，他们就要拼命话M了。不过罗马数字中也有一个跟位置有关的计数方法，比如：7他们就用VII（I在V右边用V+II=5+2），4用IV（I在V左边用V-I=5-1）表示或者IIII表示。\n\n大家都发现了这种计数方式麻烦了，要表示一个大一点的数要写好久，而且很费纸。于是印度人发明的包括0在内的10个阿拉伯数字的阿拉伯数表示法得到了大家的青睐。这种表示法书写简单，也就是我们现在使用的10进制数。\n\n说明了10进制数的来由，那现在我们深入讨论10进制的含义。10进制，只用0、1、2、3、4、5、6、7、8、9（当然，你还可以使用其它10个符号，比如a、b、c、d、e、f、g、h、i、j）这10个符号来表示所以的数，为什么是10个符号，估计多少跟我们有10根手指有关。如果只用一个符号来表示数，它只能让我们区分出10个数，如果要表示与前面不同的第11个数，我们就必须使用两字符来表示，这就是为什么说逢十进一，两个符号来表示，又有很多种情况，为了使表示有规律性，我们就规定数字位置的顺序，最右边的符号表示是用一个符号表示的那10个数，在这个符号的左边那一个符号又可以像这个符号一样表示10种情况，只不过它表示的基数是10了，这个概念就是我们所说的**个十百千万位**。使用这个统一的规律进行下去，我们就可以轻易的表示很大的数，而且很简单，上面定义中已经有数学抽象了，这里省略这部分。\n\n### 2、其他进制\n\n上面已经讨论了10进制的来由和规律，那么我们考虑一下这么一种情况：假如，在外太空有一个类似人类的智能物种，他们也有两只手，每只手只有4根手指，所以他们总共只有8根手指。那么现在问题来了，他们计数系统是什么样的呢？这里有一种可能就是跟我们使用技术系统类似，他们使用8个符号来表示所有的数，比如使用如下八个符号：a、b、c、d、e、f、g、h来表示。假如在未来的某天，我们跟这个星球的外星人建立的深厚的友谊，我们可以使用我们的资源与他们的资源进行交换。有一个外星人向你买一个东西，这个东西要15块钱（假设汇率是1），这时你该向他说要多少钱呢？\n\n要回答这问题，我们先来看看他们的计数系统的表示方法。与10进制类似的，只有8个符号，如果只用一个符号表示，最多能表示8个不同的数，如果要表示所有的数，必须使用多个符号，为了方便表示，引进位的概念，每一个位代表不同的量级，比如：a表示没有东西也就是数0，ba表示第九个数，由于包括0在内，所以第九个数就是我们10进制的8，由此，我们就能建立起一个类似10进制的8进制数的表示方式。抽象成数学概念就是：八进制就是用a、b、c、d、e、f、g、h不可拆分的基数通过位权（权值为8）来表示所有的数的计数方法。用公式表示就是\n<embed src=\"http://latex.codecogs.com/svg.latex? {\\displaystyle a_{n},\\dots,a_{2},a_{1},a_{0}\\in\\{a,b,c,d,e,f,g,h\\}}\" type=\"image/svg+xml\" />，\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle a_{n}\\dots a_{2}a_{1}a_{0}=a_{n}\\times 8^{n}+\\dots +a_{2}\\times 8^{2}+a_{1}\\times 8^{1}+a_{0}\\times 8^{0}} \" type=\"image/svg+xml\" />;\n\n现在回到刚刚那个问题，问题的本质就是问如何用8进制数表示10进制数15，所谓要进行转换，最关键的点是他们表示的数量是一样的，所以我们可得到下面这个公式：\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle a_{n}\\dots a_{2}a_{1}a_{0}=a_{n}\\times 8^{n}+\\dots+a_{2}\\times 8^{2}+a_{1}\\times 8^{1}+a_{0}\\times 8^{0}=x}\" type=\"image/svg+xml\" />;其中x就是十进制数。\n\n将公式变一下形：\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle a_{n}\\dots a_{2}a_{1}a_{0}=8\\times (8\\times (\\dots (8\\times a_{n} + a_{n-1})\\dots ) + a_{1})+a_{0}=x}\" type=\"image/svg+xml\" />;\n\n现在我们把x除以8，由于\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle x=8\\times (8\\times (\\dots (8\\times a_{n} + a_{n-1})\\dots ) + a_{1})+a_{0}}\" type=\"image/svg+xml\" />;\n所以有：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle x\\div 8=(8\\times (8\\times (\\dots (8\\times a_{n} + a_{n-1})\\dots ) + a_{1})+a_{0})\\div 8=8\\times (\\dots (8\\times a_{n} + a_{n-1})\\dots ) + a_{1}\\cdots a_{0}}\" type=\"image/svg+xml\" />，\n商是：<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle 8\\times (\\dots (8\\times a_{n} + a_{n-1})\\dots ) + a_{1}}\" type=\"image/svg+xml\" />,\n余数是：<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle a_{0}}\" type=\"image/svg+xml\" />;\n\n以此类推下去，可以依次得到<embed src=\"http://latex.codecogs.com/svg.latex? {\\displaystyle a_{0},a_{1},a_{2}\\dots,a_{n}}\" type=\"image/svg+xml\" />。\n\n这就是为什么在很多计算机教科书中进制转换的数学原理，教科书中只说了，用十进制数除以要转换为的进制数的权值，求出商和余数，然后再用商除以权值，求出商和余数，直至商为0，最后将余数倒过来写就是我吗要转换的结果。下面示范一下：\n\n1、<embed src=\"http://latex.codecogs.com/svg.latex? {\\displaystyle 15\\div 8=1\\cdots 7}\" type=\"image/svg+xml\" />,商是1，余数是7；\n2、<embed src=\"http://latex.codecogs.com/svg.latex? {\\displaystyle 1\\div 8=0\\cdots 1}\" type=\"image/svg+xml\" />，用上次的商除以8，此次商为0，余数1\n3、最后把求得的余数从后面最后余数向第一余数写下来：17，这就是结果，当然我们之前的协定是用a、b、c、d、e、f、g、h来表示，所以就是bh，这里不用0~7表示的原因是，这只是符号而已，不要被以前的思维定势绑架了自己，我们应该释放自己的想象力。\n\n在生活中其实还有好多进制，比如12进制、24进制、60进制等等，有兴趣的小伙伴，可以自己玩玩这些进制的表示和转换。请注意了，我们这里的转换都是用10进制作为跳板进行的，如果你想从8进制直接和12进制进行转换，你可以尝试一下有没有什么规律，找到了顺便告诉我一下。\n\n===========\n2016年6月6号10时更新：\n其他进制之间也是可以直接转换的，只要你有相应的进制的乘法表。\n\n===========\n\n### 3、回答老鼠和毒药问题\n\n老鼠与毒药升级版：有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有三星期的时间进行实验，在某轮实验中死掉的老鼠，无法继续参与之后的实验。为了从 1000 个瓶子中找出毒药，你最少需要几只老鼠？\n\n如果我们使用某种进制的数对这1000平液体进行编码，每一次实验都可以用一只老鼠来负责某一位的某个符号的检测，如果老鼠不幸牺牲了，说明这一位就是这个符号，这一位不需要进行下面的的实验了，如果老鼠没事，那让老鼠再接再厉，继续对这一位进行检查。最后就能确定是哪个数，也就能找到对应的瓶子，那问题就转变成了，用什么进制进行编码，最大数（这里是1000）在这种编码下一共要多少位字符表示，就要多少只老鼠。\n\n由于只有三个星期的时间，只能做3此次实验。也就是说每一位都只有3中情况，很容易就想到了用三进制来对1~1000进行编码，如下：\n\n{% asset_img 图一.png 图一 %}\n\n1、第一周，让这七只都喝相应位为0的瓶子中的液体，比如：老鼠1喝1~6等，老鼠7喝3，……，996，999，如图，用红线圈起来的。\n\n{% asset_img 图二.png 图二 %}\n\n2、一周后，如果老鼠1牺牲了，那么可以确定有毒那瓶的编码最高位是0，那么这个编号就是0xxxxxx。那么接下来，让剩下的6只老鼠依旧喝之前负责的那一位上符号为1的液体，比如：老鼠2喝995~1000等，如图，用红线圈起来的。\n\n{% asset_img 图三.png 图三 %}\n\n3、两周后，如果老鼠4牺牲了，那么可以确定有毒那瓶的编码从右边数第四位是1，那么这个编号就是0xx1xxx。那么接下来，让剩下的5只老鼠依旧喝之前负责的那一位上符号为2的液体，比如：老鼠5喝995~998等，如图，用红线圈起来的。\n\n{% asset_img 图四.png 图四 %}\n\n4、三周后，老鼠2、3、5、6、7应该都会牺牲，那么可以确定有毒那瓶的编码的2、3、5、6、7位是2，那么这个编号就是0221222，也就是701号那瓶是有毒液体，为什么呢？因为，通过前两周的实验，我们已经排除了有毒液体编号在2、3、5、6、7位上是0和1的可能性，否则，老鼠2、3、5、6、7在前两次实验中就应该牺牲了。所以第三周的实验是浪费掉的，还把所有老鼠害死了。\n\n所以，我们可以设计的方案是有问题的，进行三次实验，其实要用四进制来表示1~1000这些数，这样我们只需要使用5只老鼠，具体步骤不详写了，有兴趣的小伙伴可以自己去推演一遍。\n\n","source":"_posts/别样的进制.md","raw":"title: 别样的进制\ntags:\n  - 计算机基础\n  - 数学\ncategories:\n  - 计算机基础\ndate: 2016-06-06 00:09:05\n---\n\n\n在[《别样的整数表示和运算》](http://t.cn/R5qdeVp)中遗留了一个问题——进制转换问题。在进入今天的主题前，先给一个趣题让大家思考一下：\n\n{% blockquote 知乎老鼠与毒药问题 https://www.zhihu.com/question/19676641%}\n\n老鼠与毒药升级版：有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有三星期的时间进行实验，在某轮实验中死掉的老鼠，无法继续参与之后的实验。为了从 1000 个瓶子中找出毒药，你最少需要几只老鼠？\n\n{% endblockquote %}\n\n<!--more-->\n\n### 1、从十进制说起\n\n什么叫进制，进制又叫[进位制(下面定义来自中文维基百科)](https://zh.wikipedia.org/wiki/进位制)是一种记数方式，亦称进位计数法或位值计数法。利用这种记数法，可以使用有限种数字符号来表示所有的数值。一种进位制中可以使用的数字符号的数目称为这种进位制的基数或底数。若一个进位制的基数为n，即可称之为n进位制，简称n进制。现在最常用的进位制是十进制，这种进位制通常使用10个阿拉伯数字（即0-9）进行记数。\n\n我们可以用不同的进位制来表示同一个数。比如：十进数57(10)，可以用二进制表示为111001(2)，也可以用五进制表示为212(5)，同时也可以用八进制表示为71(8)、亦可用十六进制表示为39(16)，它们所代表的数值都是一样的。\n\n在10进制中有10个数字(0 - 9)，比如\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle 2506=2\\times 10^{3}+5\\times 10^{2}+0\\times 10^{1}+6\\times 10^{0}} \" type=\"image/svg+xml\" />\n\n在16进制中有16个数字(0–9 和 A–F)，比如\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle 171B=1\\times 16^{3}+7\\times 16^{2}+1\\times 16^{1}+B\\times 16^{0}}\" type=\"image/svg+xml\" />\n\n  (这里用字符B表示数字11)\n一般说来，b进制有b个数字，如果<embed src=\"http://latex.codecogs.com/svg.latex? {\\displaystyle a_{3},a_{2},a_{1},a_{0}}\" type=\"image/svg+xml\" /> 是其中四个数字，那么就有\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle a_{3}a_{2}a_{1}a_{0}=a_{3}\\times b^{3}+a_{2}\\times b^{2}+a_{1}\\times b^{1}+a_{0}\\times b^{0}}\" type=\"image/svg+xml\" />(注意，<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle a_{3}a_{2}a_{1}a_{0}}\" type=\"image/svg+xml\" /> 表示一个数字序列, 而不是数字的相乘)\n\n\n看完上面的定义，我不禁想到，所谓进位制，其实就是跟数表示与数字所在位置有关，在不同的位置上的数字代表了不同量级的大小。这与我们最开始的掰手指不同，掰手指无论你从左边掰到右边，还是从右边掰到左边，我们都是把所有手指代表的大小认为是相等的，且为1，然后用加法一个一个加起来，得到用掰手指代表的数。这就是在进位制出现之前，我们的祖先使用的计数方法，这是对数的一个初级抽象，这种例子还有很多，比如罗马人用I代表1，用V代表5，X代表10，L代表50，C代表100，D代表500，M代表1000，再往上就没了，罗马人要表示2就是用II，要表示100万的话，他们就要拼命话M了。不过罗马数字中也有一个跟位置有关的计数方法，比如：7他们就用VII（I在V右边用V+II=5+2），4用IV（I在V左边用V-I=5-1）表示或者IIII表示。\n\n大家都发现了这种计数方式麻烦了，要表示一个大一点的数要写好久，而且很费纸。于是印度人发明的包括0在内的10个阿拉伯数字的阿拉伯数表示法得到了大家的青睐。这种表示法书写简单，也就是我们现在使用的10进制数。\n\n说明了10进制数的来由，那现在我们深入讨论10进制的含义。10进制，只用0、1、2、3、4、5、6、7、8、9（当然，你还可以使用其它10个符号，比如a、b、c、d、e、f、g、h、i、j）这10个符号来表示所以的数，为什么是10个符号，估计多少跟我们有10根手指有关。如果只用一个符号来表示数，它只能让我们区分出10个数，如果要表示与前面不同的第11个数，我们就必须使用两字符来表示，这就是为什么说逢十进一，两个符号来表示，又有很多种情况，为了使表示有规律性，我们就规定数字位置的顺序，最右边的符号表示是用一个符号表示的那10个数，在这个符号的左边那一个符号又可以像这个符号一样表示10种情况，只不过它表示的基数是10了，这个概念就是我们所说的**个十百千万位**。使用这个统一的规律进行下去，我们就可以轻易的表示很大的数，而且很简单，上面定义中已经有数学抽象了，这里省略这部分。\n\n### 2、其他进制\n\n上面已经讨论了10进制的来由和规律，那么我们考虑一下这么一种情况：假如，在外太空有一个类似人类的智能物种，他们也有两只手，每只手只有4根手指，所以他们总共只有8根手指。那么现在问题来了，他们计数系统是什么样的呢？这里有一种可能就是跟我们使用技术系统类似，他们使用8个符号来表示所有的数，比如使用如下八个符号：a、b、c、d、e、f、g、h来表示。假如在未来的某天，我们跟这个星球的外星人建立的深厚的友谊，我们可以使用我们的资源与他们的资源进行交换。有一个外星人向你买一个东西，这个东西要15块钱（假设汇率是1），这时你该向他说要多少钱呢？\n\n要回答这问题，我们先来看看他们的计数系统的表示方法。与10进制类似的，只有8个符号，如果只用一个符号表示，最多能表示8个不同的数，如果要表示所有的数，必须使用多个符号，为了方便表示，引进位的概念，每一个位代表不同的量级，比如：a表示没有东西也就是数0，ba表示第九个数，由于包括0在内，所以第九个数就是我们10进制的8，由此，我们就能建立起一个类似10进制的8进制数的表示方式。抽象成数学概念就是：八进制就是用a、b、c、d、e、f、g、h不可拆分的基数通过位权（权值为8）来表示所有的数的计数方法。用公式表示就是\n<embed src=\"http://latex.codecogs.com/svg.latex? {\\displaystyle a_{n},\\dots,a_{2},a_{1},a_{0}\\in\\{a,b,c,d,e,f,g,h\\}}\" type=\"image/svg+xml\" />，\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle a_{n}\\dots a_{2}a_{1}a_{0}=a_{n}\\times 8^{n}+\\dots +a_{2}\\times 8^{2}+a_{1}\\times 8^{1}+a_{0}\\times 8^{0}} \" type=\"image/svg+xml\" />;\n\n现在回到刚刚那个问题，问题的本质就是问如何用8进制数表示10进制数15，所谓要进行转换，最关键的点是他们表示的数量是一样的，所以我们可得到下面这个公式：\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle a_{n}\\dots a_{2}a_{1}a_{0}=a_{n}\\times 8^{n}+\\dots+a_{2}\\times 8^{2}+a_{1}\\times 8^{1}+a_{0}\\times 8^{0}=x}\" type=\"image/svg+xml\" />;其中x就是十进制数。\n\n将公式变一下形：\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle a_{n}\\dots a_{2}a_{1}a_{0}=8\\times (8\\times (\\dots (8\\times a_{n} + a_{n-1})\\dots ) + a_{1})+a_{0}=x}\" type=\"image/svg+xml\" />;\n\n现在我们把x除以8，由于\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle x=8\\times (8\\times (\\dots (8\\times a_{n} + a_{n-1})\\dots ) + a_{1})+a_{0}}\" type=\"image/svg+xml\" />;\n所以有：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle x\\div 8=(8\\times (8\\times (\\dots (8\\times a_{n} + a_{n-1})\\dots ) + a_{1})+a_{0})\\div 8=8\\times (\\dots (8\\times a_{n} + a_{n-1})\\dots ) + a_{1}\\cdots a_{0}}\" type=\"image/svg+xml\" />，\n商是：<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle 8\\times (\\dots (8\\times a_{n} + a_{n-1})\\dots ) + a_{1}}\" type=\"image/svg+xml\" />,\n余数是：<embed src=\"http://latex.codecogs.com/svg.latex?{\\displaystyle a_{0}}\" type=\"image/svg+xml\" />;\n\n以此类推下去，可以依次得到<embed src=\"http://latex.codecogs.com/svg.latex? {\\displaystyle a_{0},a_{1},a_{2}\\dots,a_{n}}\" type=\"image/svg+xml\" />。\n\n这就是为什么在很多计算机教科书中进制转换的数学原理，教科书中只说了，用十进制数除以要转换为的进制数的权值，求出商和余数，然后再用商除以权值，求出商和余数，直至商为0，最后将余数倒过来写就是我吗要转换的结果。下面示范一下：\n\n1、<embed src=\"http://latex.codecogs.com/svg.latex? {\\displaystyle 15\\div 8=1\\cdots 7}\" type=\"image/svg+xml\" />,商是1，余数是7；\n2、<embed src=\"http://latex.codecogs.com/svg.latex? {\\displaystyle 1\\div 8=0\\cdots 1}\" type=\"image/svg+xml\" />，用上次的商除以8，此次商为0，余数1\n3、最后把求得的余数从后面最后余数向第一余数写下来：17，这就是结果，当然我们之前的协定是用a、b、c、d、e、f、g、h来表示，所以就是bh，这里不用0~7表示的原因是，这只是符号而已，不要被以前的思维定势绑架了自己，我们应该释放自己的想象力。\n\n在生活中其实还有好多进制，比如12进制、24进制、60进制等等，有兴趣的小伙伴，可以自己玩玩这些进制的表示和转换。请注意了，我们这里的转换都是用10进制作为跳板进行的，如果你想从8进制直接和12进制进行转换，你可以尝试一下有没有什么规律，找到了顺便告诉我一下。\n\n===========\n2016年6月6号10时更新：\n其他进制之间也是可以直接转换的，只要你有相应的进制的乘法表。\n\n===========\n\n### 3、回答老鼠和毒药问题\n\n老鼠与毒药升级版：有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有三星期的时间进行实验，在某轮实验中死掉的老鼠，无法继续参与之后的实验。为了从 1000 个瓶子中找出毒药，你最少需要几只老鼠？\n\n如果我们使用某种进制的数对这1000平液体进行编码，每一次实验都可以用一只老鼠来负责某一位的某个符号的检测，如果老鼠不幸牺牲了，说明这一位就是这个符号，这一位不需要进行下面的的实验了，如果老鼠没事，那让老鼠再接再厉，继续对这一位进行检查。最后就能确定是哪个数，也就能找到对应的瓶子，那问题就转变成了，用什么进制进行编码，最大数（这里是1000）在这种编码下一共要多少位字符表示，就要多少只老鼠。\n\n由于只有三个星期的时间，只能做3此次实验。也就是说每一位都只有3中情况，很容易就想到了用三进制来对1~1000进行编码，如下：\n\n{% asset_img 图一.png 图一 %}\n\n1、第一周，让这七只都喝相应位为0的瓶子中的液体，比如：老鼠1喝1~6等，老鼠7喝3，……，996，999，如图，用红线圈起来的。\n\n{% asset_img 图二.png 图二 %}\n\n2、一周后，如果老鼠1牺牲了，那么可以确定有毒那瓶的编码最高位是0，那么这个编号就是0xxxxxx。那么接下来，让剩下的6只老鼠依旧喝之前负责的那一位上符号为1的液体，比如：老鼠2喝995~1000等，如图，用红线圈起来的。\n\n{% asset_img 图三.png 图三 %}\n\n3、两周后，如果老鼠4牺牲了，那么可以确定有毒那瓶的编码从右边数第四位是1，那么这个编号就是0xx1xxx。那么接下来，让剩下的5只老鼠依旧喝之前负责的那一位上符号为2的液体，比如：老鼠5喝995~998等，如图，用红线圈起来的。\n\n{% asset_img 图四.png 图四 %}\n\n4、三周后，老鼠2、3、5、6、7应该都会牺牲，那么可以确定有毒那瓶的编码的2、3、5、6、7位是2，那么这个编号就是0221222，也就是701号那瓶是有毒液体，为什么呢？因为，通过前两周的实验，我们已经排除了有毒液体编号在2、3、5、6、7位上是0和1的可能性，否则，老鼠2、3、5、6、7在前两次实验中就应该牺牲了。所以第三周的实验是浪费掉的，还把所有老鼠害死了。\n\n所以，我们可以设计的方案是有问题的，进行三次实验，其实要用四进制来表示1~1000这些数，这样我们只需要使用5只老鼠，具体步骤不详写了，有兴趣的小伙伴可以自己去推演一遍。\n\n","slug":"别样的进制","published":1,"updated":"2016-06-06T02:18:48.458Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw0s0019tkb9aicrpagh"},{"title":"别样的整数表示和运算","date":"2016-06-04T15:47:02.000Z","_content":"\n\n最近进入懒癌晚期，拖延症重症期，总惦记着让自己写点东西，然而回头一看，已经将近两个月没写东西，看书也开始打瞌睡，彻底进入老年人模式。细思极恐，鼓起勇气，把最近吹着电扇，抠着脚丫看的些东西记录一下。此文涉及的知识非常简单，主要是涉及小学整数加减运算。\n\n主要是温习一下计算机基础知识，计算机的信息表示和处理基础二进制整数的表示和运算。不过，我不打算照着书本介绍一下二进制，今天我们使用我们熟知的十进制（也就是我们平时使用的数）来介绍其中的原理。这样做的好处有很多：1、对于不熟悉二进制的或者说不熟悉进制的读者也可以理解一二，而不用多费口舌去介绍进制的概念；2、使用十进制，可以让自己对书本上的原理有更好的理解；3、使用十进制，可以让自己增进对知识的迁移能力，已达到触类旁通等等。\n\n### 1、小学一年级加法（十以内加法）\n\n请注意了，各位童鞋，请用掰手指的方法告诉下面这道题加法题的答案\n\n**题目1：3+5=？**\n\n\n有八根手指对吧。再来\n\n**题目2：6+7=？**\n\n\n多少？13？你确定你是13吗？请问你真的有13根手指吗？反正我是只看到了3根手指，我的答案是3。这不禁让人感叹人生苦短，在有限的时间范围之内，你想得到的越多，反而拥有的会越少。一不小心又变成了鸡汤小短文，寓言小故事。\n<!--more-->\n### 2、小学二年级加减法（一百以内加减法）\n\n一年级的太简单了，我们快速进入二年级，请听题：\n\n\n**题目3：28+57=？**\n\n\n答案是……，我还没算出来，容我开个挂，用计算器算一下，答案是85，各位小盘友，使用一百根火柴棒就能算出来哦(*^__^*)。接着看题：\n\n**题目4：68+57=？**\n\n请注意了，你只有一百根火柴棒，这次你应该能给出正确答案，答案是：25。到目前为止，你已经学会了加法了，下面来学习减法：\n\n**题目5：68-43=？**\n\n不啰嗦了，直接给答案：25。来一道有难度的减法：\n\n**题目6：28-57=？**\n\n以我小学二年级的智商，表示不知道答案。那让我们进入到高年级阶段。\n\n### 3、高年级阶段（部分涉及超越了小学知识）\n\n所谓高年级就是知道了负数这么一个概念，所以题目6的答案就是-29。既然进入了高年级，那我们来做另外一件有意思的事，把减法变成加法，省的记两种运算规则。我们来仔细看一下题目4和题目5，\n**题目4：68+57=？**\n**题目5：68-43=？**\n\n这两道题根据**有限范围内**的加减法得出的结果是一样的，都是25，那我们是不是可以将题目5的减法变成题目4的加法呢？进一步，在**有限范围内**的加减法，是不是所有的减法都可以转变成加法，使用加法规则做减法运算呢？答案是肯定的，下面我们就来实现这一猜想。\n\n我们都知道，一个数减去一个数等于一个数加上一个负数，现在的问题是怎么把这个负数表示成一个正数。你有没有发现，题目4和题目5中的第二运算数57和43的关系，这两个数加起来57+43=100，正好是我们所规定的范围（一百以内的加减法），当然，如果按照一百以内不含一百的加法计算，这个结果应该是0。找到这个规律，我们来看是不是真的是这样呢？再来验证一下，73-27=73+73=46（请注意这都是都是100以内的计算）。好像是对的，为什么呢？因为100以内的加法，超过100（包括100）的数都要减去100，也就是：73-27=73+(73-100)=73+73-100，此时73+73-100正好是表达100以内的加法运算。好像有什么不对，谁能保证所有的运算都能像73+73-100这样，前两个数的和大于100呢，有没可能小于100呢？那肯定是有可能的，就拿这个例子来说，假设第一个数为x，要x+73<100，也就是x<100-73=27，也就是说x-27是一个负数，同时x+73-100也正好是一个负数，也说明这个两个数是相等的，但它还是用负数表示。综上，当y>0，x-y可以表示成x-y+100，也就是说-y用正数表示是100-y。\n\n### 3、正规化阶段\n\n经过前面一些简单的介绍，让我们来总结和归纳一下这个**在一定范围内**的加减法运算。\n\n#### 1、让数的表示更正规化\n\n上面提到过正数和负数的表示，以及如何将一个减法变成一个加法，然和将负数变成一个正数进行相加，且等到与加法相等的结果。现在我们将其进行更进一步的整理。\n\n表示一个一百以内的十进制数（不包括100，当然这里所说的数是指|x|<100的数），我们只需要两个数字进行组合即可得到，考虑到有正与负数，我们多加一位表示正负，这一位可以是+、-，比如+20、-60等。我也说过了，我现在是懒癌晚期，我只想学习正数加法，我天真的把所有数都变成正数，而且只是数，连正负号都是用数字，还能表示出这个数是正数还是负数，所以绝对值在100以内的数，只需要三位数表示，而且我们只用三个数表示。明确了目标，那开始吧：\n\n100以内的正数表示：最高位用0或1表示这是一个正数，后两位表示数的大小。比如：+20表示成020。\n绝对值100以内的负数的表示：最高位用8或9表示是负数，一般使用9，后两位表示数的大小，当然了为了能让负数变成正数加法，数的大小部分还是用100-数的大小部分。比如：-60表示成940（9是符号位，40=100-60）。\n\n\n#### 2、让计算方法更正规化\n\n将数的表示正规化后，我们用正规化后的数带入之前的题目中进行计算，注意符号位也当作数值进行运算，且只能保留最低三位数，看看能不能得到正确答案：\n\n**题目3：28+57=028+057=085**\n**题目4：68+57=068+057=125=025     (前面说过，0或1都表示正数，通常我们会把1变成0来表示)**\n**题目5：68-43=068+957=1025（超过了3个位，把最高为丢掉）=025**\n**题目6：28-57=028+943=971**\n**题目7：-66-88=934+912=1846（超过了3位，把最高位丢掉）=846=946(前面说过，8或9都表示负数，通常我们会把8变成9来表示)**\n\n题目3、4、5的结果都是正数，且结果和我们之前得到是一样的，题目6、7的结果是负数，题6值为100-71=29，所以结果是-29，也与我之前的结果一致，题7的值为-54，也是正确值。至此，我们就实现了绝对值在100以内的正负数加减法的正规化，全部简化为加法运算。\n\n至此，可以结束本文了，不过，我们现在不禁要问，为什么我们这样做可以得到与我们以前计算方法一致的结果呢？\n\n嗯，这个超出了小学数学知识的范畴了，我们之所以可以等到相同的结果，因为我们讨论的**在一定范围内**的带符号加法运算和**在一定范围内**的不带符号的加法运算都是一个阿贝尔群，还具有相同的单位元，而且表示的范围是符合双射关系。简单点说，我们现在讨论的整数加法是一个[阿贝尔群](https://zh.wikipedia.org/wiki/阿贝尔群)，满足（下面是个人的通俗说法，准确定义请参考相关专业书籍）：\n1、封闭性：通俗说就是加数与和属于同样的一个取值域，比如绝对值100以内的加法运算，如果大于等于100我们就减去100，得到的和还是在100以内，转换成不带正负号的加法，就是计算[0,999]内的正整数加法，加数与和都是在[0,999]区间；\n2、结合律：就是满足结合律，a+b+c=(a+b)+c=a+(b+c)，a、b、c是任意取值域的值;\n3、单位元：就是满足，a+e=a，e+a=a，a是任意取值域的值，e就是单位元,这里两种情况的单位元都是0；\n4、逆元：对取值域中的任意a，取值域中都存在b，使得a+b=单位元，b称为a的逆元。比如：绝对值100以内的加法运算，x的逆元就是-x，而在[0,999]无符号加法的x的逆元就是1000-x；\n5、交换律：对取值域中的任意a、b，都有a+b=b+a。\n\n这就是原因，估计很多小伙伴根本看不懂，只能说就当热闹看看，不要求弄懂。\n\n### 4、衍生阶段\n\n说了这么久，说好的计算机基础呢？为什么与计算机没半毛钱关系，鉴于此，我就简单说一下，计算机使用的是二进制，加法分为有符号和无符号整数加法。有符号的计算使用了类似上面的方法，正数最高位是0，负数最高位是1，后面的位表示值。\n\n用一个例子说明一下：\n用4位二进制表示一个数，最高位是符号位，还有3位用于表示数值，所以二进制数的取值范围是[-8,7],\n\n**题目8：2-4=0010+1100=1110=-2**\n\n\n最后强调一下，有些小伙伴说，一个数的补码很难求，其实，在二进制中的补码其实就是上面说的逆元，只要你理解了上面逆元的概念，是很好求的，比如十进制中减掉一个数，其实就是加上这个数的逆元。\n举几个例子熟练一下（用4位数表示，最高位是符号位），算法就是：x逆元=10……0-x（10……0总共有指定数的表示位数个0，用4位数表示，因此这里是4）：\n-1=1的逆元=10000-1=9999\n1=-1的逆元=10000-(-1)=10000+1=0001\n-48=48的逆元=10000-48=9952\n\n下面是一个二进制的例子：\n-4=0100的逆元=10000-0100=1100\n\n下面是一些计算中的补码（即逆元）的应用：\n20-48=0020+(10000-48)=0020+9952=9972=-28，同样的在二进制中，2-4=0010+(10000-0100)=0010+1100=1110=-2\n\n当然如果你学过计算机相关知识，还有一种求补码（逆元）的方法，原码（原数）取反加一即得补码（逆元），其中原码取反得到的数被成为反码。取反就是：指定的位数中的最大数-原码，什么意思？举个例子，用四位数表示下面的数的反码，由于是用四位数表示，所以四位数最大能表示的数是9999：\n48的反码=9999-48=9951\n根据：补码=反码+1得：\n48的补码=48的反码+1=9951+1=9952=-48\n同理，用二进制表示下面的数，四位最大二进制数能表示的最大数是1111：\n4的反码=1111-0100=1011\n4的补码=4的反码+1=1011+1=1100=-4\n\n\n### 小结\n\n\n在**有限范围内**的整数计算中，将负数使用补码（也就是逆元）参与运算，就能只使用加法实现有符号整数的加减法运算，这其中使用到的就是群的性质，尤其是逆元公式：x+y=e。在有符号整数计算中x+(-x)=0，而无符号整数计算有：x+(x的逆元)=0，所以我们将无符号整数中的逆元等效于有符号整数中的负数，以此达到只使用加法实现加减法运算的目的。本文还有一点没写清楚，那就是进制转换，后面几个例子中涉及十进制转二进制，等有时间再写。","source":"_posts/别样的整数表示和运算.md","raw":"title: 别样的整数表示和运算\ntags:\n  - 计算机基础\n  - 数学\ncategories:\n  - 计算机基础\ndate: 2016-06-04 23:47:02\n---\n\n\n最近进入懒癌晚期，拖延症重症期，总惦记着让自己写点东西，然而回头一看，已经将近两个月没写东西，看书也开始打瞌睡，彻底进入老年人模式。细思极恐，鼓起勇气，把最近吹着电扇，抠着脚丫看的些东西记录一下。此文涉及的知识非常简单，主要是涉及小学整数加减运算。\n\n主要是温习一下计算机基础知识，计算机的信息表示和处理基础二进制整数的表示和运算。不过，我不打算照着书本介绍一下二进制，今天我们使用我们熟知的十进制（也就是我们平时使用的数）来介绍其中的原理。这样做的好处有很多：1、对于不熟悉二进制的或者说不熟悉进制的读者也可以理解一二，而不用多费口舌去介绍进制的概念；2、使用十进制，可以让自己对书本上的原理有更好的理解；3、使用十进制，可以让自己增进对知识的迁移能力，已达到触类旁通等等。\n\n### 1、小学一年级加法（十以内加法）\n\n请注意了，各位童鞋，请用掰手指的方法告诉下面这道题加法题的答案\n\n**题目1：3+5=？**\n\n\n有八根手指对吧。再来\n\n**题目2：6+7=？**\n\n\n多少？13？你确定你是13吗？请问你真的有13根手指吗？反正我是只看到了3根手指，我的答案是3。这不禁让人感叹人生苦短，在有限的时间范围之内，你想得到的越多，反而拥有的会越少。一不小心又变成了鸡汤小短文，寓言小故事。\n<!--more-->\n### 2、小学二年级加减法（一百以内加减法）\n\n一年级的太简单了，我们快速进入二年级，请听题：\n\n\n**题目3：28+57=？**\n\n\n答案是……，我还没算出来，容我开个挂，用计算器算一下，答案是85，各位小盘友，使用一百根火柴棒就能算出来哦(*^__^*)。接着看题：\n\n**题目4：68+57=？**\n\n请注意了，你只有一百根火柴棒，这次你应该能给出正确答案，答案是：25。到目前为止，你已经学会了加法了，下面来学习减法：\n\n**题目5：68-43=？**\n\n不啰嗦了，直接给答案：25。来一道有难度的减法：\n\n**题目6：28-57=？**\n\n以我小学二年级的智商，表示不知道答案。那让我们进入到高年级阶段。\n\n### 3、高年级阶段（部分涉及超越了小学知识）\n\n所谓高年级就是知道了负数这么一个概念，所以题目6的答案就是-29。既然进入了高年级，那我们来做另外一件有意思的事，把减法变成加法，省的记两种运算规则。我们来仔细看一下题目4和题目5，\n**题目4：68+57=？**\n**题目5：68-43=？**\n\n这两道题根据**有限范围内**的加减法得出的结果是一样的，都是25，那我们是不是可以将题目5的减法变成题目4的加法呢？进一步，在**有限范围内**的加减法，是不是所有的减法都可以转变成加法，使用加法规则做减法运算呢？答案是肯定的，下面我们就来实现这一猜想。\n\n我们都知道，一个数减去一个数等于一个数加上一个负数，现在的问题是怎么把这个负数表示成一个正数。你有没有发现，题目4和题目5中的第二运算数57和43的关系，这两个数加起来57+43=100，正好是我们所规定的范围（一百以内的加减法），当然，如果按照一百以内不含一百的加法计算，这个结果应该是0。找到这个规律，我们来看是不是真的是这样呢？再来验证一下，73-27=73+73=46（请注意这都是都是100以内的计算）。好像是对的，为什么呢？因为100以内的加法，超过100（包括100）的数都要减去100，也就是：73-27=73+(73-100)=73+73-100，此时73+73-100正好是表达100以内的加法运算。好像有什么不对，谁能保证所有的运算都能像73+73-100这样，前两个数的和大于100呢，有没可能小于100呢？那肯定是有可能的，就拿这个例子来说，假设第一个数为x，要x+73<100，也就是x<100-73=27，也就是说x-27是一个负数，同时x+73-100也正好是一个负数，也说明这个两个数是相等的，但它还是用负数表示。综上，当y>0，x-y可以表示成x-y+100，也就是说-y用正数表示是100-y。\n\n### 3、正规化阶段\n\n经过前面一些简单的介绍，让我们来总结和归纳一下这个**在一定范围内**的加减法运算。\n\n#### 1、让数的表示更正规化\n\n上面提到过正数和负数的表示，以及如何将一个减法变成一个加法，然和将负数变成一个正数进行相加，且等到与加法相等的结果。现在我们将其进行更进一步的整理。\n\n表示一个一百以内的十进制数（不包括100，当然这里所说的数是指|x|<100的数），我们只需要两个数字进行组合即可得到，考虑到有正与负数，我们多加一位表示正负，这一位可以是+、-，比如+20、-60等。我也说过了，我现在是懒癌晚期，我只想学习正数加法，我天真的把所有数都变成正数，而且只是数，连正负号都是用数字，还能表示出这个数是正数还是负数，所以绝对值在100以内的数，只需要三位数表示，而且我们只用三个数表示。明确了目标，那开始吧：\n\n100以内的正数表示：最高位用0或1表示这是一个正数，后两位表示数的大小。比如：+20表示成020。\n绝对值100以内的负数的表示：最高位用8或9表示是负数，一般使用9，后两位表示数的大小，当然了为了能让负数变成正数加法，数的大小部分还是用100-数的大小部分。比如：-60表示成940（9是符号位，40=100-60）。\n\n\n#### 2、让计算方法更正规化\n\n将数的表示正规化后，我们用正规化后的数带入之前的题目中进行计算，注意符号位也当作数值进行运算，且只能保留最低三位数，看看能不能得到正确答案：\n\n**题目3：28+57=028+057=085**\n**题目4：68+57=068+057=125=025     (前面说过，0或1都表示正数，通常我们会把1变成0来表示)**\n**题目5：68-43=068+957=1025（超过了3个位，把最高为丢掉）=025**\n**题目6：28-57=028+943=971**\n**题目7：-66-88=934+912=1846（超过了3位，把最高位丢掉）=846=946(前面说过，8或9都表示负数，通常我们会把8变成9来表示)**\n\n题目3、4、5的结果都是正数，且结果和我们之前得到是一样的，题目6、7的结果是负数，题6值为100-71=29，所以结果是-29，也与我之前的结果一致，题7的值为-54，也是正确值。至此，我们就实现了绝对值在100以内的正负数加减法的正规化，全部简化为加法运算。\n\n至此，可以结束本文了，不过，我们现在不禁要问，为什么我们这样做可以得到与我们以前计算方法一致的结果呢？\n\n嗯，这个超出了小学数学知识的范畴了，我们之所以可以等到相同的结果，因为我们讨论的**在一定范围内**的带符号加法运算和**在一定范围内**的不带符号的加法运算都是一个阿贝尔群，还具有相同的单位元，而且表示的范围是符合双射关系。简单点说，我们现在讨论的整数加法是一个[阿贝尔群](https://zh.wikipedia.org/wiki/阿贝尔群)，满足（下面是个人的通俗说法，准确定义请参考相关专业书籍）：\n1、封闭性：通俗说就是加数与和属于同样的一个取值域，比如绝对值100以内的加法运算，如果大于等于100我们就减去100，得到的和还是在100以内，转换成不带正负号的加法，就是计算[0,999]内的正整数加法，加数与和都是在[0,999]区间；\n2、结合律：就是满足结合律，a+b+c=(a+b)+c=a+(b+c)，a、b、c是任意取值域的值;\n3、单位元：就是满足，a+e=a，e+a=a，a是任意取值域的值，e就是单位元,这里两种情况的单位元都是0；\n4、逆元：对取值域中的任意a，取值域中都存在b，使得a+b=单位元，b称为a的逆元。比如：绝对值100以内的加法运算，x的逆元就是-x，而在[0,999]无符号加法的x的逆元就是1000-x；\n5、交换律：对取值域中的任意a、b，都有a+b=b+a。\n\n这就是原因，估计很多小伙伴根本看不懂，只能说就当热闹看看，不要求弄懂。\n\n### 4、衍生阶段\n\n说了这么久，说好的计算机基础呢？为什么与计算机没半毛钱关系，鉴于此，我就简单说一下，计算机使用的是二进制，加法分为有符号和无符号整数加法。有符号的计算使用了类似上面的方法，正数最高位是0，负数最高位是1，后面的位表示值。\n\n用一个例子说明一下：\n用4位二进制表示一个数，最高位是符号位，还有3位用于表示数值，所以二进制数的取值范围是[-8,7],\n\n**题目8：2-4=0010+1100=1110=-2**\n\n\n最后强调一下，有些小伙伴说，一个数的补码很难求，其实，在二进制中的补码其实就是上面说的逆元，只要你理解了上面逆元的概念，是很好求的，比如十进制中减掉一个数，其实就是加上这个数的逆元。\n举几个例子熟练一下（用4位数表示，最高位是符号位），算法就是：x逆元=10……0-x（10……0总共有指定数的表示位数个0，用4位数表示，因此这里是4）：\n-1=1的逆元=10000-1=9999\n1=-1的逆元=10000-(-1)=10000+1=0001\n-48=48的逆元=10000-48=9952\n\n下面是一个二进制的例子：\n-4=0100的逆元=10000-0100=1100\n\n下面是一些计算中的补码（即逆元）的应用：\n20-48=0020+(10000-48)=0020+9952=9972=-28，同样的在二进制中，2-4=0010+(10000-0100)=0010+1100=1110=-2\n\n当然如果你学过计算机相关知识，还有一种求补码（逆元）的方法，原码（原数）取反加一即得补码（逆元），其中原码取反得到的数被成为反码。取反就是：指定的位数中的最大数-原码，什么意思？举个例子，用四位数表示下面的数的反码，由于是用四位数表示，所以四位数最大能表示的数是9999：\n48的反码=9999-48=9951\n根据：补码=反码+1得：\n48的补码=48的反码+1=9951+1=9952=-48\n同理，用二进制表示下面的数，四位最大二进制数能表示的最大数是1111：\n4的反码=1111-0100=1011\n4的补码=4的反码+1=1011+1=1100=-4\n\n\n### 小结\n\n\n在**有限范围内**的整数计算中，将负数使用补码（也就是逆元）参与运算，就能只使用加法实现有符号整数的加减法运算，这其中使用到的就是群的性质，尤其是逆元公式：x+y=e。在有符号整数计算中x+(-x)=0，而无符号整数计算有：x+(x的逆元)=0，所以我们将无符号整数中的逆元等效于有符号整数中的负数，以此达到只使用加法实现加减法运算的目的。本文还有一点没写清楚，那就是进制转换，后面几个例子中涉及十进制转二进制，等有时间再写。","slug":"别样的整数表示和运算","published":1,"updated":"2016-06-06T02:06:23.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw1i001gtkb983gluet6"},{"title":"初识Netfilter/iptables","date":"2016-03-25T12:49:54.000Z","_content":"\n\n### 一、什么是Netfilter/iptables？\n\n{% blockquote 维基百科 https://zh.wikipedia.org/wiki/Iptables%}\n\niptables是一个运行在用户空间的应用软件，通过控制Linux内核netfilter模块，来管理网络数据包的流动与转送。在大部分的Linux系统上面，iptables是使用/usr/sbin/iptables来操作，文件则放置在手册页底下，可以通过 man iptables 指令获取。通常iptables都需要内核层级的模块来配合运作，Xtables是主要在内核层级里面iptables API运作功能的模块。因相关动作上的需要，iptables的操作需要用到超级用户的权限。\n\n目前iptables系在2.4、2.6及3.0的内核底下运作，旧版的Linux内核（2.2）使用ipchains及ipwadm（Linux 2.0）来达成类似的功能，2014年1月19日起发行的新版Linux内核（3.13后）则使用nftables取而代之。\n\n{% endblockquote %}\n<!-- more -->\n以上就是中文维基百科上给出的定义，看完后，仍然不知所云，iptables的功能具体是什么？它与NetFilter是什么关系？\n\niptables是用来管理网络数据包的流动和转送的，也就是控制数据包的流向。我们都知道网络数据包在流经一台电脑时，数据包一般只有两种流向，一是目的地址是本机的：网卡驱动接收数据包->路由程序处理->本地协议栈处理->网卡驱动发送数据包；另一种流向是目的地址不是本机：网卡驱动接收数据包->路由程序处理数据包->将数据包转送到另一网卡->网卡驱动发送数据包。为了能灵活的管理数据包，Linux内核使用Netfilter模块在这些主要流向的路径的关键位置添加了一些钩子。如下图：\n\n{% asset_img Netfilter-packet-flow.png Netfilter-packet-flow %}\n\n上图过于复杂，为了便于理解，使用下面简化版的流程：\n\n{% asset_img iptables数据包流程.png iptables数据包流程 %}\n\n从上图可知，Netfilter在几个固定的位置设置了5个钩子：\n\n1. NF_INET_PRE_ROUTING:在网卡接收到数据包后，进入路由选择之前；\n2. NF_INET_LOCAL_IN:在路由判断目的地址是本机之后，交给本地协议栈处理之前；\n3. NF_INET_FORWARD:在路由判断目的地址不是本机之后，交给另一个网卡发送之前；\n4. NF_INET_LOCAL_OUT:在本地协议栈和应用程序处理之后，交给网卡发送之前；\n5. NF_INET_POST_ROUTING:在交给网卡发送之前，这是数据流中的最后一个钩子。\n\n既然有钩子，就可以定义与之对应的处理函数，这些函数也已经在Netfilter中定义好，并且与钩子绑定了。感觉所有的活，Netfilter都已经做好了，还有iptables什么事呢？\n\n其实不然，先来看看Netfilter的四个基本模块：\n1. conntrack模块：连接追踪模块\n2. Filter模块：过滤模块\n3. Nat模块：地址转换模块\n4. Mangle模块：数据包修改模块\n其中conntrack模块是基础核心模块，而其他几个模块是在此模块的基础上，维护一张全局表，以实现各模块相应的功能。为了灵活的管理数据包，iptables就可以调用Netfilter提供的接口想这些全局表中添加相应的控制条件和处理。以此，Netfilter其实就是提供一组系统调用以实现管理网络数据包流动和转送的框架。\n\n而iptables则是提供命令处理的用户空间应用程序，同时提供了一些扩展模块以加载到内核对数据包进行处理。Netfilter和iptables的关系如图：\n\n{% asset_img Netfilter与iptabales关系.png Netfilter与iptabales关系 %}\n\n为了方便处理用户命令的一组有序控制策略，iptables使用table、chain、rule来表示一条策略。其中table与Netfilter中的各模块中维护的全局表进行对应，chain与挂载点（即钩子）相对应，rule处理规则。iptables策略组成如图：\n\n{% asset_img iptables策略组成.png iptables策略组成 %}\n\n### 二、 iptables命令格式\n\niptables命令语法：\n``` bash\niptables [-t 表名] 命令 [条件匹配] [目标]\n```\n下面是更加详细的命令格式：\n``` bash\niptables [ -t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作或跳转] \n```\n\n#### 1.表名\n有四张表：filter(默认值)、NAT、mangle、raw。\n\n#### 2.命令选项\n|选项名\t\t\t|功能说明|\n|:-------------:|-------|\n|-A\t\t\t\t|在指定链的末尾添加（--append）一条新的规则|\n|-D\t\t\t\t|删除（--delete）指定链中的某一条规则，按规则序号或内容确定要删除的规则|\n|-I\t\t\t\t|在指定链中插入（--insert）一条新的规则，默认在链的开头插入|\n|-R\t\t\t\t|修改、替换（--replace）指定链中的一条规则，按规则序号或内容确定|\n|-L\t\t\t\t|列出（--list）指定链中的所有的规则进行查看，默认列出表中所有链的内容|\n|-F\t\t\t\t|清空（--flush）指定链中的所有规则，默认清空表中所有链的内容|\n|-N\t\t\t\t|新建（--new-chain）一条用户自己定义的规则链|\n|-X\t\t\t\t|删除指定表中用户自定义的规则链（--delete-chain）|\n|-P\t\t\t\t|设置指定链的默认策略（--policy）|\n|-n\t\t\t\t|用数字形式（--numeric）显示输出结果，若显示主机的 IP地址而不是主机名|\n|-P\t\t\t\t|设置指定链的默认策略（--policy）|\n|-v\t\t\t\t|查看规则列表时显示详细（--verbose）的信息|\n|-V\t\t\t\t|查看iptables命令工具的版本（--Version）信息|\n|-h\t\t\t\t|查看命令帮助信息（--help）|\n|--line-number\t|查看规则列表时，同时显示规则在链中的顺序号|\n\n#### 3.链名\n通过之前分析，主要有一下五条链：\n1. PREROUTING：与NF_INET_PRE_ROUTING钩子相对应，此链的处理时机也与NF_INET_PRE_ROUTING的时机相对应。\n2. INPUT：与NF_INET_LOCAL_IN钩子相对应，此链的处理时机也与NF_INET_LOCAL_IN的时机相对应。\n3. FORWARD：与NF_INET_LOCAL_OUT钩子相对应，此链的处理时机也与NF_INET_LOCAL_OUT的时机相对应。\n4. OUTPUT：与NF_INET_LOCAL_OUT钩子相对应，此链的处理时机也与NF_INET_LOCAL_OUT的时机相对应。\n5. POSTROUTING：与NF_INET_POST_ROUTING钩子相对应，此链的处理时机也与NF_INET_POST_ROUTING的时机相对应。\n\n#### 4.匹配条件\n\n##### 1）通用匹配\n|匹配参数\t|参数说明|\n|:---------:|-------|\n|-p\t\t\t|指定规则协议，如tcp, udp,icmp等，可以使用all来指定所有协议|\n|-s\t\t\t|指定数据包的源地址参数，可以使IP地址、网络地址、主机名|\n|-d\t\t\t|指定目的地址|\n|-i\t\t\t|输入接口|\n|-o\t\t\t|输出接口|\n\n##### 2）隐含匹配\n\n{% asset_img 隐含匹配.jpg 隐含匹配 %}\n\n##### 3）显式匹配\n\n{% asset_img 显式匹配.jpg 显式匹配 %}\n\n#### 5.目标动作或跳转\n|目标项           |功能说明|\n|:--------------:|-------|\n|ACCEPT\t|当信息包与具有ACCEPT目标的规则完全匹配时，会被接受（允许它前往目的地）|\n|DROP\t|当信息包与具有DROP目标的规则完全匹配时，会阻塞该信息包，并且不对它做进一步处理。该目标被指定为-j DROP|\n|REJECT\t|该目标的工作方式与DROP目标相同，但它比DROP好。和DROP不同，REJECT不会在服务器和客户机上留下死套接字。另外，REJECT将错误消息发回给信息包的发送方。该目标被指定为-j REJECT|\n|RETURN\t|在规则中设置的RETURN目标让与该规则匹配的信息包停止遍历包含该规则的链。如果链是如INPUT之类的主链，则使用该链的默认策略处理信息包。它被指定为-jump RETURN|\n|LOG\t|表示将包的有关信息记录入日志|\n|TOS\t|表示改写数据包的TOS值|\n\n### 三、  iptables应用\n\n1. 删除iptables现有规则\n``` bash\niptables –F\n```\n2. 查看iptables规则\n``` bash\niptables –L (iptables –L –v -n)\n```\n3. 增加一条规则到最后\n``` bash\niptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT\n```\n4. 添加一条规则到指定位置\n``` bash\niptables -I INPUT 2 -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT \n```\n5.  删除一条规则\n``` bash\niptabels -D INPUT 2 \n```\n6. 修改一条规则\n``` bash\niptables -R INPUT 3 -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT \n```\n7. 设置默认策略\n``` bash\niptables -P INPUT DROP \n```\n\n### 四、实战——使用iptables的源地址转发功能\n\n上面就是一些简单的介绍，下面模拟内网通过网关访问外网的一个简单例子来看看iptables的应用。\n\n#### 1.准备：\n1. 用虚拟机开启两台机器，分别命名为VM1（Virtual Machine 1）和VM2，VM2当作局域网内的机器，VM2当作网关，真实机器（即本机）LM（Local Machine）当作外网；\n2. 现在分别为VM1配置网络，ip地址是192.186.10.1，掩码是255.255.255.0；VM2配置两网卡，网络配置分别为：网卡1：ip地址是192.168.10.2，掩码是255.255.255.0，网卡2：ip地址是10.126.72.203，掩码是255.255.255.0；LM的网络配置是：ip地址是10.126.72.23，掩码是255.255.255.0。\n3. 在LM上搭建一个web服务器，配置网址www.LM.com。\n\n注意：怎么配置两台虚拟机在同一个局域网内，以及如何配置本机和虚拟机在同一网络中并相互访问呢？\n\n这里备注一下：下面的配置均是以VirtualBox为例。\n\n1. 配置虚拟机局域网\n\n{% asset_img 虚拟机网络配置1.png 虚拟机网络配置1 %}\n\n{% asset_img 虚拟机网络配置2.png 虚拟机网络配置2 %}\n\n2. 配置本机和虚拟机在同一网络中并相互访问\n{% asset_img 虚拟机网络配置3.png 虚拟机网络配置3 %}\n\n准备工作基本完成，如果顺利的话，最后将得到如下网络：\n\n{% asset_img 模拟网络.png 模拟网络 %}\n\n#### 2.实现VM1通过VM2访问LM\n\n由于LM的Web服务(www.lm.com)是本地服务并没有申请域名，还需要手动在VM1和VM2主机的/etc/hosts中添加如下一语句，否则无法对其进行域名解析：\n\n``` bash\n10.126.72.23     www.lm.com\n```\n\n毋庸置疑，开始VM1无法访问LM的Web服务（www.lm.com）。\n\n{% asset_img 访问LM服务1.png 访问LM服务1 %}\n\n下面将实现此访问。\n\n1. 首先开启内核转发的模块\n向/etc/sysctl.conf文件添加或这修改net.ipv4.ip_forward的值为1（即net.ipv4.ip_forward = 1）：\n``` bash\nsudo vim /etc/sysctl.conf\n```\n\n2. 设置VM1的默认网关为VM2，即192.168.10.2，\n\n{% asset_img 设置默认网关.png 设置默认网关 %}\n\n3. 在VM2上安装iptables及服务（此处系统为CentOS 7），并启动\n``` bash\nsudo yum -y install iptables\nsudo yum -y install iptables-services\nsudo systemctl start iptables.service \n```\n\n4. 配置iptables策略\n``` bash\nsudo iptables -F\nsudo iptalbes -t nat -F\nsudo iptables -t nat -A POSTROUTING -s 192.168.10.1/32 -j SNAT --to 10.126.72.203 \n```\n\n这就可以实现VM1访问LM上的服务了。\n\n{% asset_img 访问LM服务2.png 访问LM服务2 %}\n\n\n### 五、小结\n\n以上简单的介绍了iptable的基本概念和基本命令，以及命令的简单使用。这只是冰山一角，iptables还能实现如下功能：\n1. 建立一个基于有状态和无状态的包过滤规则的因特网防火墙。\n2. 部署高度可用的有状态和无状态防火墙集群。\n3. 当公网ip不够用时，可以进行ip伪装，属于NAT模块。\n4. 使用NAT来实现透明代理。\n5. 辅助内核网络模块中的tc和iproute2去构造一个复杂的QoS和路由策略。\n6. 做进一步处理比如比如更改IP包头中的TOS/DSCP/ECN参数。\n\n\n### 参考文章\n[Iptables入门教程](http://drops.wooyun.org/tips/1424)\n[Netfilter---框架的设计](http://blog.chinaunix.net/uid-20786208-id-3429074.html)\n[iptables防火墙原理详解](http://seanlook.com/2014/02/23/iptables-understand/)\n[iptables深入解析](http://blog.jobbole.com/?s=iptables%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90)\n[Linux内核工程导论——网络：Netfilter概览](http://blog.csdn.net/ljy1988123/article/details/50458044?utm_source=tuicool&utm_medium=referral)\n[Netfilter/iptables框架总结](http://vinllen.com/netfilteriptableskuang-jia-zong-jie/)\n","source":"_posts/初识Netfilter-iptables.md","raw":"title: 初识Netfilter/iptables\ntags:\n  - iptables\n  - Netfilter\n  - 防火墙\n  - 网络\ncategories:\n  - Linux防火墙\ndate: 2016-03-25 20:49:54\n---\n\n\n### 一、什么是Netfilter/iptables？\n\n{% blockquote 维基百科 https://zh.wikipedia.org/wiki/Iptables%}\n\niptables是一个运行在用户空间的应用软件，通过控制Linux内核netfilter模块，来管理网络数据包的流动与转送。在大部分的Linux系统上面，iptables是使用/usr/sbin/iptables来操作，文件则放置在手册页底下，可以通过 man iptables 指令获取。通常iptables都需要内核层级的模块来配合运作，Xtables是主要在内核层级里面iptables API运作功能的模块。因相关动作上的需要，iptables的操作需要用到超级用户的权限。\n\n目前iptables系在2.4、2.6及3.0的内核底下运作，旧版的Linux内核（2.2）使用ipchains及ipwadm（Linux 2.0）来达成类似的功能，2014年1月19日起发行的新版Linux内核（3.13后）则使用nftables取而代之。\n\n{% endblockquote %}\n<!-- more -->\n以上就是中文维基百科上给出的定义，看完后，仍然不知所云，iptables的功能具体是什么？它与NetFilter是什么关系？\n\niptables是用来管理网络数据包的流动和转送的，也就是控制数据包的流向。我们都知道网络数据包在流经一台电脑时，数据包一般只有两种流向，一是目的地址是本机的：网卡驱动接收数据包->路由程序处理->本地协议栈处理->网卡驱动发送数据包；另一种流向是目的地址不是本机：网卡驱动接收数据包->路由程序处理数据包->将数据包转送到另一网卡->网卡驱动发送数据包。为了能灵活的管理数据包，Linux内核使用Netfilter模块在这些主要流向的路径的关键位置添加了一些钩子。如下图：\n\n{% asset_img Netfilter-packet-flow.png Netfilter-packet-flow %}\n\n上图过于复杂，为了便于理解，使用下面简化版的流程：\n\n{% asset_img iptables数据包流程.png iptables数据包流程 %}\n\n从上图可知，Netfilter在几个固定的位置设置了5个钩子：\n\n1. NF_INET_PRE_ROUTING:在网卡接收到数据包后，进入路由选择之前；\n2. NF_INET_LOCAL_IN:在路由判断目的地址是本机之后，交给本地协议栈处理之前；\n3. NF_INET_FORWARD:在路由判断目的地址不是本机之后，交给另一个网卡发送之前；\n4. NF_INET_LOCAL_OUT:在本地协议栈和应用程序处理之后，交给网卡发送之前；\n5. NF_INET_POST_ROUTING:在交给网卡发送之前，这是数据流中的最后一个钩子。\n\n既然有钩子，就可以定义与之对应的处理函数，这些函数也已经在Netfilter中定义好，并且与钩子绑定了。感觉所有的活，Netfilter都已经做好了，还有iptables什么事呢？\n\n其实不然，先来看看Netfilter的四个基本模块：\n1. conntrack模块：连接追踪模块\n2. Filter模块：过滤模块\n3. Nat模块：地址转换模块\n4. Mangle模块：数据包修改模块\n其中conntrack模块是基础核心模块，而其他几个模块是在此模块的基础上，维护一张全局表，以实现各模块相应的功能。为了灵活的管理数据包，iptables就可以调用Netfilter提供的接口想这些全局表中添加相应的控制条件和处理。以此，Netfilter其实就是提供一组系统调用以实现管理网络数据包流动和转送的框架。\n\n而iptables则是提供命令处理的用户空间应用程序，同时提供了一些扩展模块以加载到内核对数据包进行处理。Netfilter和iptables的关系如图：\n\n{% asset_img Netfilter与iptabales关系.png Netfilter与iptabales关系 %}\n\n为了方便处理用户命令的一组有序控制策略，iptables使用table、chain、rule来表示一条策略。其中table与Netfilter中的各模块中维护的全局表进行对应，chain与挂载点（即钩子）相对应，rule处理规则。iptables策略组成如图：\n\n{% asset_img iptables策略组成.png iptables策略组成 %}\n\n### 二、 iptables命令格式\n\niptables命令语法：\n``` bash\niptables [-t 表名] 命令 [条件匹配] [目标]\n```\n下面是更加详细的命令格式：\n``` bash\niptables [ -t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作或跳转] \n```\n\n#### 1.表名\n有四张表：filter(默认值)、NAT、mangle、raw。\n\n#### 2.命令选项\n|选项名\t\t\t|功能说明|\n|:-------------:|-------|\n|-A\t\t\t\t|在指定链的末尾添加（--append）一条新的规则|\n|-D\t\t\t\t|删除（--delete）指定链中的某一条规则，按规则序号或内容确定要删除的规则|\n|-I\t\t\t\t|在指定链中插入（--insert）一条新的规则，默认在链的开头插入|\n|-R\t\t\t\t|修改、替换（--replace）指定链中的一条规则，按规则序号或内容确定|\n|-L\t\t\t\t|列出（--list）指定链中的所有的规则进行查看，默认列出表中所有链的内容|\n|-F\t\t\t\t|清空（--flush）指定链中的所有规则，默认清空表中所有链的内容|\n|-N\t\t\t\t|新建（--new-chain）一条用户自己定义的规则链|\n|-X\t\t\t\t|删除指定表中用户自定义的规则链（--delete-chain）|\n|-P\t\t\t\t|设置指定链的默认策略（--policy）|\n|-n\t\t\t\t|用数字形式（--numeric）显示输出结果，若显示主机的 IP地址而不是主机名|\n|-P\t\t\t\t|设置指定链的默认策略（--policy）|\n|-v\t\t\t\t|查看规则列表时显示详细（--verbose）的信息|\n|-V\t\t\t\t|查看iptables命令工具的版本（--Version）信息|\n|-h\t\t\t\t|查看命令帮助信息（--help）|\n|--line-number\t|查看规则列表时，同时显示规则在链中的顺序号|\n\n#### 3.链名\n通过之前分析，主要有一下五条链：\n1. PREROUTING：与NF_INET_PRE_ROUTING钩子相对应，此链的处理时机也与NF_INET_PRE_ROUTING的时机相对应。\n2. INPUT：与NF_INET_LOCAL_IN钩子相对应，此链的处理时机也与NF_INET_LOCAL_IN的时机相对应。\n3. FORWARD：与NF_INET_LOCAL_OUT钩子相对应，此链的处理时机也与NF_INET_LOCAL_OUT的时机相对应。\n4. OUTPUT：与NF_INET_LOCAL_OUT钩子相对应，此链的处理时机也与NF_INET_LOCAL_OUT的时机相对应。\n5. POSTROUTING：与NF_INET_POST_ROUTING钩子相对应，此链的处理时机也与NF_INET_POST_ROUTING的时机相对应。\n\n#### 4.匹配条件\n\n##### 1）通用匹配\n|匹配参数\t|参数说明|\n|:---------:|-------|\n|-p\t\t\t|指定规则协议，如tcp, udp,icmp等，可以使用all来指定所有协议|\n|-s\t\t\t|指定数据包的源地址参数，可以使IP地址、网络地址、主机名|\n|-d\t\t\t|指定目的地址|\n|-i\t\t\t|输入接口|\n|-o\t\t\t|输出接口|\n\n##### 2）隐含匹配\n\n{% asset_img 隐含匹配.jpg 隐含匹配 %}\n\n##### 3）显式匹配\n\n{% asset_img 显式匹配.jpg 显式匹配 %}\n\n#### 5.目标动作或跳转\n|目标项           |功能说明|\n|:--------------:|-------|\n|ACCEPT\t|当信息包与具有ACCEPT目标的规则完全匹配时，会被接受（允许它前往目的地）|\n|DROP\t|当信息包与具有DROP目标的规则完全匹配时，会阻塞该信息包，并且不对它做进一步处理。该目标被指定为-j DROP|\n|REJECT\t|该目标的工作方式与DROP目标相同，但它比DROP好。和DROP不同，REJECT不会在服务器和客户机上留下死套接字。另外，REJECT将错误消息发回给信息包的发送方。该目标被指定为-j REJECT|\n|RETURN\t|在规则中设置的RETURN目标让与该规则匹配的信息包停止遍历包含该规则的链。如果链是如INPUT之类的主链，则使用该链的默认策略处理信息包。它被指定为-jump RETURN|\n|LOG\t|表示将包的有关信息记录入日志|\n|TOS\t|表示改写数据包的TOS值|\n\n### 三、  iptables应用\n\n1. 删除iptables现有规则\n``` bash\niptables –F\n```\n2. 查看iptables规则\n``` bash\niptables –L (iptables –L –v -n)\n```\n3. 增加一条规则到最后\n``` bash\niptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT\n```\n4. 添加一条规则到指定位置\n``` bash\niptables -I INPUT 2 -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT \n```\n5.  删除一条规则\n``` bash\niptabels -D INPUT 2 \n```\n6. 修改一条规则\n``` bash\niptables -R INPUT 3 -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT \n```\n7. 设置默认策略\n``` bash\niptables -P INPUT DROP \n```\n\n### 四、实战——使用iptables的源地址转发功能\n\n上面就是一些简单的介绍，下面模拟内网通过网关访问外网的一个简单例子来看看iptables的应用。\n\n#### 1.准备：\n1. 用虚拟机开启两台机器，分别命名为VM1（Virtual Machine 1）和VM2，VM2当作局域网内的机器，VM2当作网关，真实机器（即本机）LM（Local Machine）当作外网；\n2. 现在分别为VM1配置网络，ip地址是192.186.10.1，掩码是255.255.255.0；VM2配置两网卡，网络配置分别为：网卡1：ip地址是192.168.10.2，掩码是255.255.255.0，网卡2：ip地址是10.126.72.203，掩码是255.255.255.0；LM的网络配置是：ip地址是10.126.72.23，掩码是255.255.255.0。\n3. 在LM上搭建一个web服务器，配置网址www.LM.com。\n\n注意：怎么配置两台虚拟机在同一个局域网内，以及如何配置本机和虚拟机在同一网络中并相互访问呢？\n\n这里备注一下：下面的配置均是以VirtualBox为例。\n\n1. 配置虚拟机局域网\n\n{% asset_img 虚拟机网络配置1.png 虚拟机网络配置1 %}\n\n{% asset_img 虚拟机网络配置2.png 虚拟机网络配置2 %}\n\n2. 配置本机和虚拟机在同一网络中并相互访问\n{% asset_img 虚拟机网络配置3.png 虚拟机网络配置3 %}\n\n准备工作基本完成，如果顺利的话，最后将得到如下网络：\n\n{% asset_img 模拟网络.png 模拟网络 %}\n\n#### 2.实现VM1通过VM2访问LM\n\n由于LM的Web服务(www.lm.com)是本地服务并没有申请域名，还需要手动在VM1和VM2主机的/etc/hosts中添加如下一语句，否则无法对其进行域名解析：\n\n``` bash\n10.126.72.23     www.lm.com\n```\n\n毋庸置疑，开始VM1无法访问LM的Web服务（www.lm.com）。\n\n{% asset_img 访问LM服务1.png 访问LM服务1 %}\n\n下面将实现此访问。\n\n1. 首先开启内核转发的模块\n向/etc/sysctl.conf文件添加或这修改net.ipv4.ip_forward的值为1（即net.ipv4.ip_forward = 1）：\n``` bash\nsudo vim /etc/sysctl.conf\n```\n\n2. 设置VM1的默认网关为VM2，即192.168.10.2，\n\n{% asset_img 设置默认网关.png 设置默认网关 %}\n\n3. 在VM2上安装iptables及服务（此处系统为CentOS 7），并启动\n``` bash\nsudo yum -y install iptables\nsudo yum -y install iptables-services\nsudo systemctl start iptables.service \n```\n\n4. 配置iptables策略\n``` bash\nsudo iptables -F\nsudo iptalbes -t nat -F\nsudo iptables -t nat -A POSTROUTING -s 192.168.10.1/32 -j SNAT --to 10.126.72.203 \n```\n\n这就可以实现VM1访问LM上的服务了。\n\n{% asset_img 访问LM服务2.png 访问LM服务2 %}\n\n\n### 五、小结\n\n以上简单的介绍了iptable的基本概念和基本命令，以及命令的简单使用。这只是冰山一角，iptables还能实现如下功能：\n1. 建立一个基于有状态和无状态的包过滤规则的因特网防火墙。\n2. 部署高度可用的有状态和无状态防火墙集群。\n3. 当公网ip不够用时，可以进行ip伪装，属于NAT模块。\n4. 使用NAT来实现透明代理。\n5. 辅助内核网络模块中的tc和iproute2去构造一个复杂的QoS和路由策略。\n6. 做进一步处理比如比如更改IP包头中的TOS/DSCP/ECN参数。\n\n\n### 参考文章\n[Iptables入门教程](http://drops.wooyun.org/tips/1424)\n[Netfilter---框架的设计](http://blog.chinaunix.net/uid-20786208-id-3429074.html)\n[iptables防火墙原理详解](http://seanlook.com/2014/02/23/iptables-understand/)\n[iptables深入解析](http://blog.jobbole.com/?s=iptables%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90)\n[Linux内核工程导论——网络：Netfilter概览](http://blog.csdn.net/ljy1988123/article/details/50458044?utm_source=tuicool&utm_medium=referral)\n[Netfilter/iptables框架总结](http://vinllen.com/netfilteriptableskuang-jia-zong-jie/)\n","slug":"初识Netfilter-iptables","published":1,"updated":"2016-03-25T12:49:54.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw1m001ktkb9eqzkx297"},{"title":"信息编码随想","date":"2015-03-11T16:45:55.000Z","_content":"\n\n先聊一聊有趣的网络语。下面内容来自百度百科的词条“流行用语”。\n支持不叫支持，叫——顶。\n有钱人不叫有钱人，叫——土豪。\n东西不叫东西，叫——东东。\n倒霉不叫倒霉，叫——衰。\nJJWW：唧唧歪歪，指人说话的样子。\nSJB：神经病。\nPMP：拍马屁。\nMPJ：马屁精。\nFB：腐败，多戏称聚餐\nXPP：夏骗骗，指学术造假者。\n1414：意思意思。\n3166： 撒由那拉，再见。(日语)\n555： wuwu,呜呜呜(哭) 。\n7456： 气死我咯。\n748： 去死吧。\n8137： 不要生气。\n84： 不是。\n848： 不是吧。\n886： 拜拜喽！\n<!--more-->\n上面这些流行语都是很容易知道它代表的含义，但是下面这几个就没那么显而易见了。\n253，874，999这三个数数字的含义可能就没那么明显了，它们的含义是：\n253： 拜礼作揖，源自mop贴图第253号，一个人在拜礼作揖。\n874： 掌嘴，源自猫扑网站的贴图第874号，动态效果，画的是一个女子正在用扫把抽一个男子的嘴巴。\n999：极度惊讶或极度佩服，源自猫扑网站的贴图第999号，用于表达极度惊讶或极度佩服。\n\n在这些流行语当中，有一些词赋予了新的含义，有些用到了谐音，有些用到了首字母拼音缩写，还有些是在论坛出现的楼层。而且包涵汉子、字母和数字，传达这各种信息，也就是说信息才是主体，汉字、字母和数字都是载体，当然了声音（语言）和肢体动作等也都是载体。明确信息才是主体，其它都是载体这一点相当重要。一切的交流都是信息的传递，而传递的形式是次要的信息才是我们要表达的。既然表现形式都是花架子，那么也就是说所有的表现形式都应该是等价的，只是有些表现形式表示出来不是那么好理解罢了（比如最后三个数字）。下面让我们来看看人们都有哪些信息交流的方式：\n《中国合伙人》这部电影中有这么一个桥段，“土鳖”成东青喜欢上了苏梅，为了博得她的芳心，一个晚上，成东青爬上苏梅的必经之路的路灯上将一破盆至于路灯之下，使在地面出现I ❤ U的字样，最后使用各种卑鄙的手段，终于征服的苏梅。将我喜欢你用这I ❤ U字符表达出来了。现在换一种情境，如果成东青与苏梅在高中就认识了，并且成东青暗恋这苏梅，但是他俩不早同一个城市上大学，成东青该怎么表达出爱意呢？当然是选择电话，将我喜欢你用这声音表达出。如果不巧那个时候电话还没有普及，成东青该怎么办？写信是一个不错的选择，但是如果你足够富裕，电报其实是更好的选择，因为它比信件更实时。那这个时候信息是怎么传达的呢？那就应该是：**<font color=#FF00FF size=5> ·· </font><font color=#00BFFF size=5> ·-··</font><font color=#FF1493 size=5> ---</font><font color=#8470FF size=5> ···-</font><font color=#FF0000 size=5> ·</font><font color=#1E90FF size=5> ··-</font>**，这就是I Love U的[摩尔斯电码](https://zh.wikipedia.org/wiki/摩尔斯电码)。\n\n现在让我们来看一下摩尔斯电码到底是怎么进行信息传递的，下面就是摩尔斯电码与字母的对应表：\n{% asset_img  图一.png 图一 %}\n有两种“符号”用来表示字符：点（.）和划（-），或叫“滴”（Dit）和“答”（Dah）。划一般是三个点的长度；点划之间的间隔是一个点的长度；字符之间的间隔是三个点的长度；单词之间的间隔是七个点的长度。通过这个规则，将要发送的字符的摩尔斯电码组织起来，我们称这叫做编码，使用电报机发送出去就行了。接收方对其进行反向操作恢复出原来的字符，这就被成为解码，然而这个操作似乎比编码要困难的些，我们要对摩尔斯电码进行扫描对比，很费力，那有没有更好的办法呢？答案是肯定的，摩尔斯电码遵循一个很重要的信息学编码原则，那就是：常用字母笔画少，生僻字母笔画多，比如下面这个故事：\n{% asset_img 图二.png 图二 %}\n这些生僻字的笔画都是很多的。而且我们发现摩尔斯电码其实是点与划的一个组合，有一种太极生两仪，两仪生四象，四象生八卦的味道，先是用一个点和一个划表示英文单词中使用最多的两个‘E’和‘T’，然后以一个点为基础，如果在点的后面加一个点，代表‘I’，如果加一个划，就代表‘A’。同理在划后面分别加一个点和者一个划，分别代表‘N’和‘M’，这四个字母就是使用频率次高的。如下图：\n{% asset_img 图三.png 图三 %}\n以此类推以两笔的摩尔斯电码作为基础推出三笔的摩尔斯电码，以三笔的摩尔斯电码作为基础推出四笔的摩尔斯电码，如下图：\n{% asset_img 图四.png 图四 %}\n{% asset_img 图五.png 图五 %}\n由于英文字符只有26个，而像刚才我们那样推导可以得到30个字符，所以其中有四个重音字母。从而我们可以得到这张图：·-··这个摩尔斯电码对应的字母就是L\n{% asset_img 图六.png 图六 %}\n\n然后根据每个摩尔斯电码，从左往右读，如果是点，就沿着图向上找（以红色五角星为起点），如果是划，就沿着图乡下找，直到代表一个字符的摩尔斯电码结束，此时图中对应的字母就是该摩尔斯电码对应的字母，比如：·-··这个摩尔斯电码，点向上找，横向下找，点向上找，点乡下找，图中蓝线路劲，对应的是L。按这种找发，最多找4次就能确定一个字母，而且出现频率高的字母都在前面，这样就极大减少了查找次数。如果不按找这张表查，而是根据字母对应的摩尔斯电码反查，查找的平均次数是：（1+2+3+……+26）÷26=13.5次。\n\n \n\n现在，我们已经知道了对信息的编码和解码，那么这些电码通过电报机是怎么传递的呢？明天我们就来看一下电报机的工作原理。回顾一下今天的类容，今天没有提到电脑的任何东西，而是全是在讨论信息以及信息的载体——包括汉子、字母、数字、声音、图像、肢体语言等，得出了载体都是信息的一种表达，而且各个载体对信息的表达是等价的，而且各有表达的优势，哪种更适合计算机呢？这个留到后面讨论。最后分析了一下摩尔斯电码的编码和解码过程，这其实就是人跟电报机的一种信息交流的过程。那么，人和计算机的信息交流会是怎么样的呢？这些都会在后面进行讨论。","source":"_posts/信息编码随想.md","raw":"title: 信息编码随想\ntags:\n  - 信息编码\ncategories:\n  - 信息编码\ndate: 2015-03-12 00:45:55\n---\n\n\n先聊一聊有趣的网络语。下面内容来自百度百科的词条“流行用语”。\n支持不叫支持，叫——顶。\n有钱人不叫有钱人，叫——土豪。\n东西不叫东西，叫——东东。\n倒霉不叫倒霉，叫——衰。\nJJWW：唧唧歪歪，指人说话的样子。\nSJB：神经病。\nPMP：拍马屁。\nMPJ：马屁精。\nFB：腐败，多戏称聚餐\nXPP：夏骗骗，指学术造假者。\n1414：意思意思。\n3166： 撒由那拉，再见。(日语)\n555： wuwu,呜呜呜(哭) 。\n7456： 气死我咯。\n748： 去死吧。\n8137： 不要生气。\n84： 不是。\n848： 不是吧。\n886： 拜拜喽！\n<!--more-->\n上面这些流行语都是很容易知道它代表的含义，但是下面这几个就没那么显而易见了。\n253，874，999这三个数数字的含义可能就没那么明显了，它们的含义是：\n253： 拜礼作揖，源自mop贴图第253号，一个人在拜礼作揖。\n874： 掌嘴，源自猫扑网站的贴图第874号，动态效果，画的是一个女子正在用扫把抽一个男子的嘴巴。\n999：极度惊讶或极度佩服，源自猫扑网站的贴图第999号，用于表达极度惊讶或极度佩服。\n\n在这些流行语当中，有一些词赋予了新的含义，有些用到了谐音，有些用到了首字母拼音缩写，还有些是在论坛出现的楼层。而且包涵汉子、字母和数字，传达这各种信息，也就是说信息才是主体，汉字、字母和数字都是载体，当然了声音（语言）和肢体动作等也都是载体。明确信息才是主体，其它都是载体这一点相当重要。一切的交流都是信息的传递，而传递的形式是次要的信息才是我们要表达的。既然表现形式都是花架子，那么也就是说所有的表现形式都应该是等价的，只是有些表现形式表示出来不是那么好理解罢了（比如最后三个数字）。下面让我们来看看人们都有哪些信息交流的方式：\n《中国合伙人》这部电影中有这么一个桥段，“土鳖”成东青喜欢上了苏梅，为了博得她的芳心，一个晚上，成东青爬上苏梅的必经之路的路灯上将一破盆至于路灯之下，使在地面出现I ❤ U的字样，最后使用各种卑鄙的手段，终于征服的苏梅。将我喜欢你用这I ❤ U字符表达出来了。现在换一种情境，如果成东青与苏梅在高中就认识了，并且成东青暗恋这苏梅，但是他俩不早同一个城市上大学，成东青该怎么表达出爱意呢？当然是选择电话，将我喜欢你用这声音表达出。如果不巧那个时候电话还没有普及，成东青该怎么办？写信是一个不错的选择，但是如果你足够富裕，电报其实是更好的选择，因为它比信件更实时。那这个时候信息是怎么传达的呢？那就应该是：**<font color=#FF00FF size=5> ·· </font><font color=#00BFFF size=5> ·-··</font><font color=#FF1493 size=5> ---</font><font color=#8470FF size=5> ···-</font><font color=#FF0000 size=5> ·</font><font color=#1E90FF size=5> ··-</font>**，这就是I Love U的[摩尔斯电码](https://zh.wikipedia.org/wiki/摩尔斯电码)。\n\n现在让我们来看一下摩尔斯电码到底是怎么进行信息传递的，下面就是摩尔斯电码与字母的对应表：\n{% asset_img  图一.png 图一 %}\n有两种“符号”用来表示字符：点（.）和划（-），或叫“滴”（Dit）和“答”（Dah）。划一般是三个点的长度；点划之间的间隔是一个点的长度；字符之间的间隔是三个点的长度；单词之间的间隔是七个点的长度。通过这个规则，将要发送的字符的摩尔斯电码组织起来，我们称这叫做编码，使用电报机发送出去就行了。接收方对其进行反向操作恢复出原来的字符，这就被成为解码，然而这个操作似乎比编码要困难的些，我们要对摩尔斯电码进行扫描对比，很费力，那有没有更好的办法呢？答案是肯定的，摩尔斯电码遵循一个很重要的信息学编码原则，那就是：常用字母笔画少，生僻字母笔画多，比如下面这个故事：\n{% asset_img 图二.png 图二 %}\n这些生僻字的笔画都是很多的。而且我们发现摩尔斯电码其实是点与划的一个组合，有一种太极生两仪，两仪生四象，四象生八卦的味道，先是用一个点和一个划表示英文单词中使用最多的两个‘E’和‘T’，然后以一个点为基础，如果在点的后面加一个点，代表‘I’，如果加一个划，就代表‘A’。同理在划后面分别加一个点和者一个划，分别代表‘N’和‘M’，这四个字母就是使用频率次高的。如下图：\n{% asset_img 图三.png 图三 %}\n以此类推以两笔的摩尔斯电码作为基础推出三笔的摩尔斯电码，以三笔的摩尔斯电码作为基础推出四笔的摩尔斯电码，如下图：\n{% asset_img 图四.png 图四 %}\n{% asset_img 图五.png 图五 %}\n由于英文字符只有26个，而像刚才我们那样推导可以得到30个字符，所以其中有四个重音字母。从而我们可以得到这张图：·-··这个摩尔斯电码对应的字母就是L\n{% asset_img 图六.png 图六 %}\n\n然后根据每个摩尔斯电码，从左往右读，如果是点，就沿着图向上找（以红色五角星为起点），如果是划，就沿着图乡下找，直到代表一个字符的摩尔斯电码结束，此时图中对应的字母就是该摩尔斯电码对应的字母，比如：·-··这个摩尔斯电码，点向上找，横向下找，点向上找，点乡下找，图中蓝线路劲，对应的是L。按这种找发，最多找4次就能确定一个字母，而且出现频率高的字母都在前面，这样就极大减少了查找次数。如果不按找这张表查，而是根据字母对应的摩尔斯电码反查，查找的平均次数是：（1+2+3+……+26）÷26=13.5次。\n\n \n\n现在，我们已经知道了对信息的编码和解码，那么这些电码通过电报机是怎么传递的呢？明天我们就来看一下电报机的工作原理。回顾一下今天的类容，今天没有提到电脑的任何东西，而是全是在讨论信息以及信息的载体——包括汉子、字母、数字、声音、图像、肢体语言等，得出了载体都是信息的一种表达，而且各个载体对信息的表达是等价的，而且各有表达的优势，哪种更适合计算机呢？这个留到后面讨论。最后分析了一下摩尔斯电码的编码和解码过程，这其实就是人跟电报机的一种信息交流的过程。那么，人和计算机的信息交流会是怎么样的呢？这些都会在后面进行讨论。","slug":"信息编码随想","published":1,"updated":"2016-07-15T09:34:05.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw30001vtkb9x9nuw5zf"},{"title":"也说“当你输入一个网址，实际会发生什么?”","date":"2015-11-01T12:02:55.000Z","_content":"\n趁着感冒好了，赶紧写个开篇，激励自己多写些东西。\n\n问题来源：http://www.zhihu.com/question/34873227\n\n最近也在各家公司面试，其中少不了会问到网络这一块的知识，借此机会整理一下网络知识。\n\n一、准备工作：\n\n使用到的工具有：\n\nDig for windows: [http://download.csdn.net/download/tuberose1605/5818117](http://download.csdn.net/download/tuberose1605/5818117)\n\nDig程序安装步骤：\n\n1. 将压缩包解压至 C:\\dig ，复制 resolv.conf 至 C:\\WINDOWS\\system32\\drivers\\etc\n\n2. 添加环境变量\n\n   xp系统 我的电脑右键 -- 属性 -- 高级 -- 环境变量 -- 用户变量\n   win7系统 计算机右键 -- 属性 -- 高级系统设置 -- 环境变量 -- 用户变量\n   如果存在 PATH 变量，双击进入编辑模式，在变量值后面添加 ;c:\\dig (;前面没有空格)\n   如果不存在，则新建变量 变量名：PATH 变量值：c:\\dig\n   进入命令提示符，输入 dig 看是否安装成功。\n\nWireshark: [https://www.wireshark.org/#download](https://www.wireshark.org/#download)\nWireshark程序的安装没什么好说的，一般都是一路next就行了。\n<!--more-->\n二、开始探索之旅：\n\n以在chrome浏览器的地址栏输入：www.baidu.com为例来看看这个过程。\n\n1．先打开wireshark：\n{% asset_img 图一.png 图一 %} \n开始之后的界面如下图所示：\n{% asset_img 图二.png 图二 %}\n现在在chrome浏览器中输入www.baidu.com，看看抓到的包是什么？\n\n在输入www.baidu.com之前先单击重新开始抓包，然后在chrome的地址栏中输入www.baidu.com当页面加载完成之后，单击停止抓包，截图如下：\n{% asset_img 图三.png 图三 %}\n从图中可以看出，访问www.baidu.com时，首先要进行的是把域名变成ip地址，也就是说电脑是通过ip找到要访问的电脑的，要找到域名对应的ip就要使用到DNS协议，今天重点看一下DNS的工作原理：\n\n（一）DNS的工作原理\n\n导航的第一步是通过访问的域名找出其IP地址。DNS查找过程如下：\n\n1. 浏览器缓存 – 浏览器会缓存DNS记录一段时间。 有趣的是，操作系统没有告诉浏览器储存DNS记录的时间，这样不同浏览器会储存个自固定的一个时间（2分钟到30分钟不等）。\n\n2. 系统缓存 – 如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用（windows里是gethostbyname）。这样便可获得系统缓存中的记录。\n\n3. 路由器缓存 – 接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存。\n\n4. ISP DNS 缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。\n\n5. 递归搜索 – 你的ISP的DNS服务器从跟域名服务器开始进行递归搜索，从com.顶级域名服务器到baidu.com.的域名服务器。一般DNS服务器的缓存中会有com.域名服务器中的域名，所以到顶级服务器的匹配过程不是那么必要了。\n\n这里简单的介绍一下系统缓存，缓存就是指不用你每次去访问www.baidu.com时，都向网络发一条DNS数据包，系统会在你第一次访问www.baidu.com时，会将www.baidu.com对应的ip地址保存在本机，下次再访问www.baidu.com时，就能直接得到ip地址了。要查看本机的dns缓存，使用使用cmd，输入ipconfig /displaydns命令就可以看到缓存了，比如百度的：\n{% asset_img 图四.png 图四 %}\n它对应的是一条CNAME记录。而formi.baidu.com对应的是两条A记录：\n{% asset_img 图五.png 图五 %}\nA记录是主机名或者域名所及对应的ip的一条记录，而CNAME记录是A记录的别名的一条记录。也就是说www.baidu.com只是www.a.shifen.com的一个别名。上面是显示系统已经缓存的dns。如果要抓包的话，有的时候由于缓存还在存活期，此时访问www.baidu.com时，就不会发出DNS包，这个时候你可选择等待一段时间再进行抓包，这当然是比较愚蠢的做法，此时你可以使用ipconfig /flushdns命令来清除这些缓存记录。\n\n接着分析发送的第一个DNS包：\n{% asset_img 图六.png 图六 %}\n这里面有两个ip地址，一个是Source：192.168.1.105和Destination：223.5.5.5，这两个ip代表了什么呢？我们想要知道www.baidu.com的ip地址，但是本地又没有www.baidu.com对应的ip地址，此时我们要怎么知道这个ip地址呢？自己不知道那就去问别人咯，那该问谁呢，谁会知道这ip呢？这是你在设置网络的时候填写的，在网络连接的属性中可以设置，如图：\n{% asset_img 图七.png 图七 %}\n看到了吗，223.5.5.5，你也可以使用cmd中的ipconfig /all命令查看这些信息，如图：\n{% asset_img 图八.png 图八 %}\n图中圈起来的是比较重要的信息。当然你也可以不用这样设置，而是使用上面的自动获得DNS服务器地址，而不是手动设置，你依然可以使用上面的命令ipconfig /all来查看这些信息。现在我们知道了Source：192.168.1.105是本机的局域网ip地址，而Destination：223.5.5.5是阿里的免费DNS服务器的公有ip地址。它是浙江省杭州市电信的一个ip地址。注意了：Source是一个局域网的ip地址，Destination是一个公有ip地址，记住这个是有区别的，这个留着以后解释，为了方便理解，就当它们没有区别，如果你想知道你的公有ip地址，可以在百度中输入ip即可以搜索到，如图：\n{% asset_img 图九.png 图九 %}\n{% asset_img 图十.png 图十 %}\n理解了这些，接着往下看，192.168.1.105问223.5.5.5：你知道www.baidu.com的ip是多少吗？这个时候233.5.5.5它会怎么办呢？如果233.5.5.5已经有这条记录的缓存，就告诉192.168.1.105这条记录的ip（这个过程比较复杂，这里省略，以后详解），233.5.5.5这就是使用了ISP DNS 缓存，如果233.5.5.5也没有缓存这条记录怎么办？这个时候就要向其它服务器要了，那它又向谁要呢？这个时候就要它就会向DNS根服务器要，在进入到DNS服务器查询前，先来了解一下域名：一般来说域名都是xxx.xxx.xxx，比如：www.baidu.com就是这样的一个，所谓域名，就是用来确定域的，而且域与域是使用“.”分割，而且越后面的域越高，范围越大，如：\n{% asset_img 图十一.png 图十一 %}\nDNS有两种查询解析方式：\n\n一、192.168.1.105询问223.5.5.5，223.5.5.5将DNS根服务器ip地址列表返回给192.168.1.105，192.168.1.105再询问DNS根服务器，DNS根服务器收到查询后，查询出顶级域是com.的服务器的ip列表返回给192.168.1.105，接着192.168.1.105询问com.域服务器，com.域服务器将baidu.com.域服务器的ip列表返回给192.168.1.105，192.168.1.105再去询问baidu.com.域服务器，如果有该记录，就将相应的ip返回给192.168.1.105。\n\n二、第二种方式的是192.168.1.105询问223.5.5.5，223.5.5.5询问根服务器，根服务器询问com.服务器，com.服务器询问baidu.com.服务，baidu.com.服务返回给com.服务器，com.服务器返回给根服务器，根服务器返回个223.5.5.5，233.5.5.5返回给192.168.1.105。\n\n下面使用dig来看看方式一这个过程，如图：\n{% asset_img 图十二.png 图十二 %}\n{% asset_img 图十三.png 图十三 %}\n附上一张因特网域名空间：\n{% asset_img 图十四.png 图十四 %}\nDNS的工作过程大致就是这样，不过这并不是完整过程。最后来看一看DNS数据包，DNS查询和应答报文格式：\n{% asset_img 图十五.png 图十五 %}\n标识（2字节）：这个字段是一对DNS查询和应答唯一标识，其实就是A向B问了一个问题用类似A1这样的id表示这个问题，等B有时间处理了这个问题告诉A时，就告诉A我现在回答的是A1这个问题。\n\n标志（2字节）：这部分非常重要，是通信方式和反馈状态的一些标志位。再借个图：\n{% asset_img 图十六.png 图十六 %}\nQR(1比特）：查询/响应的标志位，1为响应，0为查询。\n\nopcode（4比特）：定义查询或响应的类型（若为0则表示是标准的，若为1则是反向的，若为2则是服务器状态请求）。\n\nAA（1比特）：授权回答的标志位。该位在响应报文中有效，1表示名字服务器是权限服务器\n\nTC（1比特）：截断标志位。1表示响应已超过512字节并已被截断，仅当DNS报文使用UDP服务器是使用，因为UDP数据报有长度限制，所以过长的DNS报文将被阶段。\n\nRD（1比特）：该位为1表示客户端希望得到递归回答（这就是上文提到的方式二），0表示迭代查询（即上文提到的方式一）\n\nRA（1比特）：只能在响应报文中置为1，表示可以得到递归响应。\n\nzero（3比特）：不说也知道都是0了，保留字段。\n\nrcode（4比特）：返回码，表示响应的差错状态，通常为0和3，各取值含义如下：\n\n\t0          无差错\n    1          格式差错\n    2          问题在域名服务器上\n    3          域不存在\n    4          查询类型不支持\n    5          在管理上被禁止\n\t6          -- 15 保留\n\n接下来的4个字段分别表示DNS报文最后4个字段的资源记录数目。对查询报文而言，它一般包含1个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。应答报文的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。\n\n查询问题的格式：\n{% asset_img 图十七.png 图十七 %}\n查询名部分长度不定，一般为要查询的域名（也会有IP的时候，即反向查询）。此部分由一个或者多个标示符序列组成，每个标示符以首字节数的计数值来说明该标示符长度，每个名字以0结束。计数字节数必须是0~63之间。该字段无需填充字节。还是借个例子来说明更直观些，查询名为www.baidu.com.\n{% asset_img 图十八.png 图十八 %}\n查询类型有：类型A，值为1，表示获取目标主机的IP地址，类型CNAME，值为5，表示获得目标主机的别名，类型PTR，值12，表示反向查询（在windows下有个命令nslookup IP，查询出域名）。\n\n查询类通常是1，表示获取因特网地址（即IP地址）。\n\n应答字段、授权字段和额外信息字段都使用资源记录（Resource Record，RR）格式，如图：\n{% asset_img 图十九.png 图十九 %}\n域名字段（不定长或2字节）：记录中资源数据对应的名字，它的格式和查询名字段格式相同。当报文中域名重复出现时，就需要使用2字节的偏移指针来替换。例如，在资源记录中，域名通常是查询问题部分的域名的重复，就需要用指针指向查询问题部分的域名。关于指针怎么用，TCP/IP详解里面有，即2字节的指针，最前面的两个高位是11，用于识别指针。其他14位从报文开始处计数（从0开始），指出该报文中的相应字节数。注意，DNS报文的第一个字节是字节0，第二个报文是字节1。一般响应报文中，资源部分的域名都是指针C00C(1100000000001100)，刚好指向查询问题部分的查询名。\n\n类型（2字节）、类（2字节）：含义与查询问题部分的类型和类相同。\n\n生存时间（4字节）：该字段表示资源记录的生命周期（以秒为单位），一般用于当地址解析程序取出资源记录后决定保存及使用缓存数据的时间。\n\n资源数据长度（2字节）：取决于类型字段，对于类型A而言，资源数据是32位的IPv4地址，而资源数据长度则为4（以字节为单位）\n\n资源数据：该字段是可变长字段，表示按查询段要求返回的相关资源记录的数据。\n\n结合wireshark抓到的包来看看：\n{% asset_img 图二十.png 图二十 %}\n这两条DNS报文就是一对，圈起来的就是标识：0X4d51，先看查询报文：\n{% asset_img 图二十一.png 图二十一 %}\n再来看应答报文：\n{% asset_img 图二十二.png 图二十二 %}\n{% asset_img 图二十三.png 图二十三 %}\n未完待续……\n\n","source":"_posts/也说“当你输入一个网址，实际会发生什么-”.md","raw":"title: 也说“当你输入一个网址，实际会发生什么?”\ntags:\n  - 计算机网络\ncategories:\n  - 计算机网络\ndate: 2015-11-01 20:02:55\n---\n\n趁着感冒好了，赶紧写个开篇，激励自己多写些东西。\n\n问题来源：http://www.zhihu.com/question/34873227\n\n最近也在各家公司面试，其中少不了会问到网络这一块的知识，借此机会整理一下网络知识。\n\n一、准备工作：\n\n使用到的工具有：\n\nDig for windows: [http://download.csdn.net/download/tuberose1605/5818117](http://download.csdn.net/download/tuberose1605/5818117)\n\nDig程序安装步骤：\n\n1. 将压缩包解压至 C:\\dig ，复制 resolv.conf 至 C:\\WINDOWS\\system32\\drivers\\etc\n\n2. 添加环境变量\n\n   xp系统 我的电脑右键 -- 属性 -- 高级 -- 环境变量 -- 用户变量\n   win7系统 计算机右键 -- 属性 -- 高级系统设置 -- 环境变量 -- 用户变量\n   如果存在 PATH 变量，双击进入编辑模式，在变量值后面添加 ;c:\\dig (;前面没有空格)\n   如果不存在，则新建变量 变量名：PATH 变量值：c:\\dig\n   进入命令提示符，输入 dig 看是否安装成功。\n\nWireshark: [https://www.wireshark.org/#download](https://www.wireshark.org/#download)\nWireshark程序的安装没什么好说的，一般都是一路next就行了。\n<!--more-->\n二、开始探索之旅：\n\n以在chrome浏览器的地址栏输入：www.baidu.com为例来看看这个过程。\n\n1．先打开wireshark：\n{% asset_img 图一.png 图一 %} \n开始之后的界面如下图所示：\n{% asset_img 图二.png 图二 %}\n现在在chrome浏览器中输入www.baidu.com，看看抓到的包是什么？\n\n在输入www.baidu.com之前先单击重新开始抓包，然后在chrome的地址栏中输入www.baidu.com当页面加载完成之后，单击停止抓包，截图如下：\n{% asset_img 图三.png 图三 %}\n从图中可以看出，访问www.baidu.com时，首先要进行的是把域名变成ip地址，也就是说电脑是通过ip找到要访问的电脑的，要找到域名对应的ip就要使用到DNS协议，今天重点看一下DNS的工作原理：\n\n（一）DNS的工作原理\n\n导航的第一步是通过访问的域名找出其IP地址。DNS查找过程如下：\n\n1. 浏览器缓存 – 浏览器会缓存DNS记录一段时间。 有趣的是，操作系统没有告诉浏览器储存DNS记录的时间，这样不同浏览器会储存个自固定的一个时间（2分钟到30分钟不等）。\n\n2. 系统缓存 – 如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用（windows里是gethostbyname）。这样便可获得系统缓存中的记录。\n\n3. 路由器缓存 – 接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存。\n\n4. ISP DNS 缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。\n\n5. 递归搜索 – 你的ISP的DNS服务器从跟域名服务器开始进行递归搜索，从com.顶级域名服务器到baidu.com.的域名服务器。一般DNS服务器的缓存中会有com.域名服务器中的域名，所以到顶级服务器的匹配过程不是那么必要了。\n\n这里简单的介绍一下系统缓存，缓存就是指不用你每次去访问www.baidu.com时，都向网络发一条DNS数据包，系统会在你第一次访问www.baidu.com时，会将www.baidu.com对应的ip地址保存在本机，下次再访问www.baidu.com时，就能直接得到ip地址了。要查看本机的dns缓存，使用使用cmd，输入ipconfig /displaydns命令就可以看到缓存了，比如百度的：\n{% asset_img 图四.png 图四 %}\n它对应的是一条CNAME记录。而formi.baidu.com对应的是两条A记录：\n{% asset_img 图五.png 图五 %}\nA记录是主机名或者域名所及对应的ip的一条记录，而CNAME记录是A记录的别名的一条记录。也就是说www.baidu.com只是www.a.shifen.com的一个别名。上面是显示系统已经缓存的dns。如果要抓包的话，有的时候由于缓存还在存活期，此时访问www.baidu.com时，就不会发出DNS包，这个时候你可选择等待一段时间再进行抓包，这当然是比较愚蠢的做法，此时你可以使用ipconfig /flushdns命令来清除这些缓存记录。\n\n接着分析发送的第一个DNS包：\n{% asset_img 图六.png 图六 %}\n这里面有两个ip地址，一个是Source：192.168.1.105和Destination：223.5.5.5，这两个ip代表了什么呢？我们想要知道www.baidu.com的ip地址，但是本地又没有www.baidu.com对应的ip地址，此时我们要怎么知道这个ip地址呢？自己不知道那就去问别人咯，那该问谁呢，谁会知道这ip呢？这是你在设置网络的时候填写的，在网络连接的属性中可以设置，如图：\n{% asset_img 图七.png 图七 %}\n看到了吗，223.5.5.5，你也可以使用cmd中的ipconfig /all命令查看这些信息，如图：\n{% asset_img 图八.png 图八 %}\n图中圈起来的是比较重要的信息。当然你也可以不用这样设置，而是使用上面的自动获得DNS服务器地址，而不是手动设置，你依然可以使用上面的命令ipconfig /all来查看这些信息。现在我们知道了Source：192.168.1.105是本机的局域网ip地址，而Destination：223.5.5.5是阿里的免费DNS服务器的公有ip地址。它是浙江省杭州市电信的一个ip地址。注意了：Source是一个局域网的ip地址，Destination是一个公有ip地址，记住这个是有区别的，这个留着以后解释，为了方便理解，就当它们没有区别，如果你想知道你的公有ip地址，可以在百度中输入ip即可以搜索到，如图：\n{% asset_img 图九.png 图九 %}\n{% asset_img 图十.png 图十 %}\n理解了这些，接着往下看，192.168.1.105问223.5.5.5：你知道www.baidu.com的ip是多少吗？这个时候233.5.5.5它会怎么办呢？如果233.5.5.5已经有这条记录的缓存，就告诉192.168.1.105这条记录的ip（这个过程比较复杂，这里省略，以后详解），233.5.5.5这就是使用了ISP DNS 缓存，如果233.5.5.5也没有缓存这条记录怎么办？这个时候就要向其它服务器要了，那它又向谁要呢？这个时候就要它就会向DNS根服务器要，在进入到DNS服务器查询前，先来了解一下域名：一般来说域名都是xxx.xxx.xxx，比如：www.baidu.com就是这样的一个，所谓域名，就是用来确定域的，而且域与域是使用“.”分割，而且越后面的域越高，范围越大，如：\n{% asset_img 图十一.png 图十一 %}\nDNS有两种查询解析方式：\n\n一、192.168.1.105询问223.5.5.5，223.5.5.5将DNS根服务器ip地址列表返回给192.168.1.105，192.168.1.105再询问DNS根服务器，DNS根服务器收到查询后，查询出顶级域是com.的服务器的ip列表返回给192.168.1.105，接着192.168.1.105询问com.域服务器，com.域服务器将baidu.com.域服务器的ip列表返回给192.168.1.105，192.168.1.105再去询问baidu.com.域服务器，如果有该记录，就将相应的ip返回给192.168.1.105。\n\n二、第二种方式的是192.168.1.105询问223.5.5.5，223.5.5.5询问根服务器，根服务器询问com.服务器，com.服务器询问baidu.com.服务，baidu.com.服务返回给com.服务器，com.服务器返回给根服务器，根服务器返回个223.5.5.5，233.5.5.5返回给192.168.1.105。\n\n下面使用dig来看看方式一这个过程，如图：\n{% asset_img 图十二.png 图十二 %}\n{% asset_img 图十三.png 图十三 %}\n附上一张因特网域名空间：\n{% asset_img 图十四.png 图十四 %}\nDNS的工作过程大致就是这样，不过这并不是完整过程。最后来看一看DNS数据包，DNS查询和应答报文格式：\n{% asset_img 图十五.png 图十五 %}\n标识（2字节）：这个字段是一对DNS查询和应答唯一标识，其实就是A向B问了一个问题用类似A1这样的id表示这个问题，等B有时间处理了这个问题告诉A时，就告诉A我现在回答的是A1这个问题。\n\n标志（2字节）：这部分非常重要，是通信方式和反馈状态的一些标志位。再借个图：\n{% asset_img 图十六.png 图十六 %}\nQR(1比特）：查询/响应的标志位，1为响应，0为查询。\n\nopcode（4比特）：定义查询或响应的类型（若为0则表示是标准的，若为1则是反向的，若为2则是服务器状态请求）。\n\nAA（1比特）：授权回答的标志位。该位在响应报文中有效，1表示名字服务器是权限服务器\n\nTC（1比特）：截断标志位。1表示响应已超过512字节并已被截断，仅当DNS报文使用UDP服务器是使用，因为UDP数据报有长度限制，所以过长的DNS报文将被阶段。\n\nRD（1比特）：该位为1表示客户端希望得到递归回答（这就是上文提到的方式二），0表示迭代查询（即上文提到的方式一）\n\nRA（1比特）：只能在响应报文中置为1，表示可以得到递归响应。\n\nzero（3比特）：不说也知道都是0了，保留字段。\n\nrcode（4比特）：返回码，表示响应的差错状态，通常为0和3，各取值含义如下：\n\n\t0          无差错\n    1          格式差错\n    2          问题在域名服务器上\n    3          域不存在\n    4          查询类型不支持\n    5          在管理上被禁止\n\t6          -- 15 保留\n\n接下来的4个字段分别表示DNS报文最后4个字段的资源记录数目。对查询报文而言，它一般包含1个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。应答报文的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。\n\n查询问题的格式：\n{% asset_img 图十七.png 图十七 %}\n查询名部分长度不定，一般为要查询的域名（也会有IP的时候，即反向查询）。此部分由一个或者多个标示符序列组成，每个标示符以首字节数的计数值来说明该标示符长度，每个名字以0结束。计数字节数必须是0~63之间。该字段无需填充字节。还是借个例子来说明更直观些，查询名为www.baidu.com.\n{% asset_img 图十八.png 图十八 %}\n查询类型有：类型A，值为1，表示获取目标主机的IP地址，类型CNAME，值为5，表示获得目标主机的别名，类型PTR，值12，表示反向查询（在windows下有个命令nslookup IP，查询出域名）。\n\n查询类通常是1，表示获取因特网地址（即IP地址）。\n\n应答字段、授权字段和额外信息字段都使用资源记录（Resource Record，RR）格式，如图：\n{% asset_img 图十九.png 图十九 %}\n域名字段（不定长或2字节）：记录中资源数据对应的名字，它的格式和查询名字段格式相同。当报文中域名重复出现时，就需要使用2字节的偏移指针来替换。例如，在资源记录中，域名通常是查询问题部分的域名的重复，就需要用指针指向查询问题部分的域名。关于指针怎么用，TCP/IP详解里面有，即2字节的指针，最前面的两个高位是11，用于识别指针。其他14位从报文开始处计数（从0开始），指出该报文中的相应字节数。注意，DNS报文的第一个字节是字节0，第二个报文是字节1。一般响应报文中，资源部分的域名都是指针C00C(1100000000001100)，刚好指向查询问题部分的查询名。\n\n类型（2字节）、类（2字节）：含义与查询问题部分的类型和类相同。\n\n生存时间（4字节）：该字段表示资源记录的生命周期（以秒为单位），一般用于当地址解析程序取出资源记录后决定保存及使用缓存数据的时间。\n\n资源数据长度（2字节）：取决于类型字段，对于类型A而言，资源数据是32位的IPv4地址，而资源数据长度则为4（以字节为单位）\n\n资源数据：该字段是可变长字段，表示按查询段要求返回的相关资源记录的数据。\n\n结合wireshark抓到的包来看看：\n{% asset_img 图二十.png 图二十 %}\n这两条DNS报文就是一对，圈起来的就是标识：0X4d51，先看查询报文：\n{% asset_img 图二十一.png 图二十一 %}\n再来看应答报文：\n{% asset_img 图二十二.png 图二十二 %}\n{% asset_img 图二十三.png 图二十三 %}\n未完待续……\n\n","slug":"也说“当你输入一个网址，实际会发生什么-”","published":1,"updated":"2016-07-15T03:50:53.985Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw3e001ytkb9gmdyvhoc"},{"title":"一个关于递推关系的思考","date":"2015-08-18T13:50:00.000Z","_content":"\n\n利姐这几天忙着做笔试题，问了我一个问题（传说是阿里的笔试题，在这里先祝愿她能如愿进入阿里），前天只帮她解释了大概的解题思路，剩下的让她自己去思考思考。但是这问题的求解确实比较困难，而且这里面可以引申出很多知识点，如果要详细讲解，估计又可以写一个系列文章。现在先帮利姐解答一下这个问题。\n\n题目：用2×1（长为2，宽为1）的瓷板砖去铺6×2（长为6，宽为2）的地面，在不允许把瓷板砖分成小块的情况下，一共有多少种铺法？（这是一个选择题，选项不记得了）\n\n就这个题目而言，求解并没有多大的难处，至少可以使用穷举法，把所有的可能的铺法画出来，虽然这只是下下之策，但也不失为一个办法。这个办法在遇到大小为601×2的地面时，估计你就会傻眼了。长话短说，我们来讨论一个更为一般的情况：\n 用2×1（长为2，宽为1）的瓷板砖去铺n×2（长为n，宽为2）的地面，在不允许把瓷板砖分成小块的情况下，一共有多少种铺法？\n 设用2×1的瓷板砖去铺n×2的地面，在不允许把瓷板砖分成小块的情况下，一共有<embed src=\"http://latex.codecogs.com/svg.latex?{a_n} \" type=\"image/svg+xml\" />种铺法。\n\n第一步：很容易得出，当n=1时，<embed src=\"http://latex.codecogs.com/svg.latex?{a_1=1} \" type=\"image/svg+xml\" />，当n=2时，<embed src=\"http://latex.codecogs.com/svg.latex?{a_2=2} \" type=\"image/svg+xml\" />。\n\n第二步：当n=k时，要分两种情况：\n\n情况一：当第一块砖是竖着铺时，如下图：\n\n{% asset_img 图一.jpg 图一 %} \n\n<!--more-->\n\n此时，剩下了(k-1)×2的地面需要铺，也就是说(k-1)×2有多少种铺法，k×2就有多少种铺法，即此时有<embed src=\"http://latex.codecogs.com/svg.latex?{a_{k-1}} \" type=\"image/svg+xml\" />种铺法。\n\n情况二：当第一块砖是横着铺时，必有一块砖铺在它的下面，这里假设是第二块砖，如下图：\n\n{% asset_img 图二.jpg 图二 %} \n\n 此时，剩下了(k-2)×2的地面需要铺，也就是说(k-2)×2有多少种铺法，k×2就有多少种铺法，即此时有<embed src=\"http://latex.codecogs.com/svg.latex?{a_{k-2}} \" type=\"image/svg+xml\" />。\n\n综上，可以得到如下递推关系：<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}=a_{n+1}+a_{n}, a_1=1,a_2=2}\" type=\"image/svg+xml\" />，n是正整数。\n\n此时，很容易求出<embed src=\"http://latex.codecogs.com/svg.latex?{a_6=13}\" type=\"image/svg+xml\" />。本来得到这个递推公式已经足够解决这个问题了，但是我们还是进一步把这个问题的通项公式求出来，这样就不用每次都要从第三项一个一个推导下去。\n\n求解这个通项公式才是这问题的难点所在，这就是没有告诉利姐的地方，官方对这个问题有一个学名叫：求解2阶线性齐次递推关系。这里不讨论这个问题的官方求解方法，因为这里面有很多概念和定理要介绍，当然如果使用官方的求解方法会简单一些。下面用我多年前教我堂弟的方法来求解这个问题： \n\n第一步：根据递推公式，构造一个等比数列：\n<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}-\\alpha\\bullet a_{n+1}=\\beta\\bullet(a_{n+1}-\\alpha\\bullet a_n) \\cdots (1)} \" type=\"image/svg+xml\" />\n构造出一个以<embed src=\"http://latex.codecogs.com/svg.latex?{2-\\alpha} \" type=\"image/svg+xml\" />(即：<embed src=\"http://latex.codecogs.com/svg.latex?{a_2-\\alpha\\bullet a_1} \" type=\"image/svg+xml\" />)为首相，<embed src=\"http://latex.codecogs.com/svg.latex?{\\beta} \" type=\"image/svg+xml\" />为公比的等比数列：<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+1}-\\alpha\\bullet a_n} \" type=\"image/svg+xml\" />。\n\n将（1）式展开：<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}=(\\alpha+\\beta)\\bullet a_{n+1}-\\alpha\\beta\\bullet a_n} \" type=\"image/svg+xml\" />,根据递推公式<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}=a_{n+1}+a_n} \" type=\"image/svg+xml\" />可以得出：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}\\alpha+\\beta=1\\\\ \\alpha\\beta=-1\\end{aligned}\\right.} \" type=\"image/svg+xml\" />，根据两根之和与两根之积可以知道<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha,\\beta} \" type=\"image/svg+xml\" />是方程<embed src=\"http://latex.codecogs.com/svg.latex?{x^2-x-1=0} \" type=\"image/svg+xml\" />的两个根。这个结论你也可以通过将方程组进行消元法得到<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha^2-\\alpha-1=0} \" type=\"image/svg+xml\" />和<embed src=\"http://latex.codecogs.com/svg.latex?{\\beta^2-\\beta-1=0} \" type=\"image/svg+xml\" />，从而得出上面的结论。方程<embed src=\"http://latex.codecogs.com/svg.latex?{x^2-x-1=0} \" type=\"image/svg+xml\" />在官方有一个学名叫：特征方程。求出方程的两个根：<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha=\\frac{1+\\sqrt5}{2},\\beta=\\frac{1-\\sqrt5}{2}} \" type=\"image/svg+xml\" />（这两个值可以互换，不影响结果）。\n\n由此可以求出等比数列<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+1}-\\left(\\frac{1+\\sqrt5}{2}\\right)\\bullet a_n} \" type=\"image/svg+xml\" />的通项公式：<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+1}-\\left(\\frac{1-\\sqrt5}{2}\\right)\\bullet a_n=\\dfrac{3-\\sqrt5}{2}\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n-1}\\cdots(2)} \" type=\"image/svg+xml\" />。\n\n第二步：根据新得到的递推公式（2），构造一个等比数列：\n<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+1}-\\alpha\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n=\\beta\\bullet\\left[a_n-\\alpha\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n-1}\\right]\\cdots(3)} \" type=\"image/svg+xml\" />\n构造出一个以<embed src=\"http://latex.codecogs.com/svg.latex?{1-\\alpha} \" type=\"image/svg+xml\" />(即：<embed src=\"http://latex.codecogs.com/svg.latex?{a_1-\\alpha\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)} \" type=\"image/svg+xml\" />)为首相，<embed src=\"http://latex.codecogs.com/svg.latex?{\\beta} \" type=\"image/svg+xml\" />为公比的等比数列：<embed src=\"http://latex.codecogs.com/svg.latex?{a_n-\\alpha\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n-1}} \" type=\"image/svg+xml\" />。\n将（3）式展开：\n<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+1}=\\beta\\bullet a_n+\\alpha\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n-1}\\bullet\\left(\\dfrac{1-\\sqrt5}{2} -\\beta\\right)} \" type=\"image/svg+xml\" />\n根据（2）式可以得出：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}\\alpha&=&\\dfrac{5-3\\bullet\\sqrt5}{10} \\\\ \\beta&=&\\dfrac{1+\\sqrt5}{2} \\end{aligned}\\right.} \" type=\"image/svg+xml\" />\n由此可以求出等比数列<embed src=\"http://latex.codecogs.com/svg.latex?{a_n-\\left(\\dfrac{5-3\\bullet\\sqrt5}{10}\\right)\\bullet\\left(\\dfrac{1-\\sqrt5}{2} \\right)^{n-1} } \" type=\"image/svg+xml\" />的通项公式：\n<embed src=\"http://latex.codecogs.com/svg.latex?{a_n-\\left(\\dfrac{5-3\\bullet\\sqrt5}{10}\\right)\\bullet\\left(\\dfrac{1-\\sqrt5}{2} \\right)^{n-1}=\\left(\\dfrac{5+3\\bullet\\sqrt5}{10} \\right)\\bullet\\left(\\dfrac{1+\\sqrt5}{2} \\right)^{n-1} } \" type=\"image/svg+xml\" />\n化简得到我们想得到的通项：\n<embed src=\"http://latex.codecogs.com/svg.latex?{a_n=\\left(\\dfrac{5+\\sqrt5}{10}\\right)\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n+\\left(\\dfrac{5-\\sqrt5}{10}\\right)\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n},\\left(n\\in\\mathbb{N}^*\\right) \" type=\"image/svg+xml\" />\n这就是我们苦苦寻求的通项公式，但是这个看起来一点都不简便，还不如直接用递推公式<embed src=\"http://latex.codecogs.com/svg.latex?{a+{n+2}=a_{n+1}+a_n}\" type=\"image/svg+xml\" />简便。对此，我只能说有的时候显式的通项要比隐式的递推公式要简便，有的时候隐式的递推公式要比显式的通项简便，这要视情况而定。\n\n看到<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}=a_{n+1}+a_n}\" type=\"image/svg+xml\" />这个递推公式，这让我想起了斐波那契的那些兔子：<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}=a_{n+1}+a_n,a_1=1,a_2=1}\" type=\"image/svg+xml\" />，n是正整数，它和现在这个问题只有一个区别，那就是<embed src=\"http://latex.codecogs.com/svg.latex?{a_2}\" type=\"image/svg+xml\" />的值，有兴趣可以自己去求一下斐波那契数列的通项。\n\n这里再介绍另一种方法：\n\n根据递推公式，某一项等前两项之和，那么我们隐约可以推断这个数列的项是以某个数的指数趋势增长的，和等比数列差不多，但却还没有构成等比，也就是说后一项比前一项的比值是变化的，但是比值是收敛的，不断趋近于某一个值。当n很大时，我们假设下一项和前一项的比值就是一个常量<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha}\" type=\"image/svg+xml\" />。我们把递推公式变一下型，等式两边同时除以<embed src=\"http://latex.codecogs.com/svg.latex?{a_n}\" type=\"image/svg+xml\" />（由于数列是递增的，且<embed src=\"http://latex.codecogs.com/svg.latex?{a_1=1}\" type=\"image/svg+xml\" />，所以可以除以<embed src=\"http://latex.codecogs.com/svg.latex?{a_n}\" type=\"image/svg+xml\" />）得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\dfrac{a_{n+2}}{a_n}=\\dfrac{a_{n+1}}{a_n}+1}\" type=\"image/svg+xml\" />，\n再进一步变型：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\dfrac{a_{n+2}}{a_{n+1}}\\bullet\\dfrac{a_{n+1}}{a_n}=\\dfrac{a_{n+1}}{a_n}+1}\" type=\"image/svg+xml\" />，\n用刚才的假设可以得到<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha^2=\\alpha+1}\" type=\"image/svg+xml\" />，整理得：<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha^2-\\alpha-1=0}\" type=\"image/svg+xml\" />，是不是很眼熟，对，就是特征方程，求出<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha=\\dfrac{1\\pm\\sqrt5}{2}}\" type=\"image/svg+xml\" />，由于数列是递增的，<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha}\" type=\"image/svg+xml\" />不可能是负数，所以<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha=\\dfrac{1+\\sqrt5}{2}}\" type=\"image/svg+xml\" />。刚才说过数列并不是真的等比数列，求出了这个值以后该怎么办呢？\n\n从上面的推导我们知道，只要是一个以<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha=\\dfrac{1\\pm\\sqrt5}{2}}\" type=\"image/svg+xml\" />为公比的等比数列，就能使递推公式<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}=a_{n+1}+a_n}\" type=\"image/svg+xml\" />成立，也就是说在不考虑<embed src=\"http://latex.codecogs.com/svg.latex?{a_1=1,a_2=2}\" type=\"image/svg+xml\" />时，有\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha=\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n,\\beta=\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n}\" type=\"image/svg+xml\" />\n使得递推公式成立，现在的问题是肯定还有通项使得递推公式也成立，那怎么得到它们呢？现在把<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha,\\beta}\" type=\"image/svg+xml\" />分别带入递推公式得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}\\left(\\dfrac{1+\\sqrt5}{2}\\right)^{n+2}=\\left(\\dfrac{1+\\sqrt5}{2}\\right)^{n+1}+\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n\\\\ \\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n+2}=\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n+1}+\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n两式分别乘以一个常系数<embed src=\"http://latex.codecogs.com/svg.latex?{c_1,c_2}\" type=\"image/svg+xml\" />得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^{n+2}=c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^{n+1}+c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n\\\\ c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n+2}=c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n+1}+c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n两等式对于<embed src=\"http://latex.codecogs.com/svg.latex?{n\\in\\mathbb{N}^*}\" type=\"image/svg+xml\" />恒等，将两式相加得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\begin{aligned}c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^{n+2}+c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n+2}=\\left[c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^{n+1}+c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n+1}\\right]\\\\ +\\left[c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n+c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n\\right]\\end{aligned}}\" type=\"image/svg+xml\" />\n此时，等式对<embed src=\"http://latex.codecogs.com/svg.latex?{n\\in\\mathbb{N}^*}\" type=\"image/svg+xml\" />恒等。这时我们就可以得到满足递推公式的所有通项是：\n<embed src=\"http://latex.codecogs.com/svg.latex?{c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n+c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n\\cdots(4),n\\in\\mathbb{N}^*}\" type=\"image/svg+xml\" />\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{c_1,c_2}\" type=\"image/svg+xml\" />是常数,这就是满足递推公式的通解,\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha=\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n,\\beta=\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n}\" type=\"image/svg+xml\" />\n是<embed src=\"http://latex.codecogs.com/svg.latex?{c_1=1,c_2=0}\" type=\"image/svg+xml\" />或者<embed src=\"http://latex.codecogs.com/svg.latex?{c_1=0,c_2=1}\" type=\"image/svg+xml\" />时的特解。\n\n既然满足<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}=a_{n+1}+a_n}\" type=\"image/svg+xml\" />递推公式的所有通项都在（4）式中，那么当<embed src=\"http://latex.codecogs.com/svg.latex?{a_1=1,a_2=2}\" type=\"image/svg+xml\" />的通项也一定在这里面，从而有：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}a_1&=&c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)+c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)&=&1\\\\ a_2&=&c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^2+c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^2&=&2\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n求出\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}c_1=\\dfrac{5+\\sqrt5}{10}\\\\c_2=\\dfrac{5-\\sqrt5}{10}\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n从而得到通项：\n<embed src=\"http://latex.codecogs.com/svg.latex?{a_n=\\left(\\dfrac{5+\\sqrt5}{10}\\right)\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n+\\left(\\dfrac{5-\\sqrt5}{10}\\right)\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n},\\left(n\\in\\mathbb{N}^*\\right) \" type=\"image/svg+xml\" />\n\n到这里这个问题就告一段落了，然而，这才是刚刚开始，比如说题目中只扩展了一个维度，如果将n*2的地面改成n*m的地面，将两个维度都扩展开来，将又会有什么有趣的事情发生呢？进一步，如果瓷板砖也扩展成L形（也就是2*2在角上挖掉一个1*1的瓷板砖）的，又会发生什么呢？另外，第二种解法就是：求解2阶线性齐次递推关系的官方方法，当然上面的推理可以省略，只要记住结论就行了，那怎么推广到求解k阶线性齐次递推关系的结论呢？如果要求解2阶线性非齐次递推关系呢？比如：在高为h的AVL的树（如下图）中，最少节点数S(h)是多少？\n\n{% asset_img 图三.png 图三 %} \n\n根据题意：去掉根节点变成高为h-1和h-2的两颗AVL数，于是可以得到S(h)=S(h-1)+S(h-2)+1。这个S(h)怎么求呢？这一切的一切还有很多值得讨论的。","source":"_posts/一个关于递推关系的思考.md","raw":"title: 一个关于递推关系的思考\ntags:\n  - 数学\n  - 笔试\ncategories:\n  - 笔试\ndate: 2015-08-18 21:50:00\n---\n\n\n利姐这几天忙着做笔试题，问了我一个问题（传说是阿里的笔试题，在这里先祝愿她能如愿进入阿里），前天只帮她解释了大概的解题思路，剩下的让她自己去思考思考。但是这问题的求解确实比较困难，而且这里面可以引申出很多知识点，如果要详细讲解，估计又可以写一个系列文章。现在先帮利姐解答一下这个问题。\n\n题目：用2×1（长为2，宽为1）的瓷板砖去铺6×2（长为6，宽为2）的地面，在不允许把瓷板砖分成小块的情况下，一共有多少种铺法？（这是一个选择题，选项不记得了）\n\n就这个题目而言，求解并没有多大的难处，至少可以使用穷举法，把所有的可能的铺法画出来，虽然这只是下下之策，但也不失为一个办法。这个办法在遇到大小为601×2的地面时，估计你就会傻眼了。长话短说，我们来讨论一个更为一般的情况：\n 用2×1（长为2，宽为1）的瓷板砖去铺n×2（长为n，宽为2）的地面，在不允许把瓷板砖分成小块的情况下，一共有多少种铺法？\n 设用2×1的瓷板砖去铺n×2的地面，在不允许把瓷板砖分成小块的情况下，一共有<embed src=\"http://latex.codecogs.com/svg.latex?{a_n} \" type=\"image/svg+xml\" />种铺法。\n\n第一步：很容易得出，当n=1时，<embed src=\"http://latex.codecogs.com/svg.latex?{a_1=1} \" type=\"image/svg+xml\" />，当n=2时，<embed src=\"http://latex.codecogs.com/svg.latex?{a_2=2} \" type=\"image/svg+xml\" />。\n\n第二步：当n=k时，要分两种情况：\n\n情况一：当第一块砖是竖着铺时，如下图：\n\n{% asset_img 图一.jpg 图一 %} \n\n<!--more-->\n\n此时，剩下了(k-1)×2的地面需要铺，也就是说(k-1)×2有多少种铺法，k×2就有多少种铺法，即此时有<embed src=\"http://latex.codecogs.com/svg.latex?{a_{k-1}} \" type=\"image/svg+xml\" />种铺法。\n\n情况二：当第一块砖是横着铺时，必有一块砖铺在它的下面，这里假设是第二块砖，如下图：\n\n{% asset_img 图二.jpg 图二 %} \n\n 此时，剩下了(k-2)×2的地面需要铺，也就是说(k-2)×2有多少种铺法，k×2就有多少种铺法，即此时有<embed src=\"http://latex.codecogs.com/svg.latex?{a_{k-2}} \" type=\"image/svg+xml\" />。\n\n综上，可以得到如下递推关系：<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}=a_{n+1}+a_{n}, a_1=1,a_2=2}\" type=\"image/svg+xml\" />，n是正整数。\n\n此时，很容易求出<embed src=\"http://latex.codecogs.com/svg.latex?{a_6=13}\" type=\"image/svg+xml\" />。本来得到这个递推公式已经足够解决这个问题了，但是我们还是进一步把这个问题的通项公式求出来，这样就不用每次都要从第三项一个一个推导下去。\n\n求解这个通项公式才是这问题的难点所在，这就是没有告诉利姐的地方，官方对这个问题有一个学名叫：求解2阶线性齐次递推关系。这里不讨论这个问题的官方求解方法，因为这里面有很多概念和定理要介绍，当然如果使用官方的求解方法会简单一些。下面用我多年前教我堂弟的方法来求解这个问题： \n\n第一步：根据递推公式，构造一个等比数列：\n<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}-\\alpha\\bullet a_{n+1}=\\beta\\bullet(a_{n+1}-\\alpha\\bullet a_n) \\cdots (1)} \" type=\"image/svg+xml\" />\n构造出一个以<embed src=\"http://latex.codecogs.com/svg.latex?{2-\\alpha} \" type=\"image/svg+xml\" />(即：<embed src=\"http://latex.codecogs.com/svg.latex?{a_2-\\alpha\\bullet a_1} \" type=\"image/svg+xml\" />)为首相，<embed src=\"http://latex.codecogs.com/svg.latex?{\\beta} \" type=\"image/svg+xml\" />为公比的等比数列：<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+1}-\\alpha\\bullet a_n} \" type=\"image/svg+xml\" />。\n\n将（1）式展开：<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}=(\\alpha+\\beta)\\bullet a_{n+1}-\\alpha\\beta\\bullet a_n} \" type=\"image/svg+xml\" />,根据递推公式<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}=a_{n+1}+a_n} \" type=\"image/svg+xml\" />可以得出：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}\\alpha+\\beta=1\\\\ \\alpha\\beta=-1\\end{aligned}\\right.} \" type=\"image/svg+xml\" />，根据两根之和与两根之积可以知道<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha,\\beta} \" type=\"image/svg+xml\" />是方程<embed src=\"http://latex.codecogs.com/svg.latex?{x^2-x-1=0} \" type=\"image/svg+xml\" />的两个根。这个结论你也可以通过将方程组进行消元法得到<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha^2-\\alpha-1=0} \" type=\"image/svg+xml\" />和<embed src=\"http://latex.codecogs.com/svg.latex?{\\beta^2-\\beta-1=0} \" type=\"image/svg+xml\" />，从而得出上面的结论。方程<embed src=\"http://latex.codecogs.com/svg.latex?{x^2-x-1=0} \" type=\"image/svg+xml\" />在官方有一个学名叫：特征方程。求出方程的两个根：<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha=\\frac{1+\\sqrt5}{2},\\beta=\\frac{1-\\sqrt5}{2}} \" type=\"image/svg+xml\" />（这两个值可以互换，不影响结果）。\n\n由此可以求出等比数列<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+1}-\\left(\\frac{1+\\sqrt5}{2}\\right)\\bullet a_n} \" type=\"image/svg+xml\" />的通项公式：<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+1}-\\left(\\frac{1-\\sqrt5}{2}\\right)\\bullet a_n=\\dfrac{3-\\sqrt5}{2}\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n-1}\\cdots(2)} \" type=\"image/svg+xml\" />。\n\n第二步：根据新得到的递推公式（2），构造一个等比数列：\n<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+1}-\\alpha\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n=\\beta\\bullet\\left[a_n-\\alpha\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n-1}\\right]\\cdots(3)} \" type=\"image/svg+xml\" />\n构造出一个以<embed src=\"http://latex.codecogs.com/svg.latex?{1-\\alpha} \" type=\"image/svg+xml\" />(即：<embed src=\"http://latex.codecogs.com/svg.latex?{a_1-\\alpha\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)} \" type=\"image/svg+xml\" />)为首相，<embed src=\"http://latex.codecogs.com/svg.latex?{\\beta} \" type=\"image/svg+xml\" />为公比的等比数列：<embed src=\"http://latex.codecogs.com/svg.latex?{a_n-\\alpha\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n-1}} \" type=\"image/svg+xml\" />。\n将（3）式展开：\n<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+1}=\\beta\\bullet a_n+\\alpha\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n-1}\\bullet\\left(\\dfrac{1-\\sqrt5}{2} -\\beta\\right)} \" type=\"image/svg+xml\" />\n根据（2）式可以得出：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}\\alpha&=&\\dfrac{5-3\\bullet\\sqrt5}{10} \\\\ \\beta&=&\\dfrac{1+\\sqrt5}{2} \\end{aligned}\\right.} \" type=\"image/svg+xml\" />\n由此可以求出等比数列<embed src=\"http://latex.codecogs.com/svg.latex?{a_n-\\left(\\dfrac{5-3\\bullet\\sqrt5}{10}\\right)\\bullet\\left(\\dfrac{1-\\sqrt5}{2} \\right)^{n-1} } \" type=\"image/svg+xml\" />的通项公式：\n<embed src=\"http://latex.codecogs.com/svg.latex?{a_n-\\left(\\dfrac{5-3\\bullet\\sqrt5}{10}\\right)\\bullet\\left(\\dfrac{1-\\sqrt5}{2} \\right)^{n-1}=\\left(\\dfrac{5+3\\bullet\\sqrt5}{10} \\right)\\bullet\\left(\\dfrac{1+\\sqrt5}{2} \\right)^{n-1} } \" type=\"image/svg+xml\" />\n化简得到我们想得到的通项：\n<embed src=\"http://latex.codecogs.com/svg.latex?{a_n=\\left(\\dfrac{5+\\sqrt5}{10}\\right)\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n+\\left(\\dfrac{5-\\sqrt5}{10}\\right)\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n},\\left(n\\in\\mathbb{N}^*\\right) \" type=\"image/svg+xml\" />\n这就是我们苦苦寻求的通项公式，但是这个看起来一点都不简便，还不如直接用递推公式<embed src=\"http://latex.codecogs.com/svg.latex?{a+{n+2}=a_{n+1}+a_n}\" type=\"image/svg+xml\" />简便。对此，我只能说有的时候显式的通项要比隐式的递推公式要简便，有的时候隐式的递推公式要比显式的通项简便，这要视情况而定。\n\n看到<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}=a_{n+1}+a_n}\" type=\"image/svg+xml\" />这个递推公式，这让我想起了斐波那契的那些兔子：<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}=a_{n+1}+a_n,a_1=1,a_2=1}\" type=\"image/svg+xml\" />，n是正整数，它和现在这个问题只有一个区别，那就是<embed src=\"http://latex.codecogs.com/svg.latex?{a_2}\" type=\"image/svg+xml\" />的值，有兴趣可以自己去求一下斐波那契数列的通项。\n\n这里再介绍另一种方法：\n\n根据递推公式，某一项等前两项之和，那么我们隐约可以推断这个数列的项是以某个数的指数趋势增长的，和等比数列差不多，但却还没有构成等比，也就是说后一项比前一项的比值是变化的，但是比值是收敛的，不断趋近于某一个值。当n很大时，我们假设下一项和前一项的比值就是一个常量<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha}\" type=\"image/svg+xml\" />。我们把递推公式变一下型，等式两边同时除以<embed src=\"http://latex.codecogs.com/svg.latex?{a_n}\" type=\"image/svg+xml\" />（由于数列是递增的，且<embed src=\"http://latex.codecogs.com/svg.latex?{a_1=1}\" type=\"image/svg+xml\" />，所以可以除以<embed src=\"http://latex.codecogs.com/svg.latex?{a_n}\" type=\"image/svg+xml\" />）得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\dfrac{a_{n+2}}{a_n}=\\dfrac{a_{n+1}}{a_n}+1}\" type=\"image/svg+xml\" />，\n再进一步变型：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\dfrac{a_{n+2}}{a_{n+1}}\\bullet\\dfrac{a_{n+1}}{a_n}=\\dfrac{a_{n+1}}{a_n}+1}\" type=\"image/svg+xml\" />，\n用刚才的假设可以得到<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha^2=\\alpha+1}\" type=\"image/svg+xml\" />，整理得：<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha^2-\\alpha-1=0}\" type=\"image/svg+xml\" />，是不是很眼熟，对，就是特征方程，求出<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha=\\dfrac{1\\pm\\sqrt5}{2}}\" type=\"image/svg+xml\" />，由于数列是递增的，<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha}\" type=\"image/svg+xml\" />不可能是负数，所以<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha=\\dfrac{1+\\sqrt5}{2}}\" type=\"image/svg+xml\" />。刚才说过数列并不是真的等比数列，求出了这个值以后该怎么办呢？\n\n从上面的推导我们知道，只要是一个以<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha=\\dfrac{1\\pm\\sqrt5}{2}}\" type=\"image/svg+xml\" />为公比的等比数列，就能使递推公式<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}=a_{n+1}+a_n}\" type=\"image/svg+xml\" />成立，也就是说在不考虑<embed src=\"http://latex.codecogs.com/svg.latex?{a_1=1,a_2=2}\" type=\"image/svg+xml\" />时，有\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha=\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n,\\beta=\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n}\" type=\"image/svg+xml\" />\n使得递推公式成立，现在的问题是肯定还有通项使得递推公式也成立，那怎么得到它们呢？现在把<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha,\\beta}\" type=\"image/svg+xml\" />分别带入递推公式得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}\\left(\\dfrac{1+\\sqrt5}{2}\\right)^{n+2}=\\left(\\dfrac{1+\\sqrt5}{2}\\right)^{n+1}+\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n\\\\ \\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n+2}=\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n+1}+\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n两式分别乘以一个常系数<embed src=\"http://latex.codecogs.com/svg.latex?{c_1,c_2}\" type=\"image/svg+xml\" />得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^{n+2}=c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^{n+1}+c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n\\\\ c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n+2}=c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n+1}+c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n两等式对于<embed src=\"http://latex.codecogs.com/svg.latex?{n\\in\\mathbb{N}^*}\" type=\"image/svg+xml\" />恒等，将两式相加得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\begin{aligned}c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^{n+2}+c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n+2}=\\left[c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^{n+1}+c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^{n+1}\\right]\\\\ +\\left[c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n+c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n\\right]\\end{aligned}}\" type=\"image/svg+xml\" />\n此时，等式对<embed src=\"http://latex.codecogs.com/svg.latex?{n\\in\\mathbb{N}^*}\" type=\"image/svg+xml\" />恒等。这时我们就可以得到满足递推公式的所有通项是：\n<embed src=\"http://latex.codecogs.com/svg.latex?{c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n+c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n\\cdots(4),n\\in\\mathbb{N}^*}\" type=\"image/svg+xml\" />\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{c_1,c_2}\" type=\"image/svg+xml\" />是常数,这就是满足递推公式的通解,\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\alpha=\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n,\\beta=\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n}\" type=\"image/svg+xml\" />\n是<embed src=\"http://latex.codecogs.com/svg.latex?{c_1=1,c_2=0}\" type=\"image/svg+xml\" />或者<embed src=\"http://latex.codecogs.com/svg.latex?{c_1=0,c_2=1}\" type=\"image/svg+xml\" />时的特解。\n\n既然满足<embed src=\"http://latex.codecogs.com/svg.latex?{a_{n+2}=a_{n+1}+a_n}\" type=\"image/svg+xml\" />递推公式的所有通项都在（4）式中，那么当<embed src=\"http://latex.codecogs.com/svg.latex?{a_1=1,a_2=2}\" type=\"image/svg+xml\" />的通项也一定在这里面，从而有：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}a_1&=&c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)+c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)&=&1\\\\ a_2&=&c_1\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^2+c_2\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^2&=&2\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n求出\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}c_1=\\dfrac{5+\\sqrt5}{10}\\\\c_2=\\dfrac{5-\\sqrt5}{10}\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n从而得到通项：\n<embed src=\"http://latex.codecogs.com/svg.latex?{a_n=\\left(\\dfrac{5+\\sqrt5}{10}\\right)\\bullet\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n+\\left(\\dfrac{5-\\sqrt5}{10}\\right)\\bullet\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n},\\left(n\\in\\mathbb{N}^*\\right) \" type=\"image/svg+xml\" />\n\n到这里这个问题就告一段落了，然而，这才是刚刚开始，比如说题目中只扩展了一个维度，如果将n*2的地面改成n*m的地面，将两个维度都扩展开来，将又会有什么有趣的事情发生呢？进一步，如果瓷板砖也扩展成L形（也就是2*2在角上挖掉一个1*1的瓷板砖）的，又会发生什么呢？另外，第二种解法就是：求解2阶线性齐次递推关系的官方方法，当然上面的推理可以省略，只要记住结论就行了，那怎么推广到求解k阶线性齐次递推关系的结论呢？如果要求解2阶线性非齐次递推关系呢？比如：在高为h的AVL的树（如下图）中，最少节点数S(h)是多少？\n\n{% asset_img 图三.png 图三 %} \n\n根据题意：去掉根节点变成高为h-1和h-2的两颗AVL数，于是可以得到S(h)=S(h-1)+S(h-2)+1。这个S(h)怎么求呢？这一切的一切还有很多值得讨论的。","slug":"一个关于递推关系的思考","published":1,"updated":"2016-07-14T10:51:16.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw4w0021tkb9afd156ry"},{"title":"RSA系类（四）：完結篇","date":"2015-02-04T15:53:00.000Z","_content":"\n\n昨天说到费马小定理可以表述成：如果 m 是一个质数的话，那么对于任意一个整数 n ，随着 i（<embed src=\"http://latex.codecogs.com/svg.latex?{i\\in n^{0}} \" type=\"image/svg+xml\" />）的增加， n 的 i 次方除以 m 的余数将会呈现出长度为 m–1 的周期性。然后我们还提出了另一个问题，如果m不是质数，那么对于任意一个整数 n ，随着 i 的增加， n 的 i 次方除以 m 的余数将会呈现出多长的周期性呢？\n\n记<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(m)} \" type=\"image/svg+xml\" />为对于任意一个整数 n ，随着 i（<embed src=\"http://latex.codecogs.com/svg.latex?{i\\in n^{0}} \" type=\"image/svg+xml\" />）的增加，n 的 i 次方除以 m 的余数的周期。\n\n1.现在我们先来看一下这种情况，如果m=p×q，其中p和q互质，由中国剩余定理可以可知：任意整数对m求余的余数和这个数分别对p、q求余组成的余数数对是一一对应关系。因此，对于任意一个整数 n ，随着 i 的增加， n 的 i 次方除以 m 的余数与n 的 i 次方分别除以p、q而组成的余数数对的周期性是一致的。而n 的 i 次方除以p的周期性可以根据费马小定理得（p-1），同理，可得n 的 i 次方除以q的周期性是（q-1）。那么(p-1)×(q-1)就是n 的 i 次方除以 m 的余数的一个周期，请注意，这里说的是一个周期，并没说是最小正周期，最小正周期一概是（p-1）和（q-1）的最小公倍数才对。为了方便，我只求出周期即可，所以通常只要(p-1)×(q-1)就行了。\n\n<!--more-->\n\n通过上面的分析可得：\n\n#### 结论一：当m=p×q，其中p和q都是互质，<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(m)=(p-1)×(q-1)} \" type=\"image/svg+xml\" />。\n\n2.如果<embed src=\"http://latex.codecogs.com/svg.latex?{m=p^{k}} \" type=\"image/svg+xml\" />，其中p是质数，k是正整数。\n\n我们先来看一张表：\n\n| i        | 0 | 1 |...| p |p+1|...| 2p|2p+1|...|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}-1} \" type=\"image/svg+xml\" />|\n| :-------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|:-:|:-:|\n| i mod p  | 0 | 1 |...| 0 | 1 |...| 0 | 1  |...|p-1|\n| i mod <embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}} \" type=\"image/svg+xml\" /> | 0 | 1 |...| p |p+1|...| 2p|2p+1|...|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}-1} \" type=\"image/svg+xml\" />|\n| i        |<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}} \" type=\"image/svg+xml\" />|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}+1} \" type=\"image/svg+xml\" />|...|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}+p} \" type=\"image/svg+xml\" />|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}+p+1} \" type=\"image/svg+xml\" />|...|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}+2p} \" type=\"image/svg+xml\" />|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}+2p+1} \" type=\"image/svg+xml\" />|...|<embed src=\"http://latex.codecogs.com/svg.latex?{2p^{k}-1} \" type=\"image/svg+xml\" />|\n| i mod p  | 0 | 1 |...| 0 | 1 |...| 0 | 1  |...|p-1|\n| i mod <embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}} \" type=\"image/svg+xml\" /> | 0 | 1 |...| p |p+1|...| 2p|2p+1|...|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}-1} \" type=\"image/svg+xml\" />|\n\n因为任意一个整数对p求余的余数的周期是p，任意一个整数对<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}} \" type=\"image/svg+xml\" />求余的余数的周期是<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}} \" type=\"image/svg+xml\" />，刚好是对p求余的余数的周期的倍<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k-1}} \" type=\"image/svg+xml\" />。由此可得：n 的 i 次方除以<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}} \" type=\"image/svg+xml\" />的余数周期正好是n 的 i 次方除以p周期的<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k-1}} \" type=\"image/svg+xml\" />倍。n 的 i 次方除以p周期可以由费马小定理得到，是(p-1)，因此：\n\n#### 结论二：当<embed src=\"http://latex.codecogs.com/svg.latex?{m=p^{k}} \" type=\"image/svg+xml\" />，其中p是质数，k是正整数时，<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(m)=(p-1)\\bullet p^{k-1}} \" type=\"image/svg+xml\" />。\n\n3.如果<embed src=\"http://latex.codecogs.com/svg.latex?{m=p_1^{k_1}p_2^{k_2}\\cdots p_r^{k_r}}\" type=\"image/svg+xml\" />，其中是质数<embed src=\"http://latex.codecogs.com/svg.latex?{p_i}\" type=\"image/svg+xml\" />，<embed src=\"http://latex.codecogs.com/svg.latex?{k_i}\" type=\"image/svg+xml\" />是正整数，<embed src=\"http://latex.codecogs.com/svg.latex?{i\\in[1,r]}\" type=\"image/svg+xml\" />；\n\n由于<embed src=\"http://latex.codecogs.com/svg.latex?{p_i}\" type=\"image/svg+xml\" />都是质数，所以<embed src=\"http://latex.codecogs.com/svg.latex?{p_i^{k_i}}\" type=\"image/svg+xml\" />之间彼此都没有相同的质因数，即<embed src=\"http://latex.codecogs.com/svg.latex?{p_i^{k_i}}\" type=\"image/svg+xml\" />两两互质。根据结论一可以知道<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(m)=\\varphi(p_1^{k_1}p_2^{k_2}\\cdots p_r^{k_r})=\\varphi(p_1^{k_1})\\bullet\\varphi(p_2^{k_2})\\bullet\\cdots\\bullet\\varphi(p_r^{k_r})}\" type=\"image/svg+xml\" />，根据结论二得：<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(p_i^{k_i})=p_i^{k_i-1}\\bullet(p_i-1})=p_i^{k_i}\\bullet(1-1/p_i)}\" type=\"image/svg+xml\" />，\n\n由此可得：\n#### 结论三：当<embed src=\"http://latex.codecogs.com/svg.latex?{m=p_1^{k_1}p_2^{k_2}\\cdots p_r^{k_r}}\" type=\"image/svg+xml\" />，其中<embed src=\"http://latex.codecogs.com/svg.latex?{p_i}\" type=\"image/svg+xml\" />是质数，<embed src=\"http://latex.codecogs.com/svg.latex?{k_i}\" type=\"image/svg+xml\" />是正整数，<embed src=\"http://latex.codecogs.com/svg.latex?{i\\in[1,r]}\" type=\"image/svg+xml\" />，<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(m)&=&\\prod_{i=1}^{r}p_i^{k_i-1}(p_i-1)&=&m\\prod_{i=1}^{r}(1-1/p_i)}\" type=\"image/svg+xml\" />，而所有的整数都能表示成<embed src=\"http://latex.codecogs.com/svg.latex?{m=p_1^{k_1}p_2^{k_2}\\cdots p_r^{k_r}}\" type=\"image/svg+xml\" />，即：对于任意的整数m，都有<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(m)&=&\\prod_{i=1}^{r}p_i^{k_i-1}(p_i-1)&=&m\\prod_{i=1}^{r}(1-1/p_i)}\" type=\"image/svg+xml\" />。\n\n这个结果正好就是[欧拉函数](https://zh.wikipedia.org/wiki/欧拉函数)。\n\n由于结论一和结论二都是结论三的特例，从而有结论：\n#### 结论四：对任意正整数n 的 i 次方除以 m 的余数将会呈现出长度<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(m)&=&\\prod_{i=1}^{r}p_i^{k_i-1}(p_i-1)&=&m\\prod_{i=1}^{r}(1-1/p_i)}\" type=\"image/svg+xml\" />的周期。即<embed src=\"http://latex.codecogs.com/svg.latex?{n^{\\varphi(m)+1}&\\equiv&n(\\mod m)}\" type=\"image/svg+xml\" />。\n\n如果n和m互质，也就是下面第三个原理中的(n，m)=1的含义，根据下面除法原理的第三个原理，\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{(1):a\\equiv b(\\mod cn)\\Rightarrow a\\equiv b(\\mod n)}\\\\{(2):\\left.\\begin{aligned}a\\equiv b(\\mod m)\\\\n|m\\end{aligned}\\right\\}\\Rightarrow a\\equiv b(\\mod n)}\\\\{(3):\\left.\\begin{aligned}ac \\equiv bc(\\mod m)\\\\(c,m) = 1\\end{aligned}\\right\\}\\Rightarrow a \\equiv b(\\mod m)}\\\\{(4):\\left.\\begin{aligned} a &\\equiv& b(\\mod m_1)\\\\a &\\equiv& b(\\mod m_2)\\\\ &\\vdots& \\\\a &\\equiv& b(\\mod m_n)\\\\(&n \\ge 2)\\end{aligned}\\right\\}\\Rightarrow a\\equiv b(\\mod [m_1,m_2,\\cdots,m_n])}\" type=\"image/svg+xml\" />\n\n将n消掉，得：\n\n结论五：当n和m互质时，\n<embed src=\"http://latex.codecogs.com/svg.latex?{n^{\\varphi(m)}\\equiv 1(\\mod m)}\" type=\"image/svg+xml\" />，这就是费马小定理的广义定义，也就是[欧拉定理](https://zh.wikipedia.org/wiki/欧拉定理_(数论))（也称费马-欧拉定理或欧拉函数定理）。\n\n好了，终于把这些理论说完了，下面接着把最后一道题目解完吧。\n\n题目：你在心里想好一个3位数，然后将这个数乘以91，最后把乘积的末尾三个数字发给我，让我猜猜你心里想的那个3位数是什么？\n\n参考答案：\n\n当时只有一位小伙伴参与了这个游戏，他发给我的三位数字是250，我的回答是750。这里面的玄机是什么呢？\n\n先来看个例子：(13×27×45) mod 17 = ?，我们可以求13×27×45=15795，然后用15795÷17=929…2，得到结果是2；你还可以这么计算：\n\n[(13×27 mod 17)×45] mod 17分解成下面的步骤：\n\n13×27 mod 17 = 11，\n\n11×45 mod 17 = 2，\n\n答案也是2，这说明取模运算不论是在最后一次性求，还是在求解过程中就开始进行取模，都不会影响最后的结果。这个游戏中发送方进行了一次取模，末尾三个数字，其实就是对1000取模。如果我能求出一个数y=m×n，使得下面这个式子成立：<embed src=\"http://latex.codecogs.com/svg.latex?{a\\bullet y\\equiv q (\\mod 1000)}\" type=\"image/svg+xml\" />，然后将m公开给所有人，n只有你自己知道，这样不论别人发什么给你，你都可以根据这个式子求出这个a，根据式子可得：ay=1000k + a，a和k是整数，因为要让等式与a无关，我们令k=k’a，当a=0，很容易猜出数字是0，当a不等于0，等式变形为y=1000k’+1。恰好1001=91×11，y就取值为1001，那么m=91,n=11。让我们来还原250的原数吧，250×11=2750，2750 mod 1000 = 750。验证一下对不对，750×91 = 68250，68250 mod 1000 = 250，完全正确。Ok，到这所有这个游戏也解决了，有兴趣的小伙伴可以跟别人玩一玩哦。\n\n进入本系列的最后一个主题：RSA加密算法\n\n先来梳理一下猜数游戏，通过一种算法得到这么两组数据，一组是(N,E)，对外公开，我们称它为公钥，比如游戏中(1000,91)；另一组是(N,D)，自己保存，不能让其他人知道，我们称它为私钥，比如游戏中的(1000,11)。根据某种算法用(N,E)对数据进行加密，然后通过某种算法用(N,D)对数据进行解密，最后得到原始数据，从而完成安全的通信，上面提到的私钥不能公开。这就非对称加密算法的基本思想。那有小伙伴就会问了，要这么麻烦干嘛，直接用一个密钥对数据进行加密，然后秘密的告诉要解密的小伙伴这个密钥，不就可以完成数据的安全通信吗？当然可以，生活中很多这种加密方式，加密压缩包就是一个例子。这种是对称加密算法的思路，不过这里面有一个问题，如何安全的把密钥告诉其他小伙伴呢？你可能说这个很简单，当面告诉他，或者发短信打电话告诉他。好吧，现实生活中这种方法不失为一种解决方案，但是在互联网中通信的可不是人，而是计算机或者更精确一点说应该是进程，这就成问题了。\n\n下面对非对称加密方法原理进行详细的阐述一下：\n\n在互联网中，所有的数据都是用二进制数表示，我们都可以将它们用整数表示，比如说：在计算机中字符’A’，它的二进制表示就是：01000001，用整数表示就是65，通过前面对数论知识的介绍，我们知道：任意整数 x ，随着 i（<embed src=\"http://latex.codecogs.com/svg.latex?{i\\in n^{0}}\" type=\"image/svg+xml\" />）的增加，x 的 i 次方除以 N 的余数会呈现出以欧拉函数<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(N)}\" type=\"image/svg+xml\" />为长度的周期性。也就是说如果我们把我们要加密的数据x，也称为明文,对x进行e（<embed src=\"http://latex.codecogs.com/svg.latex?{0<e<\\varphi(N)}\" type=\"image/svg+xml\" />）次幂得<embed src=\"http://latex.codecogs.com/svg.latex?{x^{e}}\" type=\"image/svg+xml\" />，用<embed src=\"http://latex.codecogs.com/svg.latex?{x^{e}}\" type=\"image/svg+xml\" />对N求余，得到密文y，这就是整个加密过程。解密过程是这样的，将得到的密文y进行<embed src=\"http://latex.codecogs.com/svg.latex?{(k\\varphi(N)+1)\\div e}\" type=\"image/svg+xml\" />（k为整数，当然这个结果一定要为整数）次幂得<embed src=\"http://latex.codecogs.com/svg.latex?{y^{k\\varphi(N)+1}}\" type=\"image/svg+xml\" />，再将<embed src=\"http://latex.codecogs.com/svg.latex?{y^{k\\varphi(N)+1}}\" type=\"image/svg+xml\" />对N求余，由于对x总共进行了<embed src=\"http://latex.codecogs.com/svg.latex?{k\\varphi(N)+1}\" type=\"image/svg+xml\" />次幂（虽然中途对N求过模，但是不会影响最后求模的结果，虽然本文没有证明，有兴趣的小伙伴可以自行证明），由于x的i次方对N取余的余数的周期有<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(N)}\" type=\"image/svg+xml\" />，即：<embed src=\"http://latex.codecogs.com/svg.latex?{x\\equiv x^{\\varphi(N)+1}\\equiv x^{k\\varphi(N)+1}(\\mod N)}\" type=\"image/svg+xml\" />，当N>x，这可以看出x mod N = x，<embed src=\"http://latex.codecogs.com/svg.latex?{x^{k\\varphi(N)+1}\\mod N = x}\" type=\"image/svg+xml\" />，从而得出了明文x。\n\n现在问题在于这个e该怎么取值，才能使得<embed src=\"http://latex.codecogs.com/svg.latex?{(k\\varphi(N)+1)\\div e}\" type=\"image/svg+xml\" />是整数呢？在RSA加密算法中，令N=p×q，并且p与q是非常大的质数，且p不等于q。明显，p与q互质，根据欧拉函数得出：<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(N)=(p-1)(q-1)}\" type=\"image/svg+xml\" />。假设有一个整数d，满足<embed src=\"http://latex.codecogs.com/svg.latex?{d=(k\\varphi(N)+1)\\div e}\" type=\"image/svg+xml\" />，即：<embed src=\"http://latex.codecogs.com/svg.latex?{ed=k\\varphi(N)+1}\" type=\"image/svg+xml\" />，亦即：<embed src=\"http://latex.codecogs.com/svg.latex?{ed\\equiv 1(\\mod \\varphi(N))}\" type=\"image/svg+xml\" />，要使得这个式子d有解，根据之前的分水问题的结论可以知道，只有e和<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(N)}\" type=\"image/svg+xml\" />互质时，d才有解。所以，我们可以随机选择一个整数e，使得e满足<embed src=\"http://latex.codecogs.com/svg.latex?{1<e<\\varphi(N)}\" type=\"image/svg+xml\" />且e与<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(N)}\" type=\"image/svg+xml\" />互质。再根据扩展辗转相除发求出d，这样我们就生成出了公钥(N，e)和密钥(N，d)。\n\n举个例子吧，假如迪奥斯A和白富美B在热恋中，通信过程中各种甜言蜜语，有一天，A室友趁A不在的时候用A的QQ各种调戏B，搞的A跪了好几天主板，于是A和B商量，以后每次聊天的时候都要进行一次身份验证，确认身份后就可以放心地各种扯。那怎么验证身份呢，有人就说了，说口令：“天王盖地虎”，“宝塔镇河妖”，……高贵的白富美B嫌这太土匪了，于是A决定使用RSA的思想做了一个小程序发给B，并商定，以后A发第一条消息的时候，会附带这条消息一个签名，B只要把签名拷到程序中解出来跟消息内容一致就说明是A在跟B聊天。现在我们来看一看A是怎么做的呢，A先想两个质数p=17和q=19，N=17×19=323，<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(N)=16×18=288}\" type=\"image/svg+xml\" />，去e=5，5d mod 288 = 1，根据扩展辗转相除法求得d=173。公钥是（323，173），密钥是（323，5），公钥和密钥是可以交换的，为了演示把（323，173）当作公钥。比如对2进行加密，<embed src=\"http://latex.codecogs.com/svg.latex?{2^{173}\\mod 323=15}\" type=\"image/svg+xml\" />，这个时候A发给B的第一条信息是2，15。当B收到这条消息时，她只要将15输入到小程序里面，输出的结果如果是2那么就说明这是就是没心没肺的那位，如果不是，B就可以启动反调戏程序。整个故事就这般完结了，可能有小伙伴就怀疑了，这难道不能破解么，我们来看一下怎么破解哈。因为公钥（323，173），你要设法去得到密钥第一步就是要将323进行分解，目前对一个整数分解成质因数的乘积只能通过简单粗暴的方法，就是一个一个去式，当然了，这个例子只是一个例子而已，323很快就能试出来，但是当这个整数很大的时候，这种简单粗暴的方法就歇菜了。正是因为 RSA 算法用到了大数分解难题，才保证了它的安全性。\n\n2009年12月12日，编号为RSA-768（768 bits, 232 digits）数也被成功分解。这一事件威胁了现通行的1024-bit密钥的安全性，普遍认为用户应尽快升级到2048-bit或以上。\n\nRSA-768表示如下：\n\n1230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413\n= 33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489\n×\n36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917\n\n\n\n参考资料：\n1. [跨越千年的RSA算法](http://www.matrix67.com/blog/archives/5100)\n2. [RSA算法原理](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)","source":"_posts/RSA系类（四）：完結篇.md","raw":"title: RSA系类（四）：完結篇\ntags:\n  - RSA算法\n  - 数学\n  - 欧拉函数\n  - 费马小定理\ncategories:\n  - 算法\ndate: 2015-02-04 23:53:00\n---\n\n\n昨天说到费马小定理可以表述成：如果 m 是一个质数的话，那么对于任意一个整数 n ，随着 i（<embed src=\"http://latex.codecogs.com/svg.latex?{i\\in n^{0}} \" type=\"image/svg+xml\" />）的增加， n 的 i 次方除以 m 的余数将会呈现出长度为 m–1 的周期性。然后我们还提出了另一个问题，如果m不是质数，那么对于任意一个整数 n ，随着 i 的增加， n 的 i 次方除以 m 的余数将会呈现出多长的周期性呢？\n\n记<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(m)} \" type=\"image/svg+xml\" />为对于任意一个整数 n ，随着 i（<embed src=\"http://latex.codecogs.com/svg.latex?{i\\in n^{0}} \" type=\"image/svg+xml\" />）的增加，n 的 i 次方除以 m 的余数的周期。\n\n1.现在我们先来看一下这种情况，如果m=p×q，其中p和q互质，由中国剩余定理可以可知：任意整数对m求余的余数和这个数分别对p、q求余组成的余数数对是一一对应关系。因此，对于任意一个整数 n ，随着 i 的增加， n 的 i 次方除以 m 的余数与n 的 i 次方分别除以p、q而组成的余数数对的周期性是一致的。而n 的 i 次方除以p的周期性可以根据费马小定理得（p-1），同理，可得n 的 i 次方除以q的周期性是（q-1）。那么(p-1)×(q-1)就是n 的 i 次方除以 m 的余数的一个周期，请注意，这里说的是一个周期，并没说是最小正周期，最小正周期一概是（p-1）和（q-1）的最小公倍数才对。为了方便，我只求出周期即可，所以通常只要(p-1)×(q-1)就行了。\n\n<!--more-->\n\n通过上面的分析可得：\n\n#### 结论一：当m=p×q，其中p和q都是互质，<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(m)=(p-1)×(q-1)} \" type=\"image/svg+xml\" />。\n\n2.如果<embed src=\"http://latex.codecogs.com/svg.latex?{m=p^{k}} \" type=\"image/svg+xml\" />，其中p是质数，k是正整数。\n\n我们先来看一张表：\n\n| i        | 0 | 1 |...| p |p+1|...| 2p|2p+1|...|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}-1} \" type=\"image/svg+xml\" />|\n| :-------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|:-:|:-:|\n| i mod p  | 0 | 1 |...| 0 | 1 |...| 0 | 1  |...|p-1|\n| i mod <embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}} \" type=\"image/svg+xml\" /> | 0 | 1 |...| p |p+1|...| 2p|2p+1|...|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}-1} \" type=\"image/svg+xml\" />|\n| i        |<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}} \" type=\"image/svg+xml\" />|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}+1} \" type=\"image/svg+xml\" />|...|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}+p} \" type=\"image/svg+xml\" />|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}+p+1} \" type=\"image/svg+xml\" />|...|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}+2p} \" type=\"image/svg+xml\" />|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}+2p+1} \" type=\"image/svg+xml\" />|...|<embed src=\"http://latex.codecogs.com/svg.latex?{2p^{k}-1} \" type=\"image/svg+xml\" />|\n| i mod p  | 0 | 1 |...| 0 | 1 |...| 0 | 1  |...|p-1|\n| i mod <embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}} \" type=\"image/svg+xml\" /> | 0 | 1 |...| p |p+1|...| 2p|2p+1|...|<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}-1} \" type=\"image/svg+xml\" />|\n\n因为任意一个整数对p求余的余数的周期是p，任意一个整数对<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}} \" type=\"image/svg+xml\" />求余的余数的周期是<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}} \" type=\"image/svg+xml\" />，刚好是对p求余的余数的周期的倍<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k-1}} \" type=\"image/svg+xml\" />。由此可得：n 的 i 次方除以<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k}} \" type=\"image/svg+xml\" />的余数周期正好是n 的 i 次方除以p周期的<embed src=\"http://latex.codecogs.com/svg.latex?{p^{k-1}} \" type=\"image/svg+xml\" />倍。n 的 i 次方除以p周期可以由费马小定理得到，是(p-1)，因此：\n\n#### 结论二：当<embed src=\"http://latex.codecogs.com/svg.latex?{m=p^{k}} \" type=\"image/svg+xml\" />，其中p是质数，k是正整数时，<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(m)=(p-1)\\bullet p^{k-1}} \" type=\"image/svg+xml\" />。\n\n3.如果<embed src=\"http://latex.codecogs.com/svg.latex?{m=p_1^{k_1}p_2^{k_2}\\cdots p_r^{k_r}}\" type=\"image/svg+xml\" />，其中是质数<embed src=\"http://latex.codecogs.com/svg.latex?{p_i}\" type=\"image/svg+xml\" />，<embed src=\"http://latex.codecogs.com/svg.latex?{k_i}\" type=\"image/svg+xml\" />是正整数，<embed src=\"http://latex.codecogs.com/svg.latex?{i\\in[1,r]}\" type=\"image/svg+xml\" />；\n\n由于<embed src=\"http://latex.codecogs.com/svg.latex?{p_i}\" type=\"image/svg+xml\" />都是质数，所以<embed src=\"http://latex.codecogs.com/svg.latex?{p_i^{k_i}}\" type=\"image/svg+xml\" />之间彼此都没有相同的质因数，即<embed src=\"http://latex.codecogs.com/svg.latex?{p_i^{k_i}}\" type=\"image/svg+xml\" />两两互质。根据结论一可以知道<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(m)=\\varphi(p_1^{k_1}p_2^{k_2}\\cdots p_r^{k_r})=\\varphi(p_1^{k_1})\\bullet\\varphi(p_2^{k_2})\\bullet\\cdots\\bullet\\varphi(p_r^{k_r})}\" type=\"image/svg+xml\" />，根据结论二得：<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(p_i^{k_i})=p_i^{k_i-1}\\bullet(p_i-1})=p_i^{k_i}\\bullet(1-1/p_i)}\" type=\"image/svg+xml\" />，\n\n由此可得：\n#### 结论三：当<embed src=\"http://latex.codecogs.com/svg.latex?{m=p_1^{k_1}p_2^{k_2}\\cdots p_r^{k_r}}\" type=\"image/svg+xml\" />，其中<embed src=\"http://latex.codecogs.com/svg.latex?{p_i}\" type=\"image/svg+xml\" />是质数，<embed src=\"http://latex.codecogs.com/svg.latex?{k_i}\" type=\"image/svg+xml\" />是正整数，<embed src=\"http://latex.codecogs.com/svg.latex?{i\\in[1,r]}\" type=\"image/svg+xml\" />，<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(m)&=&\\prod_{i=1}^{r}p_i^{k_i-1}(p_i-1)&=&m\\prod_{i=1}^{r}(1-1/p_i)}\" type=\"image/svg+xml\" />，而所有的整数都能表示成<embed src=\"http://latex.codecogs.com/svg.latex?{m=p_1^{k_1}p_2^{k_2}\\cdots p_r^{k_r}}\" type=\"image/svg+xml\" />，即：对于任意的整数m，都有<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(m)&=&\\prod_{i=1}^{r}p_i^{k_i-1}(p_i-1)&=&m\\prod_{i=1}^{r}(1-1/p_i)}\" type=\"image/svg+xml\" />。\n\n这个结果正好就是[欧拉函数](https://zh.wikipedia.org/wiki/欧拉函数)。\n\n由于结论一和结论二都是结论三的特例，从而有结论：\n#### 结论四：对任意正整数n 的 i 次方除以 m 的余数将会呈现出长度<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(m)&=&\\prod_{i=1}^{r}p_i^{k_i-1}(p_i-1)&=&m\\prod_{i=1}^{r}(1-1/p_i)}\" type=\"image/svg+xml\" />的周期。即<embed src=\"http://latex.codecogs.com/svg.latex?{n^{\\varphi(m)+1}&\\equiv&n(\\mod m)}\" type=\"image/svg+xml\" />。\n\n如果n和m互质，也就是下面第三个原理中的(n，m)=1的含义，根据下面除法原理的第三个原理，\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{(1):a\\equiv b(\\mod cn)\\Rightarrow a\\equiv b(\\mod n)}\\\\{(2):\\left.\\begin{aligned}a\\equiv b(\\mod m)\\\\n|m\\end{aligned}\\right\\}\\Rightarrow a\\equiv b(\\mod n)}\\\\{(3):\\left.\\begin{aligned}ac \\equiv bc(\\mod m)\\\\(c,m) = 1\\end{aligned}\\right\\}\\Rightarrow a \\equiv b(\\mod m)}\\\\{(4):\\left.\\begin{aligned} a &\\equiv& b(\\mod m_1)\\\\a &\\equiv& b(\\mod m_2)\\\\ &\\vdots& \\\\a &\\equiv& b(\\mod m_n)\\\\(&n \\ge 2)\\end{aligned}\\right\\}\\Rightarrow a\\equiv b(\\mod [m_1,m_2,\\cdots,m_n])}\" type=\"image/svg+xml\" />\n\n将n消掉，得：\n\n结论五：当n和m互质时，\n<embed src=\"http://latex.codecogs.com/svg.latex?{n^{\\varphi(m)}\\equiv 1(\\mod m)}\" type=\"image/svg+xml\" />，这就是费马小定理的广义定义，也就是[欧拉定理](https://zh.wikipedia.org/wiki/欧拉定理_(数论))（也称费马-欧拉定理或欧拉函数定理）。\n\n好了，终于把这些理论说完了，下面接着把最后一道题目解完吧。\n\n题目：你在心里想好一个3位数，然后将这个数乘以91，最后把乘积的末尾三个数字发给我，让我猜猜你心里想的那个3位数是什么？\n\n参考答案：\n\n当时只有一位小伙伴参与了这个游戏，他发给我的三位数字是250，我的回答是750。这里面的玄机是什么呢？\n\n先来看个例子：(13×27×45) mod 17 = ?，我们可以求13×27×45=15795，然后用15795÷17=929…2，得到结果是2；你还可以这么计算：\n\n[(13×27 mod 17)×45] mod 17分解成下面的步骤：\n\n13×27 mod 17 = 11，\n\n11×45 mod 17 = 2，\n\n答案也是2，这说明取模运算不论是在最后一次性求，还是在求解过程中就开始进行取模，都不会影响最后的结果。这个游戏中发送方进行了一次取模，末尾三个数字，其实就是对1000取模。如果我能求出一个数y=m×n，使得下面这个式子成立：<embed src=\"http://latex.codecogs.com/svg.latex?{a\\bullet y\\equiv q (\\mod 1000)}\" type=\"image/svg+xml\" />，然后将m公开给所有人，n只有你自己知道，这样不论别人发什么给你，你都可以根据这个式子求出这个a，根据式子可得：ay=1000k + a，a和k是整数，因为要让等式与a无关，我们令k=k’a，当a=0，很容易猜出数字是0，当a不等于0，等式变形为y=1000k’+1。恰好1001=91×11，y就取值为1001，那么m=91,n=11。让我们来还原250的原数吧，250×11=2750，2750 mod 1000 = 750。验证一下对不对，750×91 = 68250，68250 mod 1000 = 250，完全正确。Ok，到这所有这个游戏也解决了，有兴趣的小伙伴可以跟别人玩一玩哦。\n\n进入本系列的最后一个主题：RSA加密算法\n\n先来梳理一下猜数游戏，通过一种算法得到这么两组数据，一组是(N,E)，对外公开，我们称它为公钥，比如游戏中(1000,91)；另一组是(N,D)，自己保存，不能让其他人知道，我们称它为私钥，比如游戏中的(1000,11)。根据某种算法用(N,E)对数据进行加密，然后通过某种算法用(N,D)对数据进行解密，最后得到原始数据，从而完成安全的通信，上面提到的私钥不能公开。这就非对称加密算法的基本思想。那有小伙伴就会问了，要这么麻烦干嘛，直接用一个密钥对数据进行加密，然后秘密的告诉要解密的小伙伴这个密钥，不就可以完成数据的安全通信吗？当然可以，生活中很多这种加密方式，加密压缩包就是一个例子。这种是对称加密算法的思路，不过这里面有一个问题，如何安全的把密钥告诉其他小伙伴呢？你可能说这个很简单，当面告诉他，或者发短信打电话告诉他。好吧，现实生活中这种方法不失为一种解决方案，但是在互联网中通信的可不是人，而是计算机或者更精确一点说应该是进程，这就成问题了。\n\n下面对非对称加密方法原理进行详细的阐述一下：\n\n在互联网中，所有的数据都是用二进制数表示，我们都可以将它们用整数表示，比如说：在计算机中字符’A’，它的二进制表示就是：01000001，用整数表示就是65，通过前面对数论知识的介绍，我们知道：任意整数 x ，随着 i（<embed src=\"http://latex.codecogs.com/svg.latex?{i\\in n^{0}}\" type=\"image/svg+xml\" />）的增加，x 的 i 次方除以 N 的余数会呈现出以欧拉函数<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(N)}\" type=\"image/svg+xml\" />为长度的周期性。也就是说如果我们把我们要加密的数据x，也称为明文,对x进行e（<embed src=\"http://latex.codecogs.com/svg.latex?{0<e<\\varphi(N)}\" type=\"image/svg+xml\" />）次幂得<embed src=\"http://latex.codecogs.com/svg.latex?{x^{e}}\" type=\"image/svg+xml\" />，用<embed src=\"http://latex.codecogs.com/svg.latex?{x^{e}}\" type=\"image/svg+xml\" />对N求余，得到密文y，这就是整个加密过程。解密过程是这样的，将得到的密文y进行<embed src=\"http://latex.codecogs.com/svg.latex?{(k\\varphi(N)+1)\\div e}\" type=\"image/svg+xml\" />（k为整数，当然这个结果一定要为整数）次幂得<embed src=\"http://latex.codecogs.com/svg.latex?{y^{k\\varphi(N)+1}}\" type=\"image/svg+xml\" />，再将<embed src=\"http://latex.codecogs.com/svg.latex?{y^{k\\varphi(N)+1}}\" type=\"image/svg+xml\" />对N求余，由于对x总共进行了<embed src=\"http://latex.codecogs.com/svg.latex?{k\\varphi(N)+1}\" type=\"image/svg+xml\" />次幂（虽然中途对N求过模，但是不会影响最后求模的结果，虽然本文没有证明，有兴趣的小伙伴可以自行证明），由于x的i次方对N取余的余数的周期有<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(N)}\" type=\"image/svg+xml\" />，即：<embed src=\"http://latex.codecogs.com/svg.latex?{x\\equiv x^{\\varphi(N)+1}\\equiv x^{k\\varphi(N)+1}(\\mod N)}\" type=\"image/svg+xml\" />，当N>x，这可以看出x mod N = x，<embed src=\"http://latex.codecogs.com/svg.latex?{x^{k\\varphi(N)+1}\\mod N = x}\" type=\"image/svg+xml\" />，从而得出了明文x。\n\n现在问题在于这个e该怎么取值，才能使得<embed src=\"http://latex.codecogs.com/svg.latex?{(k\\varphi(N)+1)\\div e}\" type=\"image/svg+xml\" />是整数呢？在RSA加密算法中，令N=p×q，并且p与q是非常大的质数，且p不等于q。明显，p与q互质，根据欧拉函数得出：<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(N)=(p-1)(q-1)}\" type=\"image/svg+xml\" />。假设有一个整数d，满足<embed src=\"http://latex.codecogs.com/svg.latex?{d=(k\\varphi(N)+1)\\div e}\" type=\"image/svg+xml\" />，即：<embed src=\"http://latex.codecogs.com/svg.latex?{ed=k\\varphi(N)+1}\" type=\"image/svg+xml\" />，亦即：<embed src=\"http://latex.codecogs.com/svg.latex?{ed\\equiv 1(\\mod \\varphi(N))}\" type=\"image/svg+xml\" />，要使得这个式子d有解，根据之前的分水问题的结论可以知道，只有e和<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(N)}\" type=\"image/svg+xml\" />互质时，d才有解。所以，我们可以随机选择一个整数e，使得e满足<embed src=\"http://latex.codecogs.com/svg.latex?{1<e<\\varphi(N)}\" type=\"image/svg+xml\" />且e与<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(N)}\" type=\"image/svg+xml\" />互质。再根据扩展辗转相除发求出d，这样我们就生成出了公钥(N，e)和密钥(N，d)。\n\n举个例子吧，假如迪奥斯A和白富美B在热恋中，通信过程中各种甜言蜜语，有一天，A室友趁A不在的时候用A的QQ各种调戏B，搞的A跪了好几天主板，于是A和B商量，以后每次聊天的时候都要进行一次身份验证，确认身份后就可以放心地各种扯。那怎么验证身份呢，有人就说了，说口令：“天王盖地虎”，“宝塔镇河妖”，……高贵的白富美B嫌这太土匪了，于是A决定使用RSA的思想做了一个小程序发给B，并商定，以后A发第一条消息的时候，会附带这条消息一个签名，B只要把签名拷到程序中解出来跟消息内容一致就说明是A在跟B聊天。现在我们来看一看A是怎么做的呢，A先想两个质数p=17和q=19，N=17×19=323，<embed src=\"http://latex.codecogs.com/svg.latex?{\\varphi(N)=16×18=288}\" type=\"image/svg+xml\" />，去e=5，5d mod 288 = 1，根据扩展辗转相除法求得d=173。公钥是（323，173），密钥是（323，5），公钥和密钥是可以交换的，为了演示把（323，173）当作公钥。比如对2进行加密，<embed src=\"http://latex.codecogs.com/svg.latex?{2^{173}\\mod 323=15}\" type=\"image/svg+xml\" />，这个时候A发给B的第一条信息是2，15。当B收到这条消息时，她只要将15输入到小程序里面，输出的结果如果是2那么就说明这是就是没心没肺的那位，如果不是，B就可以启动反调戏程序。整个故事就这般完结了，可能有小伙伴就怀疑了，这难道不能破解么，我们来看一下怎么破解哈。因为公钥（323，173），你要设法去得到密钥第一步就是要将323进行分解，目前对一个整数分解成质因数的乘积只能通过简单粗暴的方法，就是一个一个去式，当然了，这个例子只是一个例子而已，323很快就能试出来，但是当这个整数很大的时候，这种简单粗暴的方法就歇菜了。正是因为 RSA 算法用到了大数分解难题，才保证了它的安全性。\n\n2009年12月12日，编号为RSA-768（768 bits, 232 digits）数也被成功分解。这一事件威胁了现通行的1024-bit密钥的安全性，普遍认为用户应尽快升级到2048-bit或以上。\n\nRSA-768表示如下：\n\n1230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413\n= 33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489\n×\n36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917\n\n\n\n参考资料：\n1. [跨越千年的RSA算法](http://www.matrix67.com/blog/archives/5100)\n2. [RSA算法原理](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)","slug":"RSA系类（四）：完結篇","published":1,"updated":"2016-07-14T06:36:15.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw530026tkb9761mr0f2"},{"title":"RSA系类（二）：分水问题","date":"2015-02-02T14:13:00.000Z","_content":"\n\n再次声明：本文只写给对数学或者计算机感兴趣的小伙伴们！\n\n今天先对昨天日记有严重问题的地方进行修正：\n\n1）还有下面这句话是有很严重的错误的，少了一个前提，为了叙述方便我们设A÷B=C···R，\n下面这句话成立的条件是C=1，A：B=B：R，又因为R=A-B，从而得A：B=B：(A-B)，解出\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\frac{B}{A}=\\frac{\\sqrt{5}-1}{2}\\approx\\frac{0.618}{1}} \" type=\"image/svg+xml\" />\n\n顺便提一下，这个时候被除数和除数的比例关系正好满足黄金分割比例1：0.618\n\n好了，现在开始解题：\n#### 2、假如你有一个6升的容器和一个9升的容器（以及充足的水源，容器没有刻度），1到8升水哪些呢取出来，哪些不能取出来，为什么，假如你有一个a升的容器和一个b升的容器（以及充足的水源，容器没有刻度），1到max{a,b}-1升水哪些呢取出来，哪些不能取出来，为什么？（说明：max{a,b}表示a和b中较大的那个数）\n\n<!--more-->\n\n参考答案：\n\n先从一个简单的情况说起：假如你有一个 3 升的容器和一个5升的容器（以及充足的水源），如何精确的得到4升水？\n\n将3 升的容器记为A，5升的容器记为B：\n\n1） 将 A 装满，此时 A 中的水为 3 升， B 中的水为 0 升；\n\n2） 将 A 里的水全部倒入 B ，此时 A 中的水为 0 升， B 中的水为 3 升；\n\n3） 将 A 装满，此时 A 中的水为 3 升， B 中的水为 3 升；\n\n4） 将 A 里的水倒入 B 直到把 B 装满，此时 A 中的水为 1 升， B 中的水为 5 升；\n\n5） 将 B 里的水全部倒掉，此时 A 中的水为 1 升， B 中的水为 0 升；\n\n6） 将 A 里剩余的水全部倒入 B ，此时 A 中的水为 0 升， B 中的水为 1 升；\n\n7） 将 A 装满，此时 A 中的水为 3 升， B 中的水为 1 升；\n\n8） 将 A 里的水全部倒入 B ，此时 A 中的水为 0 升， B 中的水为 4 升；\n\n \n\n现在我们尝试把这个过程用数学语言来表述一下：由于容器没有刻度，而且取水的过程都是一容器一容器的去取，由此可以得出总的取水量是A容器的整数倍，Ｂ容器倒水也是一容器一容器的倒，所以倒出去的水也就是B容器的整数倍。而最后剩余的水就是n次A容器取水的总量减掉m次B容器倒水的总量。因此得出：3×n - 5×m=4，求出m,n就能得到结果。现在的问题来了，这个二元不定方程怎么求呢？有小伙伴说哪来那么多事，写个程序，直接从1开始，一个一个的往后面试就是了。这个小伙伴的方法很好，从这可以看出这个小伙伴是一个直截了当或者说简单粗暴的人，我喜欢，哈哈。不过，这里有个方法你可以试一试，如果我们能求出3×n’ + 5×m’=1,那么就能很快得出3×n’×4 - 5×(-m’)×4=4，要求解这个3×n’ + 5×m’=1这个不定式，我们得先回顾一下第一道题里面的辗转相除法：\n\n1）210 ÷165=1 ···45（余数）；\n\n2）165÷45=3···30（余数）；\n\n3）45÷30=1···15（余数）；\n\n4）30÷15=2···0（余数）；\n\n我们这样就能确定出最大公因数15，现在我们把上面的步骤换一种表示方法：\n\n1）45=210×1+165×(-1)；\n\n2）30=165×1+45×(-3)；\n\n3）15=45×1+30×(-1)；\n\n4）0=30×1+15×(-2)；\n\n现在我们忽略最后一个等式，把45和30这两个数看做是两个未知数，然后将2）式代入3）式替换掉30，再将结果等式中的45用1）式替换，也就是从下往上，依次将上面一个等式右边的式子代换掉下面等式右边式子中等于上面等式左边的那个数：\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}30&=&165\\times1+45\\times(-3)\\\\15&=&45\\times1+30\\times(-1)\\end{aligned}\\right\\}\\Rightarrow15=45\\times1+[165\\times1+45\\times(-3)]\\times(-1) }\" type=\"image/svg+xml\" />\n\n化简得15=45×4+165×(-1)，再将1）式替换掉45得：\n\n15=[210×1+165×(-1)]×4+165×(-1)，化简得：210×4+165×(-5)=15，好神奇的一种方法呀，最后居然化简出了一个由原来被除数和除数做为系数，最大公约数作为结果的一个等式，我们可以按照刚才的那种方法来求解任何一个满足ax+by=a和b最大公约数的不定方程，这种求解方法叫做[扩展欧几里得算法](https://zh.wikipedia.org/wiki/扩展欧几里得算法)或者[扩展辗转相除法](https://zh.wikipedia.org/wiki/扩展欧几里得算法)。我们可以来试一试3×n’ + 5×m’=1这个不定方程，因为3和5的最大公因数就是1,从而满足要求，先对5和3进行辗转相除法：\n\n1）5÷3=1 ···2（余数）；\n\n2）3÷2=1···1（余数）；\n\n3）2÷1=2···0（余数）；\n\n转换一下：\n\n1）2=5×1+3×(-1)；\n\n2）1=3×1+2×(-1)；\n\n代入的：\n\n3×2 + 5×(-1)=1  \n\n所以n’=2，m’=-1；\n\n最后，我们求解一下3×n - 5×m=4这个不定方程：\n\n3×2 + 5×(-1)=1两边同时乘以4得：3×8 + 5×(-4)=4，从而得出：n=8，m=-4，有些聪明的小伙伴就会说：“我书读的少，你不要骗我，这个结果跟前面倒水过程的结果明显不相等”，好吧，我承认我是在忽悠你，这个结果其实很明显了：由于3的5倍刚好等于5的3倍，等式再变换一下的：3×3 + 3×5 + 5×(-4) = 3×3 + 5×(-1)，这种简单情况终于解释完了。\n\n回答一下原始问题：6升和9升的容器，根据上面的结论，应该很容易得出：6x+9y=3一定有解的，同时能准确取出3的倍数升水。所以1到8升水中3升和6升水是可以取出来的，那其余的能取出来吗，为什么呢？答案是不能，有兴趣的小伙伴可以去查看[裴蜀定理](https://zh.wikipedia.org/wiki/貝祖等式)。从上面的分析，我们能得出，a升和b升容器的答案：在区间[1,max{a,b}-1]上的a和b的最大公约数的整数倍是能够精确取出来的。\n\n参考资料：\n1. [跨越千年的RSA算法](http://www.matrix67.com/blog/archives/5100)\n2. [RSA算法原理](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)","source":"_posts/RSA系类（二）：分水问题.md","raw":"title: RSA系类（二）：分水问题\ntags:\n  - RSA算法\n  - 数学\n  - 扩展辗转相除法\ncategories:\n  - 算法\ndate: 2015-02-02 22:13:00\n---\n\n\n再次声明：本文只写给对数学或者计算机感兴趣的小伙伴们！\n\n今天先对昨天日记有严重问题的地方进行修正：\n\n1）还有下面这句话是有很严重的错误的，少了一个前提，为了叙述方便我们设A÷B=C···R，\n下面这句话成立的条件是C=1，A：B=B：R，又因为R=A-B，从而得A：B=B：(A-B)，解出\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\frac{B}{A}=\\frac{\\sqrt{5}-1}{2}\\approx\\frac{0.618}{1}} \" type=\"image/svg+xml\" />\n\n顺便提一下，这个时候被除数和除数的比例关系正好满足黄金分割比例1：0.618\n\n好了，现在开始解题：\n#### 2、假如你有一个6升的容器和一个9升的容器（以及充足的水源，容器没有刻度），1到8升水哪些呢取出来，哪些不能取出来，为什么，假如你有一个a升的容器和一个b升的容器（以及充足的水源，容器没有刻度），1到max{a,b}-1升水哪些呢取出来，哪些不能取出来，为什么？（说明：max{a,b}表示a和b中较大的那个数）\n\n<!--more-->\n\n参考答案：\n\n先从一个简单的情况说起：假如你有一个 3 升的容器和一个5升的容器（以及充足的水源），如何精确的得到4升水？\n\n将3 升的容器记为A，5升的容器记为B：\n\n1） 将 A 装满，此时 A 中的水为 3 升， B 中的水为 0 升；\n\n2） 将 A 里的水全部倒入 B ，此时 A 中的水为 0 升， B 中的水为 3 升；\n\n3） 将 A 装满，此时 A 中的水为 3 升， B 中的水为 3 升；\n\n4） 将 A 里的水倒入 B 直到把 B 装满，此时 A 中的水为 1 升， B 中的水为 5 升；\n\n5） 将 B 里的水全部倒掉，此时 A 中的水为 1 升， B 中的水为 0 升；\n\n6） 将 A 里剩余的水全部倒入 B ，此时 A 中的水为 0 升， B 中的水为 1 升；\n\n7） 将 A 装满，此时 A 中的水为 3 升， B 中的水为 1 升；\n\n8） 将 A 里的水全部倒入 B ，此时 A 中的水为 0 升， B 中的水为 4 升；\n\n \n\n现在我们尝试把这个过程用数学语言来表述一下：由于容器没有刻度，而且取水的过程都是一容器一容器的去取，由此可以得出总的取水量是A容器的整数倍，Ｂ容器倒水也是一容器一容器的倒，所以倒出去的水也就是B容器的整数倍。而最后剩余的水就是n次A容器取水的总量减掉m次B容器倒水的总量。因此得出：3×n - 5×m=4，求出m,n就能得到结果。现在的问题来了，这个二元不定方程怎么求呢？有小伙伴说哪来那么多事，写个程序，直接从1开始，一个一个的往后面试就是了。这个小伙伴的方法很好，从这可以看出这个小伙伴是一个直截了当或者说简单粗暴的人，我喜欢，哈哈。不过，这里有个方法你可以试一试，如果我们能求出3×n’ + 5×m’=1,那么就能很快得出3×n’×4 - 5×(-m’)×4=4，要求解这个3×n’ + 5×m’=1这个不定式，我们得先回顾一下第一道题里面的辗转相除法：\n\n1）210 ÷165=1 ···45（余数）；\n\n2）165÷45=3···30（余数）；\n\n3）45÷30=1···15（余数）；\n\n4）30÷15=2···0（余数）；\n\n我们这样就能确定出最大公因数15，现在我们把上面的步骤换一种表示方法：\n\n1）45=210×1+165×(-1)；\n\n2）30=165×1+45×(-3)；\n\n3）15=45×1+30×(-1)；\n\n4）0=30×1+15×(-2)；\n\n现在我们忽略最后一个等式，把45和30这两个数看做是两个未知数，然后将2）式代入3）式替换掉30，再将结果等式中的45用1）式替换，也就是从下往上，依次将上面一个等式右边的式子代换掉下面等式右边式子中等于上面等式左边的那个数：\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}30&=&165\\times1+45\\times(-3)\\\\15&=&45\\times1+30\\times(-1)\\end{aligned}\\right\\}\\Rightarrow15=45\\times1+[165\\times1+45\\times(-3)]\\times(-1) }\" type=\"image/svg+xml\" />\n\n化简得15=45×4+165×(-1)，再将1）式替换掉45得：\n\n15=[210×1+165×(-1)]×4+165×(-1)，化简得：210×4+165×(-5)=15，好神奇的一种方法呀，最后居然化简出了一个由原来被除数和除数做为系数，最大公约数作为结果的一个等式，我们可以按照刚才的那种方法来求解任何一个满足ax+by=a和b最大公约数的不定方程，这种求解方法叫做[扩展欧几里得算法](https://zh.wikipedia.org/wiki/扩展欧几里得算法)或者[扩展辗转相除法](https://zh.wikipedia.org/wiki/扩展欧几里得算法)。我们可以来试一试3×n’ + 5×m’=1这个不定方程，因为3和5的最大公因数就是1,从而满足要求，先对5和3进行辗转相除法：\n\n1）5÷3=1 ···2（余数）；\n\n2）3÷2=1···1（余数）；\n\n3）2÷1=2···0（余数）；\n\n转换一下：\n\n1）2=5×1+3×(-1)；\n\n2）1=3×1+2×(-1)；\n\n代入的：\n\n3×2 + 5×(-1)=1  \n\n所以n’=2，m’=-1；\n\n最后，我们求解一下3×n - 5×m=4这个不定方程：\n\n3×2 + 5×(-1)=1两边同时乘以4得：3×8 + 5×(-4)=4，从而得出：n=8，m=-4，有些聪明的小伙伴就会说：“我书读的少，你不要骗我，这个结果跟前面倒水过程的结果明显不相等”，好吧，我承认我是在忽悠你，这个结果其实很明显了：由于3的5倍刚好等于5的3倍，等式再变换一下的：3×3 + 3×5 + 5×(-4) = 3×3 + 5×(-1)，这种简单情况终于解释完了。\n\n回答一下原始问题：6升和9升的容器，根据上面的结论，应该很容易得出：6x+9y=3一定有解的，同时能准确取出3的倍数升水。所以1到8升水中3升和6升水是可以取出来的，那其余的能取出来吗，为什么呢？答案是不能，有兴趣的小伙伴可以去查看[裴蜀定理](https://zh.wikipedia.org/wiki/貝祖等式)。从上面的分析，我们能得出，a升和b升容器的答案：在区间[1,max{a,b}-1]上的a和b的最大公约数的整数倍是能够精确取出来的。\n\n参考资料：\n1. [跨越千年的RSA算法](http://www.matrix67.com/blog/archives/5100)\n2. [RSA算法原理](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)","slug":"RSA系类（二）：分水问题","published":1,"updated":"2016-07-13T08:36:51.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw5f002gtkb9ocv94lnw"},{"title":"RSA系类（三）：从物不知数到中国剩余定理和费马小定理","date":"2015-02-03T15:51:00.000Z","_content":"\n\n先对昨天的错误进行修正：“最后，我们求解一下3×n - 5×m=4这个不定方程： 3×2 + 5×(-1)=1两边同时乘以4得：3×8 + 5×(-4)=4，从而得出：n=8，m=-4”，这句话中的m=-4应该改成m=4。\n\n下面进入今天的主题： \n\n#### 3、今有物不知其数，三三数之剩二；五五数之剩三；七七数之剩二。问物几何?\n{% blockquote 维基百科 http://baike.baidu.com/link?url=nUHiJ81_AIP_fx3ebRpG4BJBAkPfOdEkaqfT6g3_A12-soPBRF6fzKSQQRZuvNMDEe7lhfworl2v_TBb9g5Kba 物不知数%}\n中国古代著名算题。原载《孙子算经》卷下第二十六题：“今有物不知其数，三三数之剩二；五五数之剩三；七七数之剩二。问物几何?”当时虽已有了答案23，但它的系统解法是秦九韶在《数书九章·大衍求一术》中给出的。大衍求一术（也称作“中国剩余定理”）是中国古算中最有独创性的成就之一，属现代数论中的一次同余式组问题。\n{% endblockquote %}\n<!--more-->\n\n今天讨论一下中国剩余定理，先把这个‘物不知数’这个问题解决。\n\n参考答案：\n\n先回顾一下分水问题，我们首先对一种简单的情况进行数学抽象，得出要解决分水问题，就要先解出3×n - 5×m=1这个二元不定式，再根据扩展欧几里得算法求得m、n，得出结果，最后总结出：在区间[1,max{a,b}-1]上的a和b的最大公约数的整数倍是能够精确取出来的，这其实就是裴蜀定理。\n\n现在我们把这个数学抽象变化一下，变成这个样子：<embed src=\"http://latex.codecogs.com/svg.latex?{3x\\mod5=1} \" type=\"image/svg+xml\" />，抑或者是：<embed src=\"http://latex.codecogs.com/svg.latex?{3x\\equiv1(\\mod 5)} \" type=\"image/svg+xml\" />，这两个等式都是表示3x除以5的余数为1（如有小伙伴还不明白等式是什么含义请参考[同余](https://zh.wikipedia.org/wiki/同餘)）。由于这两个式子和3×n - 5×m=1都是对分水问题的数学抽象，因此，都可以使用扩展欧几里得算法求解x，请记住这种方法，待会用的着。\n\n先给出同余的概念：当两个整数除以同一个正整数，若得相同余数，则两整数[同余](https://zh.wikipedia.org/wiki/同餘)。\n\n下面几个同余的性质接下来可能用得着：\n\n1）传递性\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}a&\\equiv&b(\\mod m)\\\\b&\\equiv&c(\\mod m)\\end{aligned}\\right\\}\\Rightarrow a\\equiv c(\\mod m)}\" type=\"image/svg+xml\" />\n2）保持基本运算\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}a&\\equiv&b(\\mod m)\\\\c&\\equiv&d(\\mod m)\\end{aligned}\\right\\}\\Rightarrow \\left\\{\\begin{aligned}a\\pm c&\\equiv&b\\pm d(\\mod m)\\\\ac&\\equiv&bd(\\mod m)\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n这性质更可进一步引申成为这样：\n<embed src=\"http://latex.codecogs.com/svg.latex?{a\\equiv b(\\mod m)\\Rightarrow \\left\\{\\begin{aligned}an&\\equiv&bn(\\mod m),\\forall n\\in\\mathbb{Z}\\\\a^{n}&\\equiv&b^{n}(\\mod m),\\forall n \\in \\mathbb{N}^{0}\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n \n好了，开始解题：\n\n以下解题过程中都是针对整数而言，没有特殊说明都是指整数。\n\n设这个整数为x，\n\n根据题意可得：\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{(S):\\left\\{\\begin{aligned}x&\\equiv&2 (\\mod3)\\\\x&\\equiv&3(\\mod5)\\\\x&\\equiv&2(\\mod7)\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n\n我们来思考这么一种情况：\n\n如果一个整数X1满足，X1是5和7的倍数，除以3的余数是2，那么就能推出下面这组同余式：\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}x_1&\\equiv&2 (\\mod3)\\\\x_1&\\equiv&0(\\mod5)\\\\x_1&\\equiv&0(\\mod7)\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n\n同理，整数X2满足，X2是3和7的倍数，除以5的余数是3，整数X3满足，X3是3和5的倍数，除以7的余数是2：\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}x_2&\\equiv&0 (\\mod3)\\\\x_2&\\equiv&3(\\mod5)\\\\x_2&\\equiv&0(\\mod7)\\end{aligned}\\right.}\" type=\"image/svg+xml\" />，<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}x_3&\\equiv&0 (\\mod3)\\\\x_3&\\equiv&0(\\mod5)\\\\x_3&\\equiv&2(\\mod7)\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n根据\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}a&\\equiv&b(\\mod m)\\\\c&\\equiv&d(\\mod m)\\end{aligned}\\right\\}\\Rightarrow a\\pm c&\\equiv&b\\pm d(\\mod m)}\" type=\"image/svg+xml\" />\n得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}x_1&\\equiv&2(\\mod 3)\\\\x_2&\\equiv&0(\\mod 3)\\end{aligned}\\right\\}\\Rightarrow x_1+ x_2&\\equiv&2+0(\\mod 3)}\" type=\"image/svg+xml\" />，<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}x_1+x_2&\\equiv&2(\\mod 3)\\\\x_3&\\equiv&0(\\mod 3)\\end{aligned}\\right\\}\\Rightarrow x_1+ x_2+x_3&\\equiv&2+0(\\mod 3)}\" type=\"image/svg+xml\" />\n所以：\n<embed src=\"http://latex.codecogs.com/svg.latex?{ x_1+ x_2+x_3&\\equiv&2(\\mod 3)}\" type=\"image/svg+xml\" />；\n同理可得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{ x_1+ x_2+x_3&\\equiv&3(\\mod 5)}\" type=\"image/svg+xml\" />，<embed src=\"http://latex.codecogs.com/svg.latex?{ x_1+ x_2+x_3&\\equiv&2(\\mod 7)}\" type=\"image/svg+xml\" />；\n\n因此，只要我们求得X1+X2+X3就是答案。现在我们来看一下X1怎么求解吧：\n\n根据\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}x_1&\\equiv&2 (\\mod3)\\\\x_1&\\equiv&0(\\mod5)\\\\x_1&\\equiv&0(\\mod7)\\end{aligned}\\right.}\" type=\"image/svg+xml\" />等价于<embed src=\"http://latex.codecogs.com/svg.latex?{5\\times 7\\times x_1^{'}&\\equiv&2(\\mod 3)}\" type=\"image/svg+xml\" />，因此只要求出x1'即可求出答案，这个时候就得用上扩展欧几里得算法求出x1'，哈哈，整个人都神清气爽了有木有。我们再把上面等式翻译成分水问题，有35升和3升无刻度的两个容器，现在只能用35升的容器取水，3升的容器倒水，请精确取出2升水。\n\n我们还是根据扩展欧几里得算法得出：\n\n3×12 + 35×(-1) =1，这个结果好像不对头，它是用3升的容器取水，35升容器倒水的结果，那该怎么办呢？很简单等式两边同时乘以-1，就变成了35升的容器取水，3升的容器倒水，第12次倒水后得-1，这明显不可能，少倒一次水，剩下的就正好是2升水，所以x1'=1。\n\n同理求出<embed src=\"http://latex.codecogs.com/svg.latex?{ x_2^{'}=3,x_3^{'}=2}\" type=\"image/svg+xml\" />；\n\n从而得出<embed src=\"http://latex.codecogs.com/svg.latex?{ x_1=35,x_2=63,x_3=30}\" type=\"image/svg+xml\" />，\n\n最后得出x=X1+X2+X3=128，\n\n这个地方碰巧，很容易能取出2升水，我们还是按照我们先取出1升，让后再根据倍数关系，求得2升水吧，这样的话更具有规律性。\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}35\\times 1+3\\times (-12)&=&-1\\\\35\\times 1+3\\times(-11)&=&2\\end{aligned}\\right\\}\\Rightarrow 35\\times 2+3\\times (-23)=1}\" type=\"image/svg+xml\" />，从而x1'=2×2=4，同理得x2'=3，x3'=2，此时我们称x1'、x2'、x3'为模逆元，由于它们形如：<embed src=\"http://latex.codecogs.com/svg.latex?{x_1^{'}\\times M&\\equiv&1(\\mod m)}\" type=\"image/svg+xml\" />，所以也称为数论倒数；\n\n从而得出x1=140，x2=63，x3=30，\n\n最后得出x=X1+X2+X3=233，\n\n聪明的小伙伴立刻明白答案不止一个，23也是对的，而且还有无数多个解，下面进一步说明一下：\n\n由于3,5,7这三个数是两两互质，所以它们的最小公倍数是3×5×7=105,105显然能同时整除3,5,7。根据下面这个性质：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}a&\\equiv&b(\\mod m)\\\\c&\\equiv&d(\\mod m)\\end{aligned}\\right\\}\\Rightarrowa\\pm c&\\equiv&b\\pm d(\\mod m)}\" type=\"image/svg+xml\" />\nx+k×105显然还是满足\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}x+k\\times 105&\\equiv&2(\\mod 3)\\\\x+k\\times 105&\\equiv&3(\\mod 5)\\\\x+k\\times 105&\\equiv&2(\\mod 7)\\end{aligned}\\right.}\" type=\"image/svg+xml\" />,\n因此，这个问题的通解是：<embed src=\"http://latex.codecogs.com/svg.latex?{23+k\\times 105,k\\in\\mathbb{Z}}\" type=\"image/svg+xml\" />。\n\nOk，解题完毕，物不知数就是中国剩余定理的一个实例。现在来看孙子定理也就是中国剩余定理：给出 i 个两两互质的整数，记为<embed src=\"http://latex.codecogs.com/svg.latex?{\\display m_1,m_2,m_3,\\cdots,m_i}\" type=\"image/svg+xml\" />，它们的乘积为 P ；假设有一个未知数 M ，如果我们已知 M 分别除以这 m 个数所得的余数，记为<embed src=\"http://latex.codecogs.com/svg.latex?{\\display r_1,r_2,r_3,\\cdots,r_i}\" type=\"image/svg+xml\" />那么在 0 到 P–1 的范围内，我们可以唯一地确定这个 M 。现代数学语言的描述，我就不贴了，有兴趣的同学就自己看wiki吧。\n\n我们从定义里面可以看出中国剩余定理有以下两点特性：\n\n1.当的整数时<embed src=\"http://latex.codecogs.com/svg.latex?{M\\in[0,P-1]}\" type=\"image/svg+xml\" />每一组余数（记为：<embed src=\"http://latex.codecogs.com/svg.latex?{\\display r_1,r_2,r_3,\\cdots,r_i}\" type=\"image/svg+xml\" />）都有唯一的一个M与之对应，而且每一个M也只有一组余数与之对应，即M与<embed src=\"http://latex.codecogs.com/svg.latex?{\\display r_1,r_2,r_3,\\cdots,r_i}\" type=\"image/svg+xml\" />是一一对应关系，由于M的取值恰好是任意整数对P求余的余数，所以结论也可以表述为任意整数对P的余数与<embed src=\"http://latex.codecogs.com/svg.latex?{\\display r_1,r_2,r_3,\\cdots,r_i}\" type=\"image/svg+xml\" />是一一对应关系；\n\n2.在<embed src=\"http://latex.codecogs.com/svg.latex?{m\\in\\mathbb{Z}}\" type=\"image/svg+xml\" />，如果余数数组看作m的一个函数，那么函数呈现周期性，且m的最小正周期是P。\n\n \n\n下面举个例：\n\n2个互质的整数3和10，它们的乘积是30，那么在[0,29]区间内的数，分别处以3和10的余数如下表所示：\n\n| i        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n| :-------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| i mod 3  | 0 | 1 | 2 | 0 | 1 | 2 | 0 | 1 | 2 | 0 |\n| i mod 10 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n| i        | 10| 11| 12| 13| 14| 15| 16| 17| 18| 19|\n| i mod 3  | 1 | 2 | 0 | 1 | 2 | 0 | 1 | 2 | 0 | 1 |\n| i mod 10 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n| i        | 20| 21| 22| 23| 24| 25| 26| 27| 28| 29|\n| i mod 3  | 2 | 0 | 1 | 2 | 0 | 1 | 2 | 0 | 1 | 2 |\n| i mod 10 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n\n\n由除以3的余数与除以10的余数组成的余数对没有出现重复现象，而且，整数M对30取模它的余数就是上表中i的取值，这就表明若果已知两个互质的整数3和10，可知它们的最小公倍数，记为gcd(3,10)，易得gcd(3,10)=3×10=30，此时，余数数对(x mod 3 , x mod 10)与x mod 30可以建立一个一一对应的关系。\n\n再来看看上面用蓝色标出的余数对(也就是能除以3余数为0的那些余数数对），刚好是10对，而且除以10的余数恰好沾满了0到9这十个数字（这同是解释了九九乘法表中，乘以3所在和列的那九个数的个位数正好沾满了1到9这九个数字），这是为什么呢，还记得分水问题中，哪些能准确取出来，哪些不能吗？小伙伴们，是不是同样的道理呀。\n\n \n\n今天还要完成一道题目：\n\n \n\n在银行办理业务的时候，通常我们是要排队的，然后你就要去叫号机取个号，假设号码是由AB这两个个字符组成的3位号码，在每个业务窗口的上方都会有一个LED的跑马灯，显示正在处理哪个号客户的业务。现在，假设在这个LED灯只显示3位的号码，而且灯的长度刚刚好只够显示3个字符。我们都知道跑马灯是循环滚动显示：比如说：刚开始的时候显示的ABB，过一小会儿，然后向左滚动一个字符变成了：BBA，如此滚动，滚动三次后又回到了ABB。假设某个字符串循环移位后才能得到另一个字符串，我们就认为这两个字符串属于同一组字符串。比如刚才那组就是通知字符串（或称同组号码），第一个字符串向左移一位就能第二字符串，问这样的同组字符串一共有多少组，如果号码是由3个、4个……n个字符组成时，一共有多少组呢？（这只是一个题目，实际生活中是不可能的，不然滚动时都不知道是在处理同组号码的哪一个号码）\n\n参考答案：\n\n先看由两个字母生成3位长的号码这种情况，一共可以生成<embed src=\"http://latex.codecogs.com/svg.latex?{\\display 2^{3}}\" type=\"image/svg+xml\" />个字符串，它们分别为：AAA,AAB,ABA,ABB,BAA,BAB,BBA,BBB，AAA和BBB其他字符串是无法通过循环移位得到的，排除掉，AAB可以由ABA和BAA移位得到，ABB可以由BAB和BBA移位得到，从这可以看出三位的号码，不管三位上的字符是什么，同组的字符串都只有3个，因为三位的字符只向同一方向循环移动3次又会回到原来的字符，每移动一次都是同组中的同一个字符串，因此每一组字符串中都只有3个字符串，所以答案是<embed src=\"http://latex.codecogs.com/svg.latex?{\\display (2^{3}-2)\\div 3=2}\" type=\"image/svg+xml\" />，与刚才移动的结论相吻合，当然了这里我故意忽略了一种因素没有考虑，待会再说，接着用这种方式分析可以得出用n个字母成3位长的号码这种情况为<embed src=\"http://latex.codecogs.com/svg.latex?{\\display (n^{3}-n)\\div 3}\" type=\"image/svg+xml\" />；3和4的情况可以用这个通式求得。\n\n现在我们再思考一种情况，如果号码的长度是4，而且跑马灯也刚刚好能显示4个字符，又会怎么样呢？用上面的通式，是不是<embed src=\"http://latex.codecogs.com/svg.latex?{\\display (n^{3}-n)\\div 4}\" type=\"image/svg+xml\" />呢？答案是否定的，应为长度为4的号码，它可能会出现ABAB这种情况，而与这个号码同组的号码只有BABA，没有想上面分析的那样有4个号码，所以除以4这显然是错的，那在什么情况下上面这个通式是正确的呢？我们仔细想一想，如果号码的连续x（x>1，且x<n，n是号码的长度）个字符重复y次之后就是整个号码字符串，这种情况就不满足这个通式，否则，就满足通式。我们再来分析一下这句话“如果号码的连续x（x>1且x<m，m是号码的长度）个字符重复y次之后就是整个号码字符串”，翻译成数学语言就是xy=m，(x>1且x<m)，要不满足这个条件，也就是说m除了能倍1和m整除外，不能倍任何整数整除，也就是说当m为质数的时候才满足通式，由此可得：\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\display (n^{m}-n)\\div m}\" type=\"image/svg+xml\" />是由n个字符组成的m位号码的同组号码的组数，因为是组数所以一定是一个整数值，从而推出：当m为质数时：<embed src=\"http://latex.codecogs.com/svg.latex?{\\display (n^{m}-n)&\\equiv&0(\\mod m)}\" type=\"image/svg+xml\" />，根据同余的性质，将式子等价变换一下得：\n\n当m是质数时：<embed src=\"http://latex.codecogs.com/svg.latex?{\\display (n^{m}&\\equiv&n(\\mod m)}\" type=\"image/svg+xml\" />，这就是费马小定理。根据性质：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}a&\\equiv&b(\\mod m)\\\\c&\\equiv&d(\\mod m)\\end{aligned}\\right\\}\\Rightarrow a\\bullet c&\\equiv&b\\bullet d(\\mod m)}\" type=\"image/svg+xml\" />，\n由于：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}n^{m}&\\equiv&n(\\mod m)\\\\n&\\equiv&n(\\mod m)\\end{aligned}\\right\\}\\Rightarrow n^{m}\\bullet n&\\equiv&n\\bullet n(\\mod m)}\" type=\"image/svg+xml\" />\n，得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{n^{m+1}&\\equiv&n^{2}(\\mod m)}\" type=\"image/svg+xml\" />\n，同理可得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{n^{m+2}&\\equiv&n^{3}(\\mod m),\\cdots,{n^{2m-2}&\\equiv&n^{m-1}(\\mod m),{n^{m-1}&\\equiv&n^{m}&\\equiv&n(\\mod m)}\" type=\"image/svg+xml\" />\n也就是说，如果 m 是一个质数的话，那么对于任意一个整数 n ，随着 i (<embed src=\"http://latex.codecogs.com/svg.latex?{\\display i\\in \\mathbb{N}^0}\" type=\"image/svg+xml\" />)的增加， n 的 i 次方除以 m 的余数将会呈现出长度为 m – 1 的周期性，这就是费马小定理另一种表述。\n\n现在还有一个问题，如果m不是质数呢？\n\n参考资料：\n1. [跨越千年的RSA算法](http://www.matrix67.com/blog/archives/5100)\n2. [RSA算法原理](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)","source":"_posts/RSA系类（三）：从物不知数到中国剩余定理和费马小定理.md","raw":"title: RSA系类（三）：从物不知数到中国剩余定理和费马小定理\ntags:\n  - RSA算法\n  - 数学\n  - 中国剩余定理\n  - 费马小定理\ncategories:\n  - 算法\ndate: 2015-02-03 23:51:00\n---\n\n\n先对昨天的错误进行修正：“最后，我们求解一下3×n - 5×m=4这个不定方程： 3×2 + 5×(-1)=1两边同时乘以4得：3×8 + 5×(-4)=4，从而得出：n=8，m=-4”，这句话中的m=-4应该改成m=4。\n\n下面进入今天的主题： \n\n#### 3、今有物不知其数，三三数之剩二；五五数之剩三；七七数之剩二。问物几何?\n{% blockquote 维基百科 http://baike.baidu.com/link?url=nUHiJ81_AIP_fx3ebRpG4BJBAkPfOdEkaqfT6g3_A12-soPBRF6fzKSQQRZuvNMDEe7lhfworl2v_TBb9g5Kba 物不知数%}\n中国古代著名算题。原载《孙子算经》卷下第二十六题：“今有物不知其数，三三数之剩二；五五数之剩三；七七数之剩二。问物几何?”当时虽已有了答案23，但它的系统解法是秦九韶在《数书九章·大衍求一术》中给出的。大衍求一术（也称作“中国剩余定理”）是中国古算中最有独创性的成就之一，属现代数论中的一次同余式组问题。\n{% endblockquote %}\n<!--more-->\n\n今天讨论一下中国剩余定理，先把这个‘物不知数’这个问题解决。\n\n参考答案：\n\n先回顾一下分水问题，我们首先对一种简单的情况进行数学抽象，得出要解决分水问题，就要先解出3×n - 5×m=1这个二元不定式，再根据扩展欧几里得算法求得m、n，得出结果，最后总结出：在区间[1,max{a,b}-1]上的a和b的最大公约数的整数倍是能够精确取出来的，这其实就是裴蜀定理。\n\n现在我们把这个数学抽象变化一下，变成这个样子：<embed src=\"http://latex.codecogs.com/svg.latex?{3x\\mod5=1} \" type=\"image/svg+xml\" />，抑或者是：<embed src=\"http://latex.codecogs.com/svg.latex?{3x\\equiv1(\\mod 5)} \" type=\"image/svg+xml\" />，这两个等式都是表示3x除以5的余数为1（如有小伙伴还不明白等式是什么含义请参考[同余](https://zh.wikipedia.org/wiki/同餘)）。由于这两个式子和3×n - 5×m=1都是对分水问题的数学抽象，因此，都可以使用扩展欧几里得算法求解x，请记住这种方法，待会用的着。\n\n先给出同余的概念：当两个整数除以同一个正整数，若得相同余数，则两整数[同余](https://zh.wikipedia.org/wiki/同餘)。\n\n下面几个同余的性质接下来可能用得着：\n\n1）传递性\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}a&\\equiv&b(\\mod m)\\\\b&\\equiv&c(\\mod m)\\end{aligned}\\right\\}\\Rightarrow a\\equiv c(\\mod m)}\" type=\"image/svg+xml\" />\n2）保持基本运算\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}a&\\equiv&b(\\mod m)\\\\c&\\equiv&d(\\mod m)\\end{aligned}\\right\\}\\Rightarrow \\left\\{\\begin{aligned}a\\pm c&\\equiv&b\\pm d(\\mod m)\\\\ac&\\equiv&bd(\\mod m)\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n这性质更可进一步引申成为这样：\n<embed src=\"http://latex.codecogs.com/svg.latex?{a\\equiv b(\\mod m)\\Rightarrow \\left\\{\\begin{aligned}an&\\equiv&bn(\\mod m),\\forall n\\in\\mathbb{Z}\\\\a^{n}&\\equiv&b^{n}(\\mod m),\\forall n \\in \\mathbb{N}^{0}\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n \n好了，开始解题：\n\n以下解题过程中都是针对整数而言，没有特殊说明都是指整数。\n\n设这个整数为x，\n\n根据题意可得：\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{(S):\\left\\{\\begin{aligned}x&\\equiv&2 (\\mod3)\\\\x&\\equiv&3(\\mod5)\\\\x&\\equiv&2(\\mod7)\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n\n我们来思考这么一种情况：\n\n如果一个整数X1满足，X1是5和7的倍数，除以3的余数是2，那么就能推出下面这组同余式：\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}x_1&\\equiv&2 (\\mod3)\\\\x_1&\\equiv&0(\\mod5)\\\\x_1&\\equiv&0(\\mod7)\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n\n同理，整数X2满足，X2是3和7的倍数，除以5的余数是3，整数X3满足，X3是3和5的倍数，除以7的余数是2：\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}x_2&\\equiv&0 (\\mod3)\\\\x_2&\\equiv&3(\\mod5)\\\\x_2&\\equiv&0(\\mod7)\\end{aligned}\\right.}\" type=\"image/svg+xml\" />，<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}x_3&\\equiv&0 (\\mod3)\\\\x_3&\\equiv&0(\\mod5)\\\\x_3&\\equiv&2(\\mod7)\\end{aligned}\\right.}\" type=\"image/svg+xml\" />\n根据\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}a&\\equiv&b(\\mod m)\\\\c&\\equiv&d(\\mod m)\\end{aligned}\\right\\}\\Rightarrow a\\pm c&\\equiv&b\\pm d(\\mod m)}\" type=\"image/svg+xml\" />\n得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}x_1&\\equiv&2(\\mod 3)\\\\x_2&\\equiv&0(\\mod 3)\\end{aligned}\\right\\}\\Rightarrow x_1+ x_2&\\equiv&2+0(\\mod 3)}\" type=\"image/svg+xml\" />，<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}x_1+x_2&\\equiv&2(\\mod 3)\\\\x_3&\\equiv&0(\\mod 3)\\end{aligned}\\right\\}\\Rightarrow x_1+ x_2+x_3&\\equiv&2+0(\\mod 3)}\" type=\"image/svg+xml\" />\n所以：\n<embed src=\"http://latex.codecogs.com/svg.latex?{ x_1+ x_2+x_3&\\equiv&2(\\mod 3)}\" type=\"image/svg+xml\" />；\n同理可得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{ x_1+ x_2+x_3&\\equiv&3(\\mod 5)}\" type=\"image/svg+xml\" />，<embed src=\"http://latex.codecogs.com/svg.latex?{ x_1+ x_2+x_3&\\equiv&2(\\mod 7)}\" type=\"image/svg+xml\" />；\n\n因此，只要我们求得X1+X2+X3就是答案。现在我们来看一下X1怎么求解吧：\n\n根据\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}x_1&\\equiv&2 (\\mod3)\\\\x_1&\\equiv&0(\\mod5)\\\\x_1&\\equiv&0(\\mod7)\\end{aligned}\\right.}\" type=\"image/svg+xml\" />等价于<embed src=\"http://latex.codecogs.com/svg.latex?{5\\times 7\\times x_1^{'}&\\equiv&2(\\mod 3)}\" type=\"image/svg+xml\" />，因此只要求出x1'即可求出答案，这个时候就得用上扩展欧几里得算法求出x1'，哈哈，整个人都神清气爽了有木有。我们再把上面等式翻译成分水问题，有35升和3升无刻度的两个容器，现在只能用35升的容器取水，3升的容器倒水，请精确取出2升水。\n\n我们还是根据扩展欧几里得算法得出：\n\n3×12 + 35×(-1) =1，这个结果好像不对头，它是用3升的容器取水，35升容器倒水的结果，那该怎么办呢？很简单等式两边同时乘以-1，就变成了35升的容器取水，3升的容器倒水，第12次倒水后得-1，这明显不可能，少倒一次水，剩下的就正好是2升水，所以x1'=1。\n\n同理求出<embed src=\"http://latex.codecogs.com/svg.latex?{ x_2^{'}=3,x_3^{'}=2}\" type=\"image/svg+xml\" />；\n\n从而得出<embed src=\"http://latex.codecogs.com/svg.latex?{ x_1=35,x_2=63,x_3=30}\" type=\"image/svg+xml\" />，\n\n最后得出x=X1+X2+X3=128，\n\n这个地方碰巧，很容易能取出2升水，我们还是按照我们先取出1升，让后再根据倍数关系，求得2升水吧，这样的话更具有规律性。\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}35\\times 1+3\\times (-12)&=&-1\\\\35\\times 1+3\\times(-11)&=&2\\end{aligned}\\right\\}\\Rightarrow 35\\times 2+3\\times (-23)=1}\" type=\"image/svg+xml\" />，从而x1'=2×2=4，同理得x2'=3，x3'=2，此时我们称x1'、x2'、x3'为模逆元，由于它们形如：<embed src=\"http://latex.codecogs.com/svg.latex?{x_1^{'}\\times M&\\equiv&1(\\mod m)}\" type=\"image/svg+xml\" />，所以也称为数论倒数；\n\n从而得出x1=140，x2=63，x3=30，\n\n最后得出x=X1+X2+X3=233，\n\n聪明的小伙伴立刻明白答案不止一个，23也是对的，而且还有无数多个解，下面进一步说明一下：\n\n由于3,5,7这三个数是两两互质，所以它们的最小公倍数是3×5×7=105,105显然能同时整除3,5,7。根据下面这个性质：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}a&\\equiv&b(\\mod m)\\\\c&\\equiv&d(\\mod m)\\end{aligned}\\right\\}\\Rightarrowa\\pm c&\\equiv&b\\pm d(\\mod m)}\" type=\"image/svg+xml\" />\nx+k×105显然还是满足\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left\\{\\begin{aligned}x+k\\times 105&\\equiv&2(\\mod 3)\\\\x+k\\times 105&\\equiv&3(\\mod 5)\\\\x+k\\times 105&\\equiv&2(\\mod 7)\\end{aligned}\\right.}\" type=\"image/svg+xml\" />,\n因此，这个问题的通解是：<embed src=\"http://latex.codecogs.com/svg.latex?{23+k\\times 105,k\\in\\mathbb{Z}}\" type=\"image/svg+xml\" />。\n\nOk，解题完毕，物不知数就是中国剩余定理的一个实例。现在来看孙子定理也就是中国剩余定理：给出 i 个两两互质的整数，记为<embed src=\"http://latex.codecogs.com/svg.latex?{\\display m_1,m_2,m_3,\\cdots,m_i}\" type=\"image/svg+xml\" />，它们的乘积为 P ；假设有一个未知数 M ，如果我们已知 M 分别除以这 m 个数所得的余数，记为<embed src=\"http://latex.codecogs.com/svg.latex?{\\display r_1,r_2,r_3,\\cdots,r_i}\" type=\"image/svg+xml\" />那么在 0 到 P–1 的范围内，我们可以唯一地确定这个 M 。现代数学语言的描述，我就不贴了，有兴趣的同学就自己看wiki吧。\n\n我们从定义里面可以看出中国剩余定理有以下两点特性：\n\n1.当的整数时<embed src=\"http://latex.codecogs.com/svg.latex?{M\\in[0,P-1]}\" type=\"image/svg+xml\" />每一组余数（记为：<embed src=\"http://latex.codecogs.com/svg.latex?{\\display r_1,r_2,r_3,\\cdots,r_i}\" type=\"image/svg+xml\" />）都有唯一的一个M与之对应，而且每一个M也只有一组余数与之对应，即M与<embed src=\"http://latex.codecogs.com/svg.latex?{\\display r_1,r_2,r_3,\\cdots,r_i}\" type=\"image/svg+xml\" />是一一对应关系，由于M的取值恰好是任意整数对P求余的余数，所以结论也可以表述为任意整数对P的余数与<embed src=\"http://latex.codecogs.com/svg.latex?{\\display r_1,r_2,r_3,\\cdots,r_i}\" type=\"image/svg+xml\" />是一一对应关系；\n\n2.在<embed src=\"http://latex.codecogs.com/svg.latex?{m\\in\\mathbb{Z}}\" type=\"image/svg+xml\" />，如果余数数组看作m的一个函数，那么函数呈现周期性，且m的最小正周期是P。\n\n \n\n下面举个例：\n\n2个互质的整数3和10，它们的乘积是30，那么在[0,29]区间内的数，分别处以3和10的余数如下表所示：\n\n| i        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n| :-------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| i mod 3  | 0 | 1 | 2 | 0 | 1 | 2 | 0 | 1 | 2 | 0 |\n| i mod 10 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n| i        | 10| 11| 12| 13| 14| 15| 16| 17| 18| 19|\n| i mod 3  | 1 | 2 | 0 | 1 | 2 | 0 | 1 | 2 | 0 | 1 |\n| i mod 10 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n| i        | 20| 21| 22| 23| 24| 25| 26| 27| 28| 29|\n| i mod 3  | 2 | 0 | 1 | 2 | 0 | 1 | 2 | 0 | 1 | 2 |\n| i mod 10 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n\n\n由除以3的余数与除以10的余数组成的余数对没有出现重复现象，而且，整数M对30取模它的余数就是上表中i的取值，这就表明若果已知两个互质的整数3和10，可知它们的最小公倍数，记为gcd(3,10)，易得gcd(3,10)=3×10=30，此时，余数数对(x mod 3 , x mod 10)与x mod 30可以建立一个一一对应的关系。\n\n再来看看上面用蓝色标出的余数对(也就是能除以3余数为0的那些余数数对），刚好是10对，而且除以10的余数恰好沾满了0到9这十个数字（这同是解释了九九乘法表中，乘以3所在和列的那九个数的个位数正好沾满了1到9这九个数字），这是为什么呢，还记得分水问题中，哪些能准确取出来，哪些不能吗？小伙伴们，是不是同样的道理呀。\n\n \n\n今天还要完成一道题目：\n\n \n\n在银行办理业务的时候，通常我们是要排队的，然后你就要去叫号机取个号，假设号码是由AB这两个个字符组成的3位号码，在每个业务窗口的上方都会有一个LED的跑马灯，显示正在处理哪个号客户的业务。现在，假设在这个LED灯只显示3位的号码，而且灯的长度刚刚好只够显示3个字符。我们都知道跑马灯是循环滚动显示：比如说：刚开始的时候显示的ABB，过一小会儿，然后向左滚动一个字符变成了：BBA，如此滚动，滚动三次后又回到了ABB。假设某个字符串循环移位后才能得到另一个字符串，我们就认为这两个字符串属于同一组字符串。比如刚才那组就是通知字符串（或称同组号码），第一个字符串向左移一位就能第二字符串，问这样的同组字符串一共有多少组，如果号码是由3个、4个……n个字符组成时，一共有多少组呢？（这只是一个题目，实际生活中是不可能的，不然滚动时都不知道是在处理同组号码的哪一个号码）\n\n参考答案：\n\n先看由两个字母生成3位长的号码这种情况，一共可以生成<embed src=\"http://latex.codecogs.com/svg.latex?{\\display 2^{3}}\" type=\"image/svg+xml\" />个字符串，它们分别为：AAA,AAB,ABA,ABB,BAA,BAB,BBA,BBB，AAA和BBB其他字符串是无法通过循环移位得到的，排除掉，AAB可以由ABA和BAA移位得到，ABB可以由BAB和BBA移位得到，从这可以看出三位的号码，不管三位上的字符是什么，同组的字符串都只有3个，因为三位的字符只向同一方向循环移动3次又会回到原来的字符，每移动一次都是同组中的同一个字符串，因此每一组字符串中都只有3个字符串，所以答案是<embed src=\"http://latex.codecogs.com/svg.latex?{\\display (2^{3}-2)\\div 3=2}\" type=\"image/svg+xml\" />，与刚才移动的结论相吻合，当然了这里我故意忽略了一种因素没有考虑，待会再说，接着用这种方式分析可以得出用n个字母成3位长的号码这种情况为<embed src=\"http://latex.codecogs.com/svg.latex?{\\display (n^{3}-n)\\div 3}\" type=\"image/svg+xml\" />；3和4的情况可以用这个通式求得。\n\n现在我们再思考一种情况，如果号码的长度是4，而且跑马灯也刚刚好能显示4个字符，又会怎么样呢？用上面的通式，是不是<embed src=\"http://latex.codecogs.com/svg.latex?{\\display (n^{3}-n)\\div 4}\" type=\"image/svg+xml\" />呢？答案是否定的，应为长度为4的号码，它可能会出现ABAB这种情况，而与这个号码同组的号码只有BABA，没有想上面分析的那样有4个号码，所以除以4这显然是错的，那在什么情况下上面这个通式是正确的呢？我们仔细想一想，如果号码的连续x（x>1，且x<n，n是号码的长度）个字符重复y次之后就是整个号码字符串，这种情况就不满足这个通式，否则，就满足通式。我们再来分析一下这句话“如果号码的连续x（x>1且x<m，m是号码的长度）个字符重复y次之后就是整个号码字符串”，翻译成数学语言就是xy=m，(x>1且x<m)，要不满足这个条件，也就是说m除了能倍1和m整除外，不能倍任何整数整除，也就是说当m为质数的时候才满足通式，由此可得：\n\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\display (n^{m}-n)\\div m}\" type=\"image/svg+xml\" />是由n个字符组成的m位号码的同组号码的组数，因为是组数所以一定是一个整数值，从而推出：当m为质数时：<embed src=\"http://latex.codecogs.com/svg.latex?{\\display (n^{m}-n)&\\equiv&0(\\mod m)}\" type=\"image/svg+xml\" />，根据同余的性质，将式子等价变换一下得：\n\n当m是质数时：<embed src=\"http://latex.codecogs.com/svg.latex?{\\display (n^{m}&\\equiv&n(\\mod m)}\" type=\"image/svg+xml\" />，这就是费马小定理。根据性质：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}a&\\equiv&b(\\mod m)\\\\c&\\equiv&d(\\mod m)\\end{aligned}\\right\\}\\Rightarrow a\\bullet c&\\equiv&b\\bullet d(\\mod m)}\" type=\"image/svg+xml\" />，\n由于：\n<embed src=\"http://latex.codecogs.com/svg.latex?{\\left.\\begin{aligned}n^{m}&\\equiv&n(\\mod m)\\\\n&\\equiv&n(\\mod m)\\end{aligned}\\right\\}\\Rightarrow n^{m}\\bullet n&\\equiv&n\\bullet n(\\mod m)}\" type=\"image/svg+xml\" />\n，得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{n^{m+1}&\\equiv&n^{2}(\\mod m)}\" type=\"image/svg+xml\" />\n，同理可得：\n<embed src=\"http://latex.codecogs.com/svg.latex?{n^{m+2}&\\equiv&n^{3}(\\mod m),\\cdots,{n^{2m-2}&\\equiv&n^{m-1}(\\mod m),{n^{m-1}&\\equiv&n^{m}&\\equiv&n(\\mod m)}\" type=\"image/svg+xml\" />\n也就是说，如果 m 是一个质数的话，那么对于任意一个整数 n ，随着 i (<embed src=\"http://latex.codecogs.com/svg.latex?{\\display i\\in \\mathbb{N}^0}\" type=\"image/svg+xml\" />)的增加， n 的 i 次方除以 m 的余数将会呈现出长度为 m – 1 的周期性，这就是费马小定理另一种表述。\n\n现在还有一个问题，如果m不是质数呢？\n\n参考资料：\n1. [跨越千年的RSA算法](http://www.matrix67.com/blog/archives/5100)\n2. [RSA算法原理](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)","slug":"RSA系类（三）：从物不知数到中国剩余定理和费马小定理","published":1,"updated":"2016-07-14T02:47:23.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw5k002mtkb92kfk23ec"},{"title":"RSA系类（一）：辗转相除法","date":"2015-02-01T14:12:00.000Z","_content":"\n\n发现最近自己也是挺颓的，没做出任何一件能让自己会心一笑的事，于是乎准备着报复那些比我过的好的小伙伴 ，三思之后最终决定用一种最歹毒的精神折磨来报复乃们----颤抖吧地球人，也让那些没事整天在QQ空间和微信朋友圈摆地摊卖东西的小伙伴们感受一下打开QQ空间那种铺天盖地的无聊数学题的折磨。现在肯定有小伙伴们在底下指着我的头像骂我吧，“我跟你什么仇什么冤”。Ok，发疯完毕进入主题。\n\n \n\n有没有小伙伴想知道我弄这些无聊的数学题做什么？\n\n``` bash\n// 温馨提示：本文只写个对数学或者计算机感兴趣的小伙伴们\nif(你想知道)\n   请安静地接着往下看;\nelse\n   请安静地离开，我不想浪费你宝贵的时间;\n```\n<!--more-->\n\n现在，我们先把那些数学题目一个一个的解答一下：\n\n#### 1、有两条长分别为210cm和165cm的无刻度的木条a和b，怎样确定一条木条c，使得a和b的长度刚刚好是整数倍个c的长度（可以无限制使用无刻度的木条）？\n\n参考答案：\n\na是c整数倍，b也是c的整数倍，于是这道题目可以简化成求a和b的公因数。我们很容易就能得出a和b的公因数是1、3、5、15，其中15是最大公因数，现在最大的问题是如何用没有刻度的木条得出这些长度呢？此时，我想起了辗转相除法求最大公因数，说到这不知道各位小伙伴有没有自己去看过关于辗转相除法的来历，记得第一次接触这个方法好像是在VB程序设计这门课上（也是我学的第一门编程语言），当时感觉很神奇，为什么小学老师没有教我们这个方法呢，于是自己去查看了一下[这个方法](https://zh.wikipedia.org/wiki/輾轉相除法)。下面是解题过程：\n1）用210 ÷165=1 ···45（余数）；\n\n2）用165÷45=3···30（余数）；\n\n3）用45÷30=1···15（余数）；\n\n4）用30÷15=2···0（余数）；\n\n此时的第四步中的除数15就是210和165的最大公约数，顺带说一下210和165的最小公倍数就是（210×165）÷15=2310。那怎么用无刻度的木条确定出15cm这个长度来呢？请看图：\n\n{% asset_img 图一.png 图一 %} \n\n\n现在我们就得到了15cm的木条c，那其它的长度有没有办法得到呢？我感觉上是没办法得到，不知道聪明的小伙伴们有没有更巧妙的方法能得出来呢？这道题目就这样解决了，不知道小学老师为什么不教我们这个方法。这里有一点是要注意的，辗转相除法有时候会失效的，那是什么时候呢？想象一下这样一种场景，当上一次的被除数与除数的比值等于除数与余数的比值时会出现什么样的一个场景。它应该会出现这样一种场景：从前有座山，山里有座面，庙里有个老和尚和小和尚，老和尚正在跟小和尚讲故事：“从前有座山，山里有座面，庙里有个老和尚和小和尚，老和尚正在跟小和尚讲故事：‘从前有座山，山里有座面，庙里有个老和尚和小和尚，老和尚正在跟小和尚讲故事：……’”。这就是那个没有终结条件的死递归。顺便提一下，这个时候被除数和除数的比例关系正好满足黄金分割比例1：0.618，而且出现了无理数，这不是公因数的范畴了，而是一种更加广的倍数数关系，或者用欧几里德的《几何原本》中的公度的概念更为准确。\n\n\n参考资料：\n1. [跨越千年的RSA算法](http://www.matrix67.com/blog/archives/5100)\n2. [RSA算法原理](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)","source":"_posts/RSA系类（一）：辗转相除法.md","raw":"title: RSA系类（一）：辗转相除法\ntags:\n  - RSA算法\n  - 数学\n  - 辗转相除法\ncategories:\n  - 算法\ndate: 2015-02-01 22:12:00\n---\n\n\n发现最近自己也是挺颓的，没做出任何一件能让自己会心一笑的事，于是乎准备着报复那些比我过的好的小伙伴 ，三思之后最终决定用一种最歹毒的精神折磨来报复乃们----颤抖吧地球人，也让那些没事整天在QQ空间和微信朋友圈摆地摊卖东西的小伙伴们感受一下打开QQ空间那种铺天盖地的无聊数学题的折磨。现在肯定有小伙伴们在底下指着我的头像骂我吧，“我跟你什么仇什么冤”。Ok，发疯完毕进入主题。\n\n \n\n有没有小伙伴想知道我弄这些无聊的数学题做什么？\n\n``` bash\n// 温馨提示：本文只写个对数学或者计算机感兴趣的小伙伴们\nif(你想知道)\n   请安静地接着往下看;\nelse\n   请安静地离开，我不想浪费你宝贵的时间;\n```\n<!--more-->\n\n现在，我们先把那些数学题目一个一个的解答一下：\n\n#### 1、有两条长分别为210cm和165cm的无刻度的木条a和b，怎样确定一条木条c，使得a和b的长度刚刚好是整数倍个c的长度（可以无限制使用无刻度的木条）？\n\n参考答案：\n\na是c整数倍，b也是c的整数倍，于是这道题目可以简化成求a和b的公因数。我们很容易就能得出a和b的公因数是1、3、5、15，其中15是最大公因数，现在最大的问题是如何用没有刻度的木条得出这些长度呢？此时，我想起了辗转相除法求最大公因数，说到这不知道各位小伙伴有没有自己去看过关于辗转相除法的来历，记得第一次接触这个方法好像是在VB程序设计这门课上（也是我学的第一门编程语言），当时感觉很神奇，为什么小学老师没有教我们这个方法呢，于是自己去查看了一下[这个方法](https://zh.wikipedia.org/wiki/輾轉相除法)。下面是解题过程：\n1）用210 ÷165=1 ···45（余数）；\n\n2）用165÷45=3···30（余数）；\n\n3）用45÷30=1···15（余数）；\n\n4）用30÷15=2···0（余数）；\n\n此时的第四步中的除数15就是210和165的最大公约数，顺带说一下210和165的最小公倍数就是（210×165）÷15=2310。那怎么用无刻度的木条确定出15cm这个长度来呢？请看图：\n\n{% asset_img 图一.png 图一 %} \n\n\n现在我们就得到了15cm的木条c，那其它的长度有没有办法得到呢？我感觉上是没办法得到，不知道聪明的小伙伴们有没有更巧妙的方法能得出来呢？这道题目就这样解决了，不知道小学老师为什么不教我们这个方法。这里有一点是要注意的，辗转相除法有时候会失效的，那是什么时候呢？想象一下这样一种场景，当上一次的被除数与除数的比值等于除数与余数的比值时会出现什么样的一个场景。它应该会出现这样一种场景：从前有座山，山里有座面，庙里有个老和尚和小和尚，老和尚正在跟小和尚讲故事：“从前有座山，山里有座面，庙里有个老和尚和小和尚，老和尚正在跟小和尚讲故事：‘从前有座山，山里有座面，庙里有个老和尚和小和尚，老和尚正在跟小和尚讲故事：……’”。这就是那个没有终结条件的死递归。顺便提一下，这个时候被除数和除数的比例关系正好满足黄金分割比例1：0.618，而且出现了无理数，这不是公因数的范畴了，而是一种更加广的倍数数关系，或者用欧几里德的《几何原本》中的公度的概念更为准确。\n\n\n参考资料：\n1. [跨越千年的RSA算法](http://www.matrix67.com/blog/archives/5100)\n2. [RSA算法原理](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)","slug":"RSA系类（一）：辗转相除法","published":1,"updated":"2016-07-13T07:11:28.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw5p002ttkb963cqqvqt"},{"title":"Github个人静态博客的搭建总结","date":"2015-02-01T09:31:06.000Z","_content":"\n在搭建博客中出现了不少问题，在此分享一下个人的博客搭建过程：\n\n\n### 第一步：想不花钱就把事情给办了\n俗话说：想不花钱，就把事情给办了，你的找一个有钱有势的主。同样的，如果你想要有一个独立的博客，又不想自己掏钱和投入经历去维护，那么你的找一个有优势的主，这当然是首推[全球最大的男性同性交友平台 github](http://www.zhihu.com/question/28976652/answer/42771650)(*^__^*) ，至于怎么注册，怎么设置，直接看官网[帮助文档](https://help.github.com/)。\n<!--more-->\n### 第二步：hexo —— 简单、快速、强大的Node.js静态博客框架\nHexo的安装和配置请参考**Heaven**的[《使用Hexo搭建GitHub个人博客》](http://heavenru.com/2015/09/02/使用Hexo搭建GitHub个人博客/)，由于Heaven大神一直是在搞前端的，博文里没有提到node.js的安装，这个就是下载，下一步的事，也不详陈了。\n\n---\n\n### 总结遇到的问题\n\n注意：以下操作都是基于windows7！！！\n\n1、在git bash客户端，使用ssh方式进行clone和push时，每次关闭重开git bash客户端总是出现如下错误：\n\n``` bash\n$ git clone git@github.com:xiaorisu/github-roam.git\nCloning into 'github-roam'...\nPermission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n之前一直是手动输入如下两句代码来解决此问题：\n\n``` bash\neval $(ssh-agent -s)\nssh-add ~/.ssh/xxxx\n```\n\n我是一个懒人，每次都要这样手动输入这两行代码，我会很烦躁，于是有了下面的解决方案：\n在当前用户目录底下新建一个.bash_profile文件，不要问我当前用户的目录是哪个目录，一般是打开cmd之后，光标之前的路劲就是当前用户目录。当然，如果你设置过默认打开路径，那就是另一回事了，这时你可以使用如下命令得到：\n\n``` bash\necho %systemdrive%%homepath%\n```\n\n创建好了.bash_profile文件后，在文件中输入如下代码：\n\n``` bash\neval $(ps | grep 'ssh-agent' | awk '{print $1}' | xargs kill -9)\neval $(ssh-agent -s)\nssh-add ~/.ssh/XXXXX\n```\n\n保存文件，此文件会在每次打开git bash时加载并运行其中的命令。解释一下这三条命令的含义：第一句是杀死之前开的所有ssh-agent，由于每次打开都会执行两编这里面的命令，没有去查是什么原因导致的。并且每次关闭了git bash客户端，都不会关闭它打开的ssh-agent程序；第二句是开启ssh-agent服务；第三句是将专用密钥添加到ssh-agent的高速缓存中。\n\n---\n\n2、执行hexo s 命令后，在浏览器中输入localhost:4000半天没有响应，最后无法访问生成的静态页面。\n\n这个问题的原因在于4000端口被FxServer占用了，但是hexo-server没有报错，真是郁闷！！！解决这问题很简单，可以关掉FxServer服务，也可使用hexo s -p 4040即可解决。解决这个问题并不困难，我要说的是怎么找到问题的原因的。\n首先使用netstat命令查看当前电脑的网络连接状况：\n\n``` bash\nC:\\Users\\lenovo>netstat -ano | findstr \"4000\"\n  TCP    0.0.0.0:4000           0.0.0.0:0              LISTENING       21908\n  TCP    127.0.0.1:4000         0.0.0.0:0              LISTENING       17620\n  TCP    127.0.0.1:4000         127.0.0.1:4737         CLOSE_WAIT      17620\n  TCP    127.0.0.1:4000         127.0.0.1:4738         ESTABLISHED     17620\n  TCP    127.0.0.1:4000         127.0.0.1:4739         ESTABLISHED     17620\n  TCP    127.0.0.1:4000         127.0.0.1:4740         CLOSE_WAIT      17620\n  TCP    127.0.0.1:4000         127.0.0.1:4741         CLOSE_WAIT      17620\n  TCP    127.0.0.1:4000         127.0.0.1:4742         CLOSE_WAIT      17620\n  TCP    127.0.0.1:4000         127.0.0.1:4755         ESTABLISHED     17620\n  TCP    127.0.0.1:4737         127.0.0.1:4000         FIN_WAIT_2      556\n  TCP    127.0.0.1:4738         127.0.0.1:4000         ESTABLISHED     556\n  TCP    127.0.0.1:4739         127.0.0.1:4000         ESTABLISHED     556\n  TCP    127.0.0.1:4740         127.0.0.1:4000         FIN_WAIT_2      556\n  TCP    127.0.0.1:4741         127.0.0.1:4000         FIN_WAIT_2      556\n  TCP    127.0.0.1:4742         127.0.0.1:4000         FIN_WAIT_2      556\n  TCP    127.0.0.1:4755         127.0.0.1:4000         ESTABLISHED     556\n```\n\n发现4000端口有很多连接，发现有两个进程在监听4000端口，pid分别是21908和17620，从任务管理器中可以看到这两个pid对应的进程分别是node.exe和FxServer服务。这就是查找问题的过程。\n\n---\n\n### 最后说一下改进\n\n最后说一说多仓库部署和源代码自动备份以及自动打开Markdown编辑器。\n\n先上我的_config.yml文件：\n\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: 翰海尘沙\nsubtitle: 进击的程序员\ndescription: 技术分享、阅读笔记\nauthor: 翰海尘沙\nlanguage: zh-CN\ntimezone:\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yourgithubname.github.io\nroot: /blog/\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Extensions\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\ntheme: landscape\n#theme: leo\n\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository:\n    github: git@github.com:your_repository,gh-pages\n    gitcafe: git@gitcafe.com:your_repository,gitcafe-pages\n# 自动备份\nbackup:\n  type: git\n  repo: \n    github: git@github.com:your_repository,master\n    gitcafe: git@gitcafe.com:your_repository,master\n\n# 评论\n# 1.友言\n#uyan:\n#  enable: true\n# 2.多说\n#duoshuo_shortname: shortname\n# 3.畅言\nchangyan:\n  enable: true\n\n# RSS订阅\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 10\n\n# 网站地图\nsitemap:\n    path: sitemap.xml\n```\n\n多仓库部署比较简单，只要在_config.yml配置成如下：\n\n```\ndeploy:\n  type: git\n  repository:\n    github: git@github.com:your_repository,gh-pages\n    gitcafe: git@gitcafe.com:your_repository,gitcafe-pages\n```\n\n使用hexo d命令就可以自动部署到github和gitcafe上去。\n\n多仓自动库备份稍微复杂些，先在配置文件中自定自己的自动备份的配置：\n\n```\nbackup:\n  type: git\n  repo: \n    github: git@github.com:your_repository,master\n    gitcafe: git@gitcafe.com:your_repository,master\n```\n\n然后在博客源代码的项目根目录下的scripts目录（如果没有就新建一个scripes文件夹）中新建一个任意名字的javascript文件。我新建的是一个AutoBackUp.js，添加如下代码：\n\n``` JavaScript\nrequire('shelljs/global');\n\nvar parseConfig = require('hexo-deployer-git/lib/parse_config');\nvar util = require('hexo/node_modules/hexo-util');\nvar Promise = require('hexo/node_modules/bluebird');\nvar spawn = util.spawn;\n\ntry {\n    hexo.on('deployAfter', function() {\n        run();\n    });\n} catch (e) {\n    console.log(\"备份出现异常，详细信息\" + e.toString());\n}\n\nfunction git() {\n    var len = arguments.length;\n    var args = new Array(len);\n\n    for (var i = 0; i < len; i++) {\n        args[i] = arguments[i];\n    }\n\n    return spawn('git', args, {\n        cwd: hexo.base_dir,\n        verbose: !hexo.config.backup.silent\n    });\n}\n\nfunction push(repo) {\n    return git('add', '-A').then(function() {\n        return git('commit', '-m', \"Form auto backup script\\'s commit\").catch(function() {\n            // Do nothing. It's OK if nothing to commit.\n        });\n    }).then(function() {\n        return git('push', '-u', repo.url, 'master:' + repo.branch, '--force');\n    });\n}\n\nfunction run() {\n    if (!which('git')) {\n        echo('Sorry, this script require git');\n    } else {\n        echo(\"=======================Auto Backup Begin=======================\");\n        Promise.each(parseConfig(hexo.config.backup),function(repo){\n            return push(repo);\n        });\n        echo(\"=======================Auto Backup Complete======================\");\n    }\n}\n\n```\n\n还要安装shelljs模块，这样每次执行hexo d后就会自动备份到githu和gitcafe代码仓库。\n\n自动打开Markdown编辑器，同样在srcipt目录中添加一个OpenEditor.js文件，代码如下：\n``` JavaScript\nvar exec = require('child_process').exec;\nvar parseConfig = require('./parse_config');\n// Hexo 2.x 用户复制这段\n// hexo.on('new', function(path){\n// exec('start  \"D:\\\\Program Files\\\\Sublime Text 3\\\\sublime_text.exe\" ' + path);\n// });\n\n// Hexo 3 用户复制这段\nhexo.on('new', function(data) {\n    //exec('start  /max \"\" \"D:\\\\Program Files\\\\Sublime Text 3\\\\sublime_text.exe\" ' + data.path);\n    exec('start  /max \"\" \"D:\\\\Program Files\\\\MarkdownPad 2\\\\MarkdownPad2.exe\" ' + data.path);\n});\n\n/*=================windows code end======================*/\n\n\n///*********************************************************\n// *                 linux   代码                          *\n// *********************************************************/\n//\n//var exec = require('child_process').exec;\n//\n//// Hexo 2.x\n//hexo.on('new', function(path){\n//  exec('vi', [path]);\n//});\n//\n//// Hexo 3\n//hexo.on('new', function(data){\n//  exec('vi', [data.path]);\n//});\n//\n///*=================linux  code  end======================*/\n//\n///*********************************************************\n// *                 mac     代码                          *\n// *********************************************************/\n//\n//var exec = require('child_process').exec;\n//\n//// Hexo 2.x 用户复制这段\n//hexo.on('new', function(path){\n//    exec('open -a \"markdown编辑器绝对路径.app\" ' + path);\n//});\n//// Hexo 3 用户复制这段\n//hexo.on('new', function(data){\n//    exec('open -a \"markdown编辑器绝对路径.app\" ' + data.path);\n//});\n///*=================mac    code  end======================*/\n\n```\n\n在windows7下是亲测可以打开，至于Mac和Linux没测试过，不敢保证可以用。\n\n---\n\n参考博文：\n\n1. [younglaker的《Hexo系列博客》](http://laker.me/blog/categories/Hexo/)\n2. [夏末的《Hexo添加文章时自动打开编辑器》](http://notes.xiamo.tk/2015-06-29-Hexo添加文章时自动打开编辑器.html)\n3. [夏末的《自动备份Hexo博客源文件》](http://notes.xiamo.tk/2015-07-06-自动备份Hexo博客源文件.html)\n4. [Heaven的《使用Hexo搭建GitHub个人博客》](http://heavenru.com/2015/09/02/使用Hexo搭建GitHub个人博客/)\n5. [github高亮语言关键字](https://github.com/github/linguist/blob/master/lib/linguist/languages.yml)","source":"_posts/Github个人静态博客的搭建.md","raw":"title: Github个人静态博客的搭建总结\ndate: 2015-02-01 17:31:06\ntags:\n - 教程\n - 总结\n - Hexo\ncategories:\n - Hexo\n---\n\n在搭建博客中出现了不少问题，在此分享一下个人的博客搭建过程：\n\n\n### 第一步：想不花钱就把事情给办了\n俗话说：想不花钱，就把事情给办了，你的找一个有钱有势的主。同样的，如果你想要有一个独立的博客，又不想自己掏钱和投入经历去维护，那么你的找一个有优势的主，这当然是首推[全球最大的男性同性交友平台 github](http://www.zhihu.com/question/28976652/answer/42771650)(*^__^*) ，至于怎么注册，怎么设置，直接看官网[帮助文档](https://help.github.com/)。\n<!--more-->\n### 第二步：hexo —— 简单、快速、强大的Node.js静态博客框架\nHexo的安装和配置请参考**Heaven**的[《使用Hexo搭建GitHub个人博客》](http://heavenru.com/2015/09/02/使用Hexo搭建GitHub个人博客/)，由于Heaven大神一直是在搞前端的，博文里没有提到node.js的安装，这个就是下载，下一步的事，也不详陈了。\n\n---\n\n### 总结遇到的问题\n\n注意：以下操作都是基于windows7！！！\n\n1、在git bash客户端，使用ssh方式进行clone和push时，每次关闭重开git bash客户端总是出现如下错误：\n\n``` bash\n$ git clone git@github.com:xiaorisu/github-roam.git\nCloning into 'github-roam'...\nPermission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n之前一直是手动输入如下两句代码来解决此问题：\n\n``` bash\neval $(ssh-agent -s)\nssh-add ~/.ssh/xxxx\n```\n\n我是一个懒人，每次都要这样手动输入这两行代码，我会很烦躁，于是有了下面的解决方案：\n在当前用户目录底下新建一个.bash_profile文件，不要问我当前用户的目录是哪个目录，一般是打开cmd之后，光标之前的路劲就是当前用户目录。当然，如果你设置过默认打开路径，那就是另一回事了，这时你可以使用如下命令得到：\n\n``` bash\necho %systemdrive%%homepath%\n```\n\n创建好了.bash_profile文件后，在文件中输入如下代码：\n\n``` bash\neval $(ps | grep 'ssh-agent' | awk '{print $1}' | xargs kill -9)\neval $(ssh-agent -s)\nssh-add ~/.ssh/XXXXX\n```\n\n保存文件，此文件会在每次打开git bash时加载并运行其中的命令。解释一下这三条命令的含义：第一句是杀死之前开的所有ssh-agent，由于每次打开都会执行两编这里面的命令，没有去查是什么原因导致的。并且每次关闭了git bash客户端，都不会关闭它打开的ssh-agent程序；第二句是开启ssh-agent服务；第三句是将专用密钥添加到ssh-agent的高速缓存中。\n\n---\n\n2、执行hexo s 命令后，在浏览器中输入localhost:4000半天没有响应，最后无法访问生成的静态页面。\n\n这个问题的原因在于4000端口被FxServer占用了，但是hexo-server没有报错，真是郁闷！！！解决这问题很简单，可以关掉FxServer服务，也可使用hexo s -p 4040即可解决。解决这个问题并不困难，我要说的是怎么找到问题的原因的。\n首先使用netstat命令查看当前电脑的网络连接状况：\n\n``` bash\nC:\\Users\\lenovo>netstat -ano | findstr \"4000\"\n  TCP    0.0.0.0:4000           0.0.0.0:0              LISTENING       21908\n  TCP    127.0.0.1:4000         0.0.0.0:0              LISTENING       17620\n  TCP    127.0.0.1:4000         127.0.0.1:4737         CLOSE_WAIT      17620\n  TCP    127.0.0.1:4000         127.0.0.1:4738         ESTABLISHED     17620\n  TCP    127.0.0.1:4000         127.0.0.1:4739         ESTABLISHED     17620\n  TCP    127.0.0.1:4000         127.0.0.1:4740         CLOSE_WAIT      17620\n  TCP    127.0.0.1:4000         127.0.0.1:4741         CLOSE_WAIT      17620\n  TCP    127.0.0.1:4000         127.0.0.1:4742         CLOSE_WAIT      17620\n  TCP    127.0.0.1:4000         127.0.0.1:4755         ESTABLISHED     17620\n  TCP    127.0.0.1:4737         127.0.0.1:4000         FIN_WAIT_2      556\n  TCP    127.0.0.1:4738         127.0.0.1:4000         ESTABLISHED     556\n  TCP    127.0.0.1:4739         127.0.0.1:4000         ESTABLISHED     556\n  TCP    127.0.0.1:4740         127.0.0.1:4000         FIN_WAIT_2      556\n  TCP    127.0.0.1:4741         127.0.0.1:4000         FIN_WAIT_2      556\n  TCP    127.0.0.1:4742         127.0.0.1:4000         FIN_WAIT_2      556\n  TCP    127.0.0.1:4755         127.0.0.1:4000         ESTABLISHED     556\n```\n\n发现4000端口有很多连接，发现有两个进程在监听4000端口，pid分别是21908和17620，从任务管理器中可以看到这两个pid对应的进程分别是node.exe和FxServer服务。这就是查找问题的过程。\n\n---\n\n### 最后说一下改进\n\n最后说一说多仓库部署和源代码自动备份以及自动打开Markdown编辑器。\n\n先上我的_config.yml文件：\n\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: 翰海尘沙\nsubtitle: 进击的程序员\ndescription: 技术分享、阅读笔记\nauthor: 翰海尘沙\nlanguage: zh-CN\ntimezone:\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yourgithubname.github.io\nroot: /blog/\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Extensions\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\ntheme: landscape\n#theme: leo\n\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository:\n    github: git@github.com:your_repository,gh-pages\n    gitcafe: git@gitcafe.com:your_repository,gitcafe-pages\n# 自动备份\nbackup:\n  type: git\n  repo: \n    github: git@github.com:your_repository,master\n    gitcafe: git@gitcafe.com:your_repository,master\n\n# 评论\n# 1.友言\n#uyan:\n#  enable: true\n# 2.多说\n#duoshuo_shortname: shortname\n# 3.畅言\nchangyan:\n  enable: true\n\n# RSS订阅\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 10\n\n# 网站地图\nsitemap:\n    path: sitemap.xml\n```\n\n多仓库部署比较简单，只要在_config.yml配置成如下：\n\n```\ndeploy:\n  type: git\n  repository:\n    github: git@github.com:your_repository,gh-pages\n    gitcafe: git@gitcafe.com:your_repository,gitcafe-pages\n```\n\n使用hexo d命令就可以自动部署到github和gitcafe上去。\n\n多仓自动库备份稍微复杂些，先在配置文件中自定自己的自动备份的配置：\n\n```\nbackup:\n  type: git\n  repo: \n    github: git@github.com:your_repository,master\n    gitcafe: git@gitcafe.com:your_repository,master\n```\n\n然后在博客源代码的项目根目录下的scripts目录（如果没有就新建一个scripes文件夹）中新建一个任意名字的javascript文件。我新建的是一个AutoBackUp.js，添加如下代码：\n\n``` JavaScript\nrequire('shelljs/global');\n\nvar parseConfig = require('hexo-deployer-git/lib/parse_config');\nvar util = require('hexo/node_modules/hexo-util');\nvar Promise = require('hexo/node_modules/bluebird');\nvar spawn = util.spawn;\n\ntry {\n    hexo.on('deployAfter', function() {\n        run();\n    });\n} catch (e) {\n    console.log(\"备份出现异常，详细信息\" + e.toString());\n}\n\nfunction git() {\n    var len = arguments.length;\n    var args = new Array(len);\n\n    for (var i = 0; i < len; i++) {\n        args[i] = arguments[i];\n    }\n\n    return spawn('git', args, {\n        cwd: hexo.base_dir,\n        verbose: !hexo.config.backup.silent\n    });\n}\n\nfunction push(repo) {\n    return git('add', '-A').then(function() {\n        return git('commit', '-m', \"Form auto backup script\\'s commit\").catch(function() {\n            // Do nothing. It's OK if nothing to commit.\n        });\n    }).then(function() {\n        return git('push', '-u', repo.url, 'master:' + repo.branch, '--force');\n    });\n}\n\nfunction run() {\n    if (!which('git')) {\n        echo('Sorry, this script require git');\n    } else {\n        echo(\"=======================Auto Backup Begin=======================\");\n        Promise.each(parseConfig(hexo.config.backup),function(repo){\n            return push(repo);\n        });\n        echo(\"=======================Auto Backup Complete======================\");\n    }\n}\n\n```\n\n还要安装shelljs模块，这样每次执行hexo d后就会自动备份到githu和gitcafe代码仓库。\n\n自动打开Markdown编辑器，同样在srcipt目录中添加一个OpenEditor.js文件，代码如下：\n``` JavaScript\nvar exec = require('child_process').exec;\nvar parseConfig = require('./parse_config');\n// Hexo 2.x 用户复制这段\n// hexo.on('new', function(path){\n// exec('start  \"D:\\\\Program Files\\\\Sublime Text 3\\\\sublime_text.exe\" ' + path);\n// });\n\n// Hexo 3 用户复制这段\nhexo.on('new', function(data) {\n    //exec('start  /max \"\" \"D:\\\\Program Files\\\\Sublime Text 3\\\\sublime_text.exe\" ' + data.path);\n    exec('start  /max \"\" \"D:\\\\Program Files\\\\MarkdownPad 2\\\\MarkdownPad2.exe\" ' + data.path);\n});\n\n/*=================windows code end======================*/\n\n\n///*********************************************************\n// *                 linux   代码                          *\n// *********************************************************/\n//\n//var exec = require('child_process').exec;\n//\n//// Hexo 2.x\n//hexo.on('new', function(path){\n//  exec('vi', [path]);\n//});\n//\n//// Hexo 3\n//hexo.on('new', function(data){\n//  exec('vi', [data.path]);\n//});\n//\n///*=================linux  code  end======================*/\n//\n///*********************************************************\n// *                 mac     代码                          *\n// *********************************************************/\n//\n//var exec = require('child_process').exec;\n//\n//// Hexo 2.x 用户复制这段\n//hexo.on('new', function(path){\n//    exec('open -a \"markdown编辑器绝对路径.app\" ' + path);\n//});\n//// Hexo 3 用户复制这段\n//hexo.on('new', function(data){\n//    exec('open -a \"markdown编辑器绝对路径.app\" ' + data.path);\n//});\n///*=================mac    code  end======================*/\n\n```\n\n在windows7下是亲测可以打开，至于Mac和Linux没测试过，不敢保证可以用。\n\n---\n\n参考博文：\n\n1. [younglaker的《Hexo系列博客》](http://laker.me/blog/categories/Hexo/)\n2. [夏末的《Hexo添加文章时自动打开编辑器》](http://notes.xiamo.tk/2015-06-29-Hexo添加文章时自动打开编辑器.html)\n3. [夏末的《自动备份Hexo博客源文件》](http://notes.xiamo.tk/2015-07-06-自动备份Hexo博客源文件.html)\n4. [Heaven的《使用Hexo搭建GitHub个人博客》](http://heavenru.com/2015/09/02/使用Hexo搭建GitHub个人博客/)\n5. [github高亮语言关键字](https://github.com/github/linguist/blob/master/lib/linguist/languages.yml)","slug":"Github个人静态博客的搭建","published":1,"updated":"2016-07-14T02:31:57.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw5u002ztkb9yxbs0ss8"},{"title":"C++11特性与应用（二）","date":"2016-08-04T07:38:22.000Z","_content":"\n\n### 模板细节\n\n#### 模板右尖括号\n\n在C++98/03范型编程中，模板实例的两个连续右尖括号之间必须加一空格，以免和右移操作符混淆。在C++11中这种限制取消了，不过，要注意的一点是：\n``` c++\ntemplate<int N>\nstruct Foo\n{\n};\nint main(void)\n{\n\tFoo<100 >> 2> x;\n\treturn EXIT_SUCCESS;\n}\n```\n在c++98/03中编译是么有问题的，它将Foo<100 >> 2> x理解为Foo<(100 >> 2)> x。但是在C++中编译器会提示错误，因为100 >> 2会先解释为模板的定界符，所以要手动写上括号Foo<(100 >> 2)> x。\n\n#### 模板的别名\n\n**类型别名**是一个名字，它是某种类型的同义词。有两种方法可以定义类型别名，一是传统方法使用关键字**typedef**：\n``` c++\ntypedef double wages;\ntypedef unsigned int uint_t;\n```\ntypedef只是为某种类型取别名，并没有真的定义一种新的类型，因此，下面这样将不是合法的函数重载：\n``` c++\ntypedef unsigned int uint_t;\nvoid func(unsigned int);\nvoid func(uint_t);\t\t\t//error:重定义\n```\n假如我们要定义一个map类型，它的key是固定类型std::string，值可以是int也可以是std::string等类型，该如何定义这么一种类型的map呢？在C++98/03中，可以如下实现：\n``` c++\ntemplate<typename Val>\nstruct str_map\n{\n\ttypedef std::map<std::string,Val> type;\n};\n\nstr_map<int>::type map1;\t\t//key是std::string，值是int\nstr_map<std::string>::type map2\t//key是std::string，只是std::string\n```\n<!--more-->\n使用C++11的新语法，会使得简洁易懂，如下：\n``` c++\ntemplate<typename Val>\nusing str_map_t = std::map<std::string,Val>;\n\nstr_map_t<int> map1;\t\t\t//key是std::string，值是int\nstr_map_t<std::string> map2;\t//key是std::string，值是std::string\n```\n这种方法叫**别名声明**，同样，别名声明也没有定义新的类型。实际上，using的别名语法覆盖了typedef的全部功能。using定义的str_map_t是一个模板，但是它既不是函数模板，也不是类模板，而是一种新的模板形式：**模板别名**。\n\n#### 函数模板的默认模板参数\n\n在C++98/03中，类模板可以有默认的模板参数，但是函数模板不支持默认参数，在C++11中这种限制被解除了。当所有模板参数都有默认值时，函数模板的调用如同调用普通函数，而对于类模板，即使参数都有默认值，在使用的时候也一定要加“<>”来实例化对象。函数模板的默认模板参数在使用规则上和其他的默认参数有所不同，它没有必要卸载参数列表的最后面。\n``` c++\n#include <iostream>\n#include \"type_name.h\"\n\ntemplate<typename R = int,typename U>\nR func(U val)\n{\n\tstd::cout << type_name<decltype(val)>() << std::endl;\n\treuturn val;\n}\n\nint main(void)\n{\n\tfunc(123);\n\tstd::cout << type_name<decltype(func(123))>() << std::endl;\n\tfunc(123L);\n\tstd::cout << type_name<decltype(func(123L))>() << std::endl;\n\tfunc<long>(123)\n\tstd::cout << type_name<decltype(func<long>(123))>() << std::endl;\n\treturn EXIT_SUCCESS;\n}\n\n////////////////////////////////////////\n/// output result\n////////////////////////////////////////\nint\t\t\t//func(123)，val类型是int,即U是int\nint\t\t\t//decltype(func(123))是函数返回类型R,默认int\nlong\t\t//func(123L),val类型是long，即U是long\nint\t\t\t//decltype(func(123L))是函数返回类型R,默认int\nint\t\t\t//func<long>(123)，val类型是int,即U是int\nlong\t\t//decltype(func<long>(123))是函数返回类型R,根据模板参数是long\n```\n从上面可以看出，由于函数调用时，参数是从右往左填充，此时根据func(123)，推导出U是int，R使用默认值；decltype(func<long>(123))函数参数是123推导出U是int，模板参数是long，所以R是long。\n\n### 初始化列表\nC++11中能够使用初始化列表进行初始化的只有**聚合类型**。什么是聚合类型呢？聚合类型的定义如下：\n1. 类型是一个普通数组（如int[1],char[2],long[3]\\[4]）；\n2. 类型是一个类（class，struct，union），且\n   1）、无用户自定义的构造函数；\n   2）、无私有(private)或者保护(protected)的非静态数据成员；\n   3）、无基类；\n   4）、无虚函数；\n   5）、不能有{}和=直接初始化的非静态数据成员。\n\n例一：普通数组\n``` c++\nint arr[] = {1,2,3,4,5};\nfloat y[2][3] =\n{\n\t{1,2,3},\n\t{4,5,6}\n};\n```\n例二：类类型\n``` c++\nstruct Foo\n{\n\tint x;\n\tdouble y;\n\tint z;\n\tFoo(int,int){}\n};\nFoo foo{1,2.5,1};\t//error:有用户自定义构造函数，与1）不符\n\nstruct ST\n{\n\tint x;\n\tdouble y;\nprotected:\n\tint z;\n};\nST s{1,2.5,1};\t\t//error:有私有或保护的非静态成员，与2）不符\n\nstruct Foo\n{\n\tint x;\n\tdouble y;\nprotected:\n\tstatic int z;\n};\nFoo foo{1,2.5};\t\t//ok,虽有保护成员，但是是静态成员\n\nstruct ST\n{\n\tint x;\n\tdouble y;\n\tvirtual void f(){}\n};\nST s{1,2.5};\t\t//error,有虚函数，与4）不符\n\nstruct Base {};\nstruct Foo : public Base\n{\n\tint x;\n\tdouble y;\n};\nFoo foo { 1, 2.5 };\t//error，有基类，与3）不符\n\nstruct ST\n{\n\tint x;\n\tdouble y = 0.0;\n};\nST s { 1, 2.5 };\t//error，有直接初始化的非静态数据成员，与5）不符；注意，在C++11中可以在声明非静态成员变量时进行初始化（使用{}或者=）。\n```\n对于上述非聚合类型，可以定义自定义构造函数来使用初始化列表：\n``` c++\nstruct ST\n{\n\tint x;\n\tdouble y;\n\tvirtual void F(){}\nprivate:\n\tint z;\npublic:\n\tST(int i,double j,int k):x(i),y(j),z(k){}\n};\nST s { 1,2.5,2 };\n```\n注意：聚合类型的定义并非递归的，当一个类的非静态成员是非聚合类型时，这个类也是有可能是聚合类型。如：\n``` c++\nstruct ST\n{\n\tint x;\n\tdouble y;\nprivate:\n\tint z;\n};\nST s { 1, 2.5, 1 };\t\t//error，这是一个非聚合类型\n\nstruct Foo\n{\n\tST st;\n\tint x;\n\tdouble y;\n};\nFoo foo { {}, 1, 2.5 };\t\t//ok，虽然ST是非聚合类型，但是Foo是聚合类型，初始化列表中的{}调用了ST的默认构造函数\n```\n\n#### 任意长度同类型初始化列表\n在C++中，定义并初始化数组时，可以不指定数组长度，通过初始化列表来确定数组长度：\n``` c++\nint arr[] = { 1, 2, 3 };\n```\n同理，可以stl中的容器std::initializer_list这个轻量级类模板来实现自定义类型的任意长度同类型初始化列表，如：\n``` c++\nclass Foo\n{\n\tstd::vector<int> content_;\npublic:\n\tFoo( std::initializer_list<int> li)\n\t{\n\t\tfor (auto it = li.begin(); it != li.end(); ++it)\n\t\t{\n\t\t\tcontent_.pushback(*it);\n\t\t}\n\t}\n};\nFoo foo = { 1, 2, 3 };\t\t//ok\n```\nstd::initializer_list不仅可以用来对自定义类型初始化，还可以用来传递同类型的数据集合，如：\n``` c++\n#include <iostream>\n\nvoid func( std::initializer_list<int> li)\n{\n\tfor (auto it = li.begin(); it != li.end(); ++it)\n\t{\n\t\tstd::cout << *it << std::endl;\n\t}\n}\n\nint main(void)\n{\n\tfunc({});\n\tfunc({ 1, 2, 3 });\n\n\treturn EXIT_SUCCESS;\n}\n\n```\nstd::initializer_list特点：\n1. 它是一个轻量级的容器类型，内部定义了iterator等；\n2. 对于std::initializer_list<T>，可以接收任意长度的同类型（或者相容类型）初始化列表元素；\n3. 对外提过：size()、begin()和end()三个接口；\n4. 它只能被整体初始化或赋值。\n``` c++\nstd::initializer_list<int> list;\t//无参构造\nsize_t n = list.size();\t\t\t\t//size为0\nlist = { 1, 2, 3 };\t\t\t\t\t//使用初始化列表赋值\nn = list.size();\t\t\t\t\t//size为3\nlist = { 3, 2, 1, 0 };\t\t\t\t//使用初始化列表重新赋值\nn = list.size();\t\t\t\t\t//size为4\n```\n对于std::initializer_list和vector容器的性能相比，std::initializer_list对初始化列表元素的引用，并没有真正拷贝元素，而std::vector是拷贝元素，所以std::initializer_list的性能更好。因为是只是引用，所以在函数返回值时，尽量不要使用std::initializer_list，如：\n``` c++\nstd::initializer_list<int> func(void)\n{\n\tint a = 1, b = 2;\n\treturn { a, b };\t//由于是引用，函数返回后， a和b的生命期都结束了，返回得到的将会是不确定的内容。此时使用std::vector更妥当。\n}\n```\n初始化列表能防止类型收窄，如：\n``` c++\nint a = 1.1;\t\t//ok\nint b = { 1.1 };\t//error\n```\n类型收窄的情况：\n1. 浮点数向整数隐式转换；\n2. 从高精度向低精度隐式转换；\n3. 从大整数向浮点数隐式转换；\n4. 从整数向长度更短的整数隐式转换。\n\n\n### 参考资料\n1. 《深入应用C++11：代码优化和工程应用》\n2. 《C++ Primer》（第五版）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/C-11特性与应用（二）.md","raw":"title: C++11特性与应用（二）\ntags:\n  - C++11\ncategories:\n  - C++\ndate: 2016-08-04 15:38:22\n---\n\n\n### 模板细节\n\n#### 模板右尖括号\n\n在C++98/03范型编程中，模板实例的两个连续右尖括号之间必须加一空格，以免和右移操作符混淆。在C++11中这种限制取消了，不过，要注意的一点是：\n``` c++\ntemplate<int N>\nstruct Foo\n{\n};\nint main(void)\n{\n\tFoo<100 >> 2> x;\n\treturn EXIT_SUCCESS;\n}\n```\n在c++98/03中编译是么有问题的，它将Foo<100 >> 2> x理解为Foo<(100 >> 2)> x。但是在C++中编译器会提示错误，因为100 >> 2会先解释为模板的定界符，所以要手动写上括号Foo<(100 >> 2)> x。\n\n#### 模板的别名\n\n**类型别名**是一个名字，它是某种类型的同义词。有两种方法可以定义类型别名，一是传统方法使用关键字**typedef**：\n``` c++\ntypedef double wages;\ntypedef unsigned int uint_t;\n```\ntypedef只是为某种类型取别名，并没有真的定义一种新的类型，因此，下面这样将不是合法的函数重载：\n``` c++\ntypedef unsigned int uint_t;\nvoid func(unsigned int);\nvoid func(uint_t);\t\t\t//error:重定义\n```\n假如我们要定义一个map类型，它的key是固定类型std::string，值可以是int也可以是std::string等类型，该如何定义这么一种类型的map呢？在C++98/03中，可以如下实现：\n``` c++\ntemplate<typename Val>\nstruct str_map\n{\n\ttypedef std::map<std::string,Val> type;\n};\n\nstr_map<int>::type map1;\t\t//key是std::string，值是int\nstr_map<std::string>::type map2\t//key是std::string，只是std::string\n```\n<!--more-->\n使用C++11的新语法，会使得简洁易懂，如下：\n``` c++\ntemplate<typename Val>\nusing str_map_t = std::map<std::string,Val>;\n\nstr_map_t<int> map1;\t\t\t//key是std::string，值是int\nstr_map_t<std::string> map2;\t//key是std::string，值是std::string\n```\n这种方法叫**别名声明**，同样，别名声明也没有定义新的类型。实际上，using的别名语法覆盖了typedef的全部功能。using定义的str_map_t是一个模板，但是它既不是函数模板，也不是类模板，而是一种新的模板形式：**模板别名**。\n\n#### 函数模板的默认模板参数\n\n在C++98/03中，类模板可以有默认的模板参数，但是函数模板不支持默认参数，在C++11中这种限制被解除了。当所有模板参数都有默认值时，函数模板的调用如同调用普通函数，而对于类模板，即使参数都有默认值，在使用的时候也一定要加“<>”来实例化对象。函数模板的默认模板参数在使用规则上和其他的默认参数有所不同，它没有必要卸载参数列表的最后面。\n``` c++\n#include <iostream>\n#include \"type_name.h\"\n\ntemplate<typename R = int,typename U>\nR func(U val)\n{\n\tstd::cout << type_name<decltype(val)>() << std::endl;\n\treuturn val;\n}\n\nint main(void)\n{\n\tfunc(123);\n\tstd::cout << type_name<decltype(func(123))>() << std::endl;\n\tfunc(123L);\n\tstd::cout << type_name<decltype(func(123L))>() << std::endl;\n\tfunc<long>(123)\n\tstd::cout << type_name<decltype(func<long>(123))>() << std::endl;\n\treturn EXIT_SUCCESS;\n}\n\n////////////////////////////////////////\n/// output result\n////////////////////////////////////////\nint\t\t\t//func(123)，val类型是int,即U是int\nint\t\t\t//decltype(func(123))是函数返回类型R,默认int\nlong\t\t//func(123L),val类型是long，即U是long\nint\t\t\t//decltype(func(123L))是函数返回类型R,默认int\nint\t\t\t//func<long>(123)，val类型是int,即U是int\nlong\t\t//decltype(func<long>(123))是函数返回类型R,根据模板参数是long\n```\n从上面可以看出，由于函数调用时，参数是从右往左填充，此时根据func(123)，推导出U是int，R使用默认值；decltype(func<long>(123))函数参数是123推导出U是int，模板参数是long，所以R是long。\n\n### 初始化列表\nC++11中能够使用初始化列表进行初始化的只有**聚合类型**。什么是聚合类型呢？聚合类型的定义如下：\n1. 类型是一个普通数组（如int[1],char[2],long[3]\\[4]）；\n2. 类型是一个类（class，struct，union），且\n   1）、无用户自定义的构造函数；\n   2）、无私有(private)或者保护(protected)的非静态数据成员；\n   3）、无基类；\n   4）、无虚函数；\n   5）、不能有{}和=直接初始化的非静态数据成员。\n\n例一：普通数组\n``` c++\nint arr[] = {1,2,3,4,5};\nfloat y[2][3] =\n{\n\t{1,2,3},\n\t{4,5,6}\n};\n```\n例二：类类型\n``` c++\nstruct Foo\n{\n\tint x;\n\tdouble y;\n\tint z;\n\tFoo(int,int){}\n};\nFoo foo{1,2.5,1};\t//error:有用户自定义构造函数，与1）不符\n\nstruct ST\n{\n\tint x;\n\tdouble y;\nprotected:\n\tint z;\n};\nST s{1,2.5,1};\t\t//error:有私有或保护的非静态成员，与2）不符\n\nstruct Foo\n{\n\tint x;\n\tdouble y;\nprotected:\n\tstatic int z;\n};\nFoo foo{1,2.5};\t\t//ok,虽有保护成员，但是是静态成员\n\nstruct ST\n{\n\tint x;\n\tdouble y;\n\tvirtual void f(){}\n};\nST s{1,2.5};\t\t//error,有虚函数，与4）不符\n\nstruct Base {};\nstruct Foo : public Base\n{\n\tint x;\n\tdouble y;\n};\nFoo foo { 1, 2.5 };\t//error，有基类，与3）不符\n\nstruct ST\n{\n\tint x;\n\tdouble y = 0.0;\n};\nST s { 1, 2.5 };\t//error，有直接初始化的非静态数据成员，与5）不符；注意，在C++11中可以在声明非静态成员变量时进行初始化（使用{}或者=）。\n```\n对于上述非聚合类型，可以定义自定义构造函数来使用初始化列表：\n``` c++\nstruct ST\n{\n\tint x;\n\tdouble y;\n\tvirtual void F(){}\nprivate:\n\tint z;\npublic:\n\tST(int i,double j,int k):x(i),y(j),z(k){}\n};\nST s { 1,2.5,2 };\n```\n注意：聚合类型的定义并非递归的，当一个类的非静态成员是非聚合类型时，这个类也是有可能是聚合类型。如：\n``` c++\nstruct ST\n{\n\tint x;\n\tdouble y;\nprivate:\n\tint z;\n};\nST s { 1, 2.5, 1 };\t\t//error，这是一个非聚合类型\n\nstruct Foo\n{\n\tST st;\n\tint x;\n\tdouble y;\n};\nFoo foo { {}, 1, 2.5 };\t\t//ok，虽然ST是非聚合类型，但是Foo是聚合类型，初始化列表中的{}调用了ST的默认构造函数\n```\n\n#### 任意长度同类型初始化列表\n在C++中，定义并初始化数组时，可以不指定数组长度，通过初始化列表来确定数组长度：\n``` c++\nint arr[] = { 1, 2, 3 };\n```\n同理，可以stl中的容器std::initializer_list这个轻量级类模板来实现自定义类型的任意长度同类型初始化列表，如：\n``` c++\nclass Foo\n{\n\tstd::vector<int> content_;\npublic:\n\tFoo( std::initializer_list<int> li)\n\t{\n\t\tfor (auto it = li.begin(); it != li.end(); ++it)\n\t\t{\n\t\t\tcontent_.pushback(*it);\n\t\t}\n\t}\n};\nFoo foo = { 1, 2, 3 };\t\t//ok\n```\nstd::initializer_list不仅可以用来对自定义类型初始化，还可以用来传递同类型的数据集合，如：\n``` c++\n#include <iostream>\n\nvoid func( std::initializer_list<int> li)\n{\n\tfor (auto it = li.begin(); it != li.end(); ++it)\n\t{\n\t\tstd::cout << *it << std::endl;\n\t}\n}\n\nint main(void)\n{\n\tfunc({});\n\tfunc({ 1, 2, 3 });\n\n\treturn EXIT_SUCCESS;\n}\n\n```\nstd::initializer_list特点：\n1. 它是一个轻量级的容器类型，内部定义了iterator等；\n2. 对于std::initializer_list<T>，可以接收任意长度的同类型（或者相容类型）初始化列表元素；\n3. 对外提过：size()、begin()和end()三个接口；\n4. 它只能被整体初始化或赋值。\n``` c++\nstd::initializer_list<int> list;\t//无参构造\nsize_t n = list.size();\t\t\t\t//size为0\nlist = { 1, 2, 3 };\t\t\t\t\t//使用初始化列表赋值\nn = list.size();\t\t\t\t\t//size为3\nlist = { 3, 2, 1, 0 };\t\t\t\t//使用初始化列表重新赋值\nn = list.size();\t\t\t\t\t//size为4\n```\n对于std::initializer_list和vector容器的性能相比，std::initializer_list对初始化列表元素的引用，并没有真正拷贝元素，而std::vector是拷贝元素，所以std::initializer_list的性能更好。因为是只是引用，所以在函数返回值时，尽量不要使用std::initializer_list，如：\n``` c++\nstd::initializer_list<int> func(void)\n{\n\tint a = 1, b = 2;\n\treturn { a, b };\t//由于是引用，函数返回后， a和b的生命期都结束了，返回得到的将会是不确定的内容。此时使用std::vector更妥当。\n}\n```\n初始化列表能防止类型收窄，如：\n``` c++\nint a = 1.1;\t\t//ok\nint b = { 1.1 };\t//error\n```\n类型收窄的情况：\n1. 浮点数向整数隐式转换；\n2. 从高精度向低精度隐式转换；\n3. 从大整数向浮点数隐式转换；\n4. 从整数向长度更短的整数隐式转换。\n\n\n### 参考资料\n1. 《深入应用C++11：代码优化和工程应用》\n2. 《C++ Primer》（第五版）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"C-11特性与应用（二）","published":1,"updated":"2016-08-04T07:40:05.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw5y0038tkb9rey5dcc1"},{"title":"C++11特性与应用（三）","date":"2016-08-09T09:33:54.000Z","_content":"\n\n### 基于范围的for循环\n\n基于范围的for循环非常的简洁，如：\n``` c++\n#include <iostream>\n#include <vector>\n\n// C++11版本\nint main(void)\n{\n        std::vector<int> arr = { 1, 2, 3, 4, 5 };\n        for (auto n : arr)\n        {\n                std::cout << n << std::endl;\n        }\n        return EXIT_SUCCESS;\n}\n\n// C++98/03版本\nint main(void)\n{\n        std::vector<int> arr = { 1, 2, 3, 4, 5 };\n\t\tstd::vector<int>::iterator it = arr.begin();\n\n        for (; it != arr.end(); ++it)\n        {\n                std::cout << *it << std::endl;\n        }\n        return EXIT_SUCCESS;\n}\n```\n相比之下，C++版本更加简洁。\n\n#### 基于范围的for循环使用细节\n\n注意到基于范围的for循环中的auto n，推导出来的是int类型，也就是说**auto推导出来的类型是容器的value_type，而不是迭代器**。\n\n看到for (auto n : arr)这句，有人会怀疑对容器的访问是没取一个值访问一次容器。事实真是这样吗？我们可以用下面的代码验证一下：\n``` c++\n#include <iostream>\n#include <vector>\n\nstd::vector<int> arr = { 1, 2, 3 };\n\nstd::vector<int>& get_range(void)\n{\n        std::cout << __FUNCTION__ << std::endl;\n        return arr;\n}\n\nint main(void)\n{\n        for (auto val : get_range())\n        {\n                std::cout << val << std::endl;\n        }\n        return EXIT_SUCCESS;\n}\n//////////////////////////////////////\n/// output result\n//////////////////////////////////////\nget_range\n1\n2\n3\n```\n<!--more-->\n从上面的结果可以看出，for (auto val : get_range())对容器只访问了一次。说明**基于范围的for循环，冒号后面的表达式只会被执行一次**\n\n在遍历时，对容器进行修改的情况：\n``` c++\n#include <iostream>\n#include <vector>\n\nint main(void)\n{\n        std::vector<int> arr = { 1, 2, 3 };\n        for(auto val : arr)\n        {\n                std::cout << val << std::endl;\n                arr.push_back(0);\n        }\n\t\tstd::cout << \"==================================\" << std::endl;for(auto val : arr)\n        {\n                std::cout << val << std::endl;\n        }\n        return EXIT_SUCCESS;\n}\n///////////////////////////////////////////\n/// output result\n///////////////////////////////////////////\n1\n2\n3\n==================================\n1\n2\n3\n0\n0\n0\n\n``` \n上面输出结果是在gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1)环境下的输出结果。对于同的编译器有不同的结果，随意在遍历容器时，尽量不要修改容器。而且可以看来上面的第一次变量虽然改变了容器，但是，遍历次数并没有增加。基于范围的for循环其实是普通for循环的语法糖，它等效下面的循环(参考ISO/IEC 14882 2014, 6.5.4 The range-based for statement)：\n``` c++\nstd::vector<int> arr = { 1, 2, 3 };\nfor(auto val : arr)\n{\n        std::cout << val << std::endl;\n        arr.push_back(0);\n}\n//上面几句，等效于下面语句\nstd::vector<int> arr = { 1, 2, 3 };\n{\n\tauto && __range = (arr);\n\tfor ( auto __begin = __range.begin(),__end = __range.end(); __begin != __end; ++__begin ) \n\t{\n\t\tauto val = *__begin;\n\t\tstd::cout << val << std::endl;\n        arr.push_back(0);\n\t}\n}\n```\n通过上面的分析，我们知道只要一个容器实现了如下功能就能自定义一个容器，使得它也可以使用基于范围的for循环：\n1. 容器要提供begin()和end()接口，返回一个该容器的迭代器；\n2. 容器的迭代器，实现重载前置++、解引用*和!=运算符；\n\n只要实现了上面两个要求，就可以将此自定义对象进行范围for循环了，下面实现一个针对整数的不完整实例：\n``` c++\n#include <iostream>\n\nnamespace range_container\n{\n\tclass iterator\n\t{\n\t\tint cursor_;\n\tpublic:\n\t\titerator(int cursor):cursor_(cursor){}\n\t\tint operator*() const\n\t\t{\n\t\t\treturn cursor_;\n\t\t}\n\t\tbool operator!=(const iterator& rhs) const\n\t\t{\n\t\t\treturn cursor_ != rhs.cursor_;\n\t\t}\n\t\titerator& operator++(void)\n\t\t{\n\t\t\t++cursor_;\n\t\t\treturn (*this);\n\t\t}\n\t};\n\t\n\tclass container\n\t{\n\t\tusing const_iterator = const range_container::iterator;\n\t\tint begin_;\n\t\tint end_;\n\t\t\n\tpublic:\n\t\tcontainer(int begin, int end):begin_(begin),end_(end + 1)\n\t\t{\n\t\t}\n\t\tconst_iterator begin(void) const\n\t\t{\n\t\t\treturn {begin_};\n\t\t}\n\t\tconst_iterator end(void) const\n\t\t{\n\t\t\treturn {end_};\n\t\t}\n\t};\n\t\n}// range_container namespace end\n\nint main(void)\n{\n        range_container::container c{ 1, 5 };\n        for( auto val : c)\n        {\n                std::cout << val << std::endl;\n        }\n\n        return EXIT_SUCCESS;\n}\n///////////////////////////////////////////\n/// output result\n///////////////////////////////////////////\n1\n2\n3\n4\n5\n```\n### 函数包装器和绑定器\n\n#### 可调用对象\n在C++中有一下几种对象可以作为可调用对象，也就是可以进行函数调用：\n1. 函数指针；\n2. 仿函数，具有operator()成员函数的类对象；\n3. 可以转换为函数指针的类对象，重载了类型转换符，并返回一个函数指针；\n4. 类成员函数指针；\n``` c++\nvoid func(void){}\n\nstruct Foo\n{\n\tvoid operator()(void){}\n};\n\nstruct Bar\n{\n\tusing fr_t = void(*)(void);\n\tstatic void func(void){}\n\toperator fr_t(void)\n\t{\n\t\treturn func;\n\t}\n};\n\nstruct A\n{\n\tvoid mem_func(void) {}\t\n};\n\nint main(void)\n{\n\tvoid (*func_ptr)(void) = &func;\t\t//1、函数指针\n\tfunc_ptr();\n\n\tFoo foo;\t\t\t\t\t\t\t//2、仿函数\n\tfoo();\n\n\tBar bar;\t\t\t\t\t\t\t//3、可以转换为函数指针的类对象\n\tbar();\n\n\tvoid (A::*mem_func_ptr)(void) = &A::mem_func;\n\tA aa;\n\t(aa.*mem_func_ptr)();\t\t\t\t//4、类成员函数指针\n\n\treturn EXIT_SUCCESS;\n}\n```\n可调用对象的类型称为**可调用类型**。\n\n#### std::function函数包装器\n\n现在思考一问题，以上的可调用类型都可充当一个回调函数类型传递给一个接口，由于可调用类型这么多，我们必须的将接口进行多次重载。如果你知道可调用对象包装器，你就无需进行重载了。如：\n``` c++\n#include <iostream>\n#include <functional>\n\nbool isEven(int a)\n{\n\treturn (a & 0x01) ? false : true;\n}\n\nstruct Even\n{\n\tbool operator()(int a)\n\t{\n\t\treturn (a & 0x01) ? false : true;\n\t}\n};\n\nstruct Bar\n{\n\tstatic bool isEven_static(int a)\n\t{\n\t\treturn (a & 0x01) ? false : true;\n\t}\n};\n\nclass FuncTest\n{\n\tstd::function<bool(int)> callback_;\npublic:\n\tFuncTest(const std::function<bool(int)> func):callback_(func){}\n\tvoid output(void)\n\t{\n\t\tfor(int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tif(callback_(i))\n\t\t\t{\n\t\t\t\tstd::cout << i << std::endl;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main(void)\n{\n\tFuncTest ft1(isEven);\t\t\t\t\t//1、函数指针\n\tft1.output();\n\n\tEven even;\t\t\t\t\t\t\t//2、仿函数\n\tFuncTest ft2(even);\n\tft2.output();\n\n\tFuncTest ft3(Bar::isEven_static);\t\t//3、静态成员函数指针\n\tft3.output();\n\n\treturn EXIT_SUCCESS;\n}\n\n///////////////////////////////////////////\n/// output result\n///////////////////////////////////////////\n0\n2\n==========================\n0\n2\n==========================\n0\n2\n```\n从上面的例子中可以看到，std::function函数包装器可以接收如下可调用对象：\n1. 函数指针；\n2. 仿函数；\n3. 可以转换为函数指针的类对象，更准确应该是静态成员函数指针。\n\n可以看到，std::function函数包装器不能容纳**类成员函数指针**，会报下面错误：\n``` c++\nstruct Bar\n{\n\tbool isEven(int a)\n\t{\n\t\treturn (a & 0x01) ? false : true;\n\t}\n};\n\nint main(void)\n{\n\tbool (Bar::*func_ptr)(int) = &Bar::func;\n\tBar bar;\t\t\t\n\tFuncTest ft1(bar.*mem_func_ptr);\t\t\t\t//4、类成员函数指针\n\tft1.output();\n\n\treturn EXIT_SUCCESS;\n}\n///////////////////////////////////////////\n/// output result\n///////////////////////////////////////////\nerror: invalid use of non-static member function\n  FuncTest ft1(bar.*func_ptr);\n```\n也就是说只有是类成员是静态函数指针才能被std::function函数包装器容纳。其实在可以转换为函数指针的类对象中，重载类型转换符，返回的就是一个静态成员函数的指针。\n\n#### std::bind绑定器\n\n不知道大家有没有写过类似如下代码：\n``` c++\nvoid output_1(int a)\n{\n\tstd::cout << a;\n}\nvoid output_2(int a, int b)\n{\n\toutput_1(a);\n\toutput_2(b);\n}\nvoid output_3(int a)\n{\n\toutput_2(100, a);\n}\nvoid output_4(int a)\n{\n\toutput_2(a, 100);\n}\n```\n总觉的上面的代码有点别扭，如果output_3和output_4中的常数多出一种情况50，又得添加两个函数接口，十分麻烦。这时如果你使用std::bind绑定器，将可调用对象和它的函数进行绑定，那么将会很方便，你只需要定义output_1和output_2两个接口，让接口调用这使用std::bind创建出他们希望的固定参数值的output了。如下：\n``` c++\n#include <iostream>\n#include <functional>\n\n///////////////////////////////////////////\n/// API \n///////////////////////////////////////////\nvoid output_1(int a)\n{\n\tstd::cout << a << \"\\t\";\n}\nvoid output_2(int a, int b)\n{\n\toutput_1(a);\n\toutput_2(b);\n\tstd::cout << std::endl;\n}\n///////////////////////////////////////////\n/// Caller\n///////////////////////////////////////////\n\nint main(void)\n{\n\tauto output_3 = std::bind(output_2,100,std::placeholders::_1);\t\t//即效果如output_2(100,a);\n\tauto output_4 = std::bind(output_2,std::placeholders::_1,100);\t\t//即效果如output_2(a,100);\n\toutput_3(3);\t\t//相当于调用output_2(100,3)效果\n\toutput_4(4);\t\t//相当于调用output_2(4,100)效果\n\n\treturn EXIT_SUCCESS;\n}\n///////////////////////////////////////////\n/// output result\n///////////////////////////////////////////\n100\t\t3\n4\t\t100\n```\nstd::bind用法说明：\n1. 参数一，要绑定的函数（如上output_2）;\n2. 参数二，传给绑定函数的第一个参数（如上，100传给output_2，即output_2(100,x)，x表示未知参数），参数三，传给绑定函数的第二个参数，以此类推；\n3. 如果参数是std::placeholders，std::placeholders::_1表示将调用绑定生成函数的第一个参数传递到std::placeholders::_1所在位置（如上，绑定生成的函数output_3，调用时output_3(3)，此时会将参数3传递到std::bind(output_2,100,**3**)，接着会解析成output_2(100,3)，以此类推std::placeholders::_2。\n\nstd::bind绑定器的作用：\n1. 将可调用对象与其参数一起绑定成一个仿函数。\n2. 将多元（参数个数为n，n>1）可调用对象转换成一元或者（n-1）元可调用对象，即部分参数绑定。\n\n绑定一个成员函数：\n``` c++\n#include <iostream>\n#include <functional>\n\nclass A\n{\npublic:\n\tvoid output(int a, int b)\n\t{\n\t\tstd::cout << x << \"\\t\" << y << std::endl;\n\t}\n};\n\nint main(void)\n{\n\tA a;\n\tstd::function<void(int,int)> fr = std::bind(&A::output,&a,std::placeholders::_1,std::placeholders::_2);\n\tfr(1,2);\n\n\treturn EXIT_SUCCESS;\n}\n///////////////////////////////////////////\n/// output result\n///////////////////////////////////////////\n1\t2\n```\n上面代码可以看出：\n1. std::bind的返回值是std::function；\n2. std::bind绑定成员函数时，第一参数是成员函数指针，第二参数是对象指针（相当于将this指针作为第一个参数传递给成员函数，在C++中，这通常是一个隐含参数），这也就将成员函数和对象绑定了，第三给参数是传递给成员函数的第一个参数，以此类推其他参数。\n\nstd::bind的组合使用\n使用绑定器和逻辑函数将多个函数组合成一个复合函数：\n``` c++\nusing std::placeholders::_1;\nauto func = std::bind(std::logical_and<boo>(),\n\t\t\t\t\t  std::bind(std::greater<int>(),_1,5),\n\t\t  \t\t\t  std::bind(std::less_equal<int>(),_1,10)\n\t\t \t\t\t );\n// 查找集合中大于5小于10的元素个数\nint count = std::count_if(container.begin(),container.end(),func);\n```\n### lambda表达式\n\n知道可调用对象之后，我们在传递一个可调用对象的时候就可以定义一个可调用对象传递过去，但是对于一些复用次数不多，处理过程简单的处理代码，为此特意定义一个可调用对象，显得大材小用。lambda就能很好的解决这个问题。例如：\n``` c++\n// 可调用对象版，使用仿函数\nclass Even\n{\npublic:\n\tvoid operator()(int a)\n\t{\n\t\tif (!(a & 0x01))\n\t\t{\n\t\t\tstd::cout << a << \"\\t\";\n\t\t}\n\t}\n};\n\nstd::vector<int> vec = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\nEven isEven;\nfor_each(vec.begin(), vec.end(), isEven);\n\n// lambda版\nstd::vector<int> vec = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\nfor_each(vec.begin(), vec.end(), [](int a)\n{\n\tif (!(a & 0x01))\n\t{\n\t\tstd::cout << a << \"\\t\";\n\t}\n});\n```\n从上面可以看出，lambda表达式使代码更可读，更简洁，上例或许还看不出多少简洁成分，可以看下例：\n``` c++\n// 查找集合中大于5小于10的元素个数，std::function和std::bind版本\nusing std::placeholders::_1;\nauto func = std::bind(std::logical_and<boo>(),\n\t\t\t\t\t  std::bind(std::greater<int>(),_1,5),\n\t\t  \t\t\t  std::bind(std::less_equal<int>(),_1,10)\n\t\t \t\t\t );\nint count = std::count_if(container.begin(),container.end(),func);\n\n// 查找集合中大于5小于10的元素个数，lambda版本\nint count = std::count_if(container.begin(),container.end(),[](int x){return x > 5 && x < 10;});\n```\nlambda表达式源于函数式编程的概念，有如下优点：\n1. 声明式编程风格：就地定义匿名目标函数或函数对象（即可调用对象）；\n2. 简洁：不需要定义具名函数或者函数对象；\n3. 在需要的时间和地点实现功能闭包，使程序更灵活。\n\n#### lambda表达式概念\nlambda语法格式：\n[ capture ] \\( params \\) opt -> ret { body; };\n说明：\n1. captura是捕获列表；\n2. params是参数列表，在参数列表没有参数时，可以省略参数列表（包括左右括号）；\n3. opt是函数选项，如mutable；\n4. ret是返回值类型，可以根据returned语句自动推导返回值类型，但是初始化列表不能用于推导，此时要显示写明返回值类型；\n5. body是函数体。\n\n捕获列表可以如下：\n\n| 捕获列表  |                   含义                                           |\n| :-------:|:----------------------------------------------------------------:|\n| []       | 不捕获任何变量                                                     |\n| [&]      | 以引用的方式捕获外部作用域中的所有变量                                |\n| [=]      | 以值的方式捕获外部作用域中的所有变量                                  |\n| [=,&foo] | 按值捕获外部作用域中的所有变量，按引用捕获foo                          |\n| [foo]    | 只按值捕获foo，其他变量都不捕获                                      |\n| [this]   | 捕获当前类中的this指针，与类成员函数一样的访问权限，[&]或[=]包括this在内 |\n\n注意：\n1. **按值捕获的变量是在定义lambda表达式时变量的复制品，当外部作用域改变该值时，不影响lambda中捕获的值**。如：\n``` c++\nint a = 0;\nauto func = [=]{return a;};\t\t\t\t//按值捕获\n\na += 1;\t\t\t\t\t\t\t\t\t//修改外部值\nstd::cout << func() << std::endl;\t\t//输出是0，不是1，因为func中是按值a,捕获的a其实是a的一个复制品，外部值改变不影响lambda这个闭包中的值。\n```\n2. **按值捕获的变量，在lambda中无法修改，如需修改，添加函数选项mutable，但是由于是按值捕获，在lambda中修改捕获值也不会影响外部变量的值，使用mutable时，就算没有参数参数列表也不能省略**。如：\n``` c++\nint a = 0;\nauto func1 = [=]{return a++;};\t\t\t\t//error,无法修改\nauto func2 = [=]() mutable {return a++;};\t//ok，mutable可以修改\n```\nlambda表达式类型在C++11中称为“闭包类型”，它是一种特殊的、匿名的非non-union的类类型。我们可以将它看作一个带有operator()的类，即仿函数。它可以使用std::function和std::bind来存储和操作lambda表达式。在上文中说道std::function函数包装器可以接收**函数指针**、**仿函数**、**静态成员函数指针**，现在还可以加上**lambda表达式**。例子：\n``` c++\nstd::function<int(int)> func1 = [](int a){ return a;};\nstd::function<int(int)> func2 = std::bind([](int a){return a;},std::placeholders::_1);\n```\nlambda表达式可以说是就地定义仿函数闭包的“语法糖”，它捕获的变量成为了闭包成员变量。按照C++标准，lambda表达式的operator()默认是const的，所以无法修改捕获到的变量。如果将lambda表达转换成函数指针，此时会丢失lambda闭包的this指针，对于无捕获列表的lambda表达式没什么问题，但是对于有捕获列表的将会报错，编译通不过。例如：\n``` c++\ntypedef void(*ptr)(int*);\nptr p1 = [](int* p) {delete p;};\t//ok\nptr p2 = [&](int *p) {delete p;};\t//error\n```\nC++11引入函数表达式，让代码更简洁，更灵活，更强大，挺提高了开发效率和提高了可维护性。\n\n### tuple元组\n\ntuple元组是一个固定大小的不同类型值的集合，是泛化的std::pair。\n1. 构造tuple：\n``` c++\n//方法一：\ntuple<int, int> tp(1,2);\t//ok\ntuple<int, int> tp{1,2);\t//ok\ntuple<int, int> tp = { 1, 2};\t//error,tuple构造函数被explicit限定\n//方法二：\ntuple<const char*,int> tp = std::make_tuple(sendPack,nSendSize);\n// 等效于\nstruct A\n{\n\tchar *pack;\n\tint len;\n}\n\n//方法三：\nauto tp = return std::tie(1,\"aa\",2);\t//实际类型：std::tuple<int&,string&,int&>\n\n//方法四：\nint a = 1, b = 2;\nstring s = \"aa\";\nauto tp = std::make_tuple(ref(a),ref(s),ref(b));\t//实际类型：std::tuple<int&,string&,int&)\n\n```\n说明：tuple构造函数被explicit限定，不能进行隐式转换，不可以将初始化列表传至“期望获取一个tuple”的地方，而是使用make_tuple。通过std::tie创建的元组是一个左值引用元组。\n2. 获取元组值\n``` c++\n//方法一：\nconst char* data = get<0>(tp);\nint len = get<1>(tp);\n\n//方法二：\nint x,y;\nstring a;\nstd::tie(x,a,y) = tp;\n\n//如果只想获取某个值\nstd::tie(std::ignore,std::ignore,y) = tp;\t//只取第三个值\n\n//方法三：\nint x,y;\nstring a;\nstd::make_tuple(ref(x),ref(a),ref(y)) = tp;\n```\n3. 连接多个tuple元组\n``` c++\n///////////////////////////////////////////\n/// printtuple.h file\n///////////////////////////////////////////\n#include <tuple>\n#include <iostream>\n\ntemplate <int IDX, int MAX, typename... Args>\nstruct PRINT_TUPLE{\n\tstatic void print (std::ostream& strm, const std::tuple<Args...>& t){\n\t\tstrm << std::get<IDX>(t) << (IDX+1==MAX ? \"\" : \",\");\n\t\tPRINT_TUPLE<IDX+1,MAX,Args...>::print(strm,t);\n\t}\n};\n\n// 偏特化类模版，终结递归调用\ntemplate <int MAX, typename... Args>\nstruct PRINT_TUPLE<MAX,MAX ,Args...>{\n\tstatic void print (std::ostream& strm, const std::tuple<Args...>& t){\n\t}\n};\n\ntemplate <typename... Args>\nstd::ostream& operator << (std::ostream& strm, const std::tuple<Args...>& t)\n{\n\tstrm << \"[\";\n\tPRINT_TUPLE<0,sizeof...(Args),Args...>::print(strm,t);\n\treturn strm << \"]\";\n}\n\n///////////////////////////////////////////\n/// testtuple.cpp file\n///////////////////////////////////////////\n#include <iostream>\n#include <tuple>\n#include <string>\n#include <functional>\n#include \"printtuple.h\"\n\nint main(void)\n{\n        std::tuple<int, std::string, float> t1(1, \"bb\", 1.23);\n        int n = 2;\n        auto t2 = std::tuple_cat(t1,std::make_pair(\"cc\",\"dd\"), std::tie(n));\n        n = 20;\n        std::cout << t2 << std::endl;\n\n        return EXIT_SUCCESS;\n}\n///////////////////////////////////////////\n/// output result\n///////////////////////////////////////////\n[1,bb,1.23,cc,dd,20]\n```\n从上面可以看出std::tie构造或者解构都是引用，std::make_tuple和std::ref组合使用能做到std::tie的效果。tuple无法直接输出，自己重载<<函数对tuple进行输出。\n\ntuple虽然可以用来代替简单的结构体，但是不要滥用，否则会导致代码的可读性下降。\n\n### 小结\n\n至此，使用C++11特性简化代码，使得代码更方便、简洁和优雅，特性有：类型推导（auto、decltype），模板别名和模板函数默认参数，基于范围的for循环，统一的初始化列表，函数包装器和函数绑定器，lambda表达式，tuple元组。\n\n\n### 参考资料\n### 参考资料\n1. 《深入应用C++11：代码优化和工程应用》\n2. 《C++ Primer》（第五版）\n3. 《C++标准库》（第二版）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/C-11特性与应用（三）.md","raw":"title: C++11特性与应用（三）\ntags:\n  - C++11\ncategories:\n  - C++\ndate: 2016-08-09 17:33:54\n---\n\n\n### 基于范围的for循环\n\n基于范围的for循环非常的简洁，如：\n``` c++\n#include <iostream>\n#include <vector>\n\n// C++11版本\nint main(void)\n{\n        std::vector<int> arr = { 1, 2, 3, 4, 5 };\n        for (auto n : arr)\n        {\n                std::cout << n << std::endl;\n        }\n        return EXIT_SUCCESS;\n}\n\n// C++98/03版本\nint main(void)\n{\n        std::vector<int> arr = { 1, 2, 3, 4, 5 };\n\t\tstd::vector<int>::iterator it = arr.begin();\n\n        for (; it != arr.end(); ++it)\n        {\n                std::cout << *it << std::endl;\n        }\n        return EXIT_SUCCESS;\n}\n```\n相比之下，C++版本更加简洁。\n\n#### 基于范围的for循环使用细节\n\n注意到基于范围的for循环中的auto n，推导出来的是int类型，也就是说**auto推导出来的类型是容器的value_type，而不是迭代器**。\n\n看到for (auto n : arr)这句，有人会怀疑对容器的访问是没取一个值访问一次容器。事实真是这样吗？我们可以用下面的代码验证一下：\n``` c++\n#include <iostream>\n#include <vector>\n\nstd::vector<int> arr = { 1, 2, 3 };\n\nstd::vector<int>& get_range(void)\n{\n        std::cout << __FUNCTION__ << std::endl;\n        return arr;\n}\n\nint main(void)\n{\n        for (auto val : get_range())\n        {\n                std::cout << val << std::endl;\n        }\n        return EXIT_SUCCESS;\n}\n//////////////////////////////////////\n/// output result\n//////////////////////////////////////\nget_range\n1\n2\n3\n```\n<!--more-->\n从上面的结果可以看出，for (auto val : get_range())对容器只访问了一次。说明**基于范围的for循环，冒号后面的表达式只会被执行一次**\n\n在遍历时，对容器进行修改的情况：\n``` c++\n#include <iostream>\n#include <vector>\n\nint main(void)\n{\n        std::vector<int> arr = { 1, 2, 3 };\n        for(auto val : arr)\n        {\n                std::cout << val << std::endl;\n                arr.push_back(0);\n        }\n\t\tstd::cout << \"==================================\" << std::endl;for(auto val : arr)\n        {\n                std::cout << val << std::endl;\n        }\n        return EXIT_SUCCESS;\n}\n///////////////////////////////////////////\n/// output result\n///////////////////////////////////////////\n1\n2\n3\n==================================\n1\n2\n3\n0\n0\n0\n\n``` \n上面输出结果是在gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1)环境下的输出结果。对于同的编译器有不同的结果，随意在遍历容器时，尽量不要修改容器。而且可以看来上面的第一次变量虽然改变了容器，但是，遍历次数并没有增加。基于范围的for循环其实是普通for循环的语法糖，它等效下面的循环(参考ISO/IEC 14882 2014, 6.5.4 The range-based for statement)：\n``` c++\nstd::vector<int> arr = { 1, 2, 3 };\nfor(auto val : arr)\n{\n        std::cout << val << std::endl;\n        arr.push_back(0);\n}\n//上面几句，等效于下面语句\nstd::vector<int> arr = { 1, 2, 3 };\n{\n\tauto && __range = (arr);\n\tfor ( auto __begin = __range.begin(),__end = __range.end(); __begin != __end; ++__begin ) \n\t{\n\t\tauto val = *__begin;\n\t\tstd::cout << val << std::endl;\n        arr.push_back(0);\n\t}\n}\n```\n通过上面的分析，我们知道只要一个容器实现了如下功能就能自定义一个容器，使得它也可以使用基于范围的for循环：\n1. 容器要提供begin()和end()接口，返回一个该容器的迭代器；\n2. 容器的迭代器，实现重载前置++、解引用*和!=运算符；\n\n只要实现了上面两个要求，就可以将此自定义对象进行范围for循环了，下面实现一个针对整数的不完整实例：\n``` c++\n#include <iostream>\n\nnamespace range_container\n{\n\tclass iterator\n\t{\n\t\tint cursor_;\n\tpublic:\n\t\titerator(int cursor):cursor_(cursor){}\n\t\tint operator*() const\n\t\t{\n\t\t\treturn cursor_;\n\t\t}\n\t\tbool operator!=(const iterator& rhs) const\n\t\t{\n\t\t\treturn cursor_ != rhs.cursor_;\n\t\t}\n\t\titerator& operator++(void)\n\t\t{\n\t\t\t++cursor_;\n\t\t\treturn (*this);\n\t\t}\n\t};\n\t\n\tclass container\n\t{\n\t\tusing const_iterator = const range_container::iterator;\n\t\tint begin_;\n\t\tint end_;\n\t\t\n\tpublic:\n\t\tcontainer(int begin, int end):begin_(begin),end_(end + 1)\n\t\t{\n\t\t}\n\t\tconst_iterator begin(void) const\n\t\t{\n\t\t\treturn {begin_};\n\t\t}\n\t\tconst_iterator end(void) const\n\t\t{\n\t\t\treturn {end_};\n\t\t}\n\t};\n\t\n}// range_container namespace end\n\nint main(void)\n{\n        range_container::container c{ 1, 5 };\n        for( auto val : c)\n        {\n                std::cout << val << std::endl;\n        }\n\n        return EXIT_SUCCESS;\n}\n///////////////////////////////////////////\n/// output result\n///////////////////////////////////////////\n1\n2\n3\n4\n5\n```\n### 函数包装器和绑定器\n\n#### 可调用对象\n在C++中有一下几种对象可以作为可调用对象，也就是可以进行函数调用：\n1. 函数指针；\n2. 仿函数，具有operator()成员函数的类对象；\n3. 可以转换为函数指针的类对象，重载了类型转换符，并返回一个函数指针；\n4. 类成员函数指针；\n``` c++\nvoid func(void){}\n\nstruct Foo\n{\n\tvoid operator()(void){}\n};\n\nstruct Bar\n{\n\tusing fr_t = void(*)(void);\n\tstatic void func(void){}\n\toperator fr_t(void)\n\t{\n\t\treturn func;\n\t}\n};\n\nstruct A\n{\n\tvoid mem_func(void) {}\t\n};\n\nint main(void)\n{\n\tvoid (*func_ptr)(void) = &func;\t\t//1、函数指针\n\tfunc_ptr();\n\n\tFoo foo;\t\t\t\t\t\t\t//2、仿函数\n\tfoo();\n\n\tBar bar;\t\t\t\t\t\t\t//3、可以转换为函数指针的类对象\n\tbar();\n\n\tvoid (A::*mem_func_ptr)(void) = &A::mem_func;\n\tA aa;\n\t(aa.*mem_func_ptr)();\t\t\t\t//4、类成员函数指针\n\n\treturn EXIT_SUCCESS;\n}\n```\n可调用对象的类型称为**可调用类型**。\n\n#### std::function函数包装器\n\n现在思考一问题，以上的可调用类型都可充当一个回调函数类型传递给一个接口，由于可调用类型这么多，我们必须的将接口进行多次重载。如果你知道可调用对象包装器，你就无需进行重载了。如：\n``` c++\n#include <iostream>\n#include <functional>\n\nbool isEven(int a)\n{\n\treturn (a & 0x01) ? false : true;\n}\n\nstruct Even\n{\n\tbool operator()(int a)\n\t{\n\t\treturn (a & 0x01) ? false : true;\n\t}\n};\n\nstruct Bar\n{\n\tstatic bool isEven_static(int a)\n\t{\n\t\treturn (a & 0x01) ? false : true;\n\t}\n};\n\nclass FuncTest\n{\n\tstd::function<bool(int)> callback_;\npublic:\n\tFuncTest(const std::function<bool(int)> func):callback_(func){}\n\tvoid output(void)\n\t{\n\t\tfor(int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tif(callback_(i))\n\t\t\t{\n\t\t\t\tstd::cout << i << std::endl;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main(void)\n{\n\tFuncTest ft1(isEven);\t\t\t\t\t//1、函数指针\n\tft1.output();\n\n\tEven even;\t\t\t\t\t\t\t//2、仿函数\n\tFuncTest ft2(even);\n\tft2.output();\n\n\tFuncTest ft3(Bar::isEven_static);\t\t//3、静态成员函数指针\n\tft3.output();\n\n\treturn EXIT_SUCCESS;\n}\n\n///////////////////////////////////////////\n/// output result\n///////////////////////////////////////////\n0\n2\n==========================\n0\n2\n==========================\n0\n2\n```\n从上面的例子中可以看到，std::function函数包装器可以接收如下可调用对象：\n1. 函数指针；\n2. 仿函数；\n3. 可以转换为函数指针的类对象，更准确应该是静态成员函数指针。\n\n可以看到，std::function函数包装器不能容纳**类成员函数指针**，会报下面错误：\n``` c++\nstruct Bar\n{\n\tbool isEven(int a)\n\t{\n\t\treturn (a & 0x01) ? false : true;\n\t}\n};\n\nint main(void)\n{\n\tbool (Bar::*func_ptr)(int) = &Bar::func;\n\tBar bar;\t\t\t\n\tFuncTest ft1(bar.*mem_func_ptr);\t\t\t\t//4、类成员函数指针\n\tft1.output();\n\n\treturn EXIT_SUCCESS;\n}\n///////////////////////////////////////////\n/// output result\n///////////////////////////////////////////\nerror: invalid use of non-static member function\n  FuncTest ft1(bar.*func_ptr);\n```\n也就是说只有是类成员是静态函数指针才能被std::function函数包装器容纳。其实在可以转换为函数指针的类对象中，重载类型转换符，返回的就是一个静态成员函数的指针。\n\n#### std::bind绑定器\n\n不知道大家有没有写过类似如下代码：\n``` c++\nvoid output_1(int a)\n{\n\tstd::cout << a;\n}\nvoid output_2(int a, int b)\n{\n\toutput_1(a);\n\toutput_2(b);\n}\nvoid output_3(int a)\n{\n\toutput_2(100, a);\n}\nvoid output_4(int a)\n{\n\toutput_2(a, 100);\n}\n```\n总觉的上面的代码有点别扭，如果output_3和output_4中的常数多出一种情况50，又得添加两个函数接口，十分麻烦。这时如果你使用std::bind绑定器，将可调用对象和它的函数进行绑定，那么将会很方便，你只需要定义output_1和output_2两个接口，让接口调用这使用std::bind创建出他们希望的固定参数值的output了。如下：\n``` c++\n#include <iostream>\n#include <functional>\n\n///////////////////////////////////////////\n/// API \n///////////////////////////////////////////\nvoid output_1(int a)\n{\n\tstd::cout << a << \"\\t\";\n}\nvoid output_2(int a, int b)\n{\n\toutput_1(a);\n\toutput_2(b);\n\tstd::cout << std::endl;\n}\n///////////////////////////////////////////\n/// Caller\n///////////////////////////////////////////\n\nint main(void)\n{\n\tauto output_3 = std::bind(output_2,100,std::placeholders::_1);\t\t//即效果如output_2(100,a);\n\tauto output_4 = std::bind(output_2,std::placeholders::_1,100);\t\t//即效果如output_2(a,100);\n\toutput_3(3);\t\t//相当于调用output_2(100,3)效果\n\toutput_4(4);\t\t//相当于调用output_2(4,100)效果\n\n\treturn EXIT_SUCCESS;\n}\n///////////////////////////////////////////\n/// output result\n///////////////////////////////////////////\n100\t\t3\n4\t\t100\n```\nstd::bind用法说明：\n1. 参数一，要绑定的函数（如上output_2）;\n2. 参数二，传给绑定函数的第一个参数（如上，100传给output_2，即output_2(100,x)，x表示未知参数），参数三，传给绑定函数的第二个参数，以此类推；\n3. 如果参数是std::placeholders，std::placeholders::_1表示将调用绑定生成函数的第一个参数传递到std::placeholders::_1所在位置（如上，绑定生成的函数output_3，调用时output_3(3)，此时会将参数3传递到std::bind(output_2,100,**3**)，接着会解析成output_2(100,3)，以此类推std::placeholders::_2。\n\nstd::bind绑定器的作用：\n1. 将可调用对象与其参数一起绑定成一个仿函数。\n2. 将多元（参数个数为n，n>1）可调用对象转换成一元或者（n-1）元可调用对象，即部分参数绑定。\n\n绑定一个成员函数：\n``` c++\n#include <iostream>\n#include <functional>\n\nclass A\n{\npublic:\n\tvoid output(int a, int b)\n\t{\n\t\tstd::cout << x << \"\\t\" << y << std::endl;\n\t}\n};\n\nint main(void)\n{\n\tA a;\n\tstd::function<void(int,int)> fr = std::bind(&A::output,&a,std::placeholders::_1,std::placeholders::_2);\n\tfr(1,2);\n\n\treturn EXIT_SUCCESS;\n}\n///////////////////////////////////////////\n/// output result\n///////////////////////////////////////////\n1\t2\n```\n上面代码可以看出：\n1. std::bind的返回值是std::function；\n2. std::bind绑定成员函数时，第一参数是成员函数指针，第二参数是对象指针（相当于将this指针作为第一个参数传递给成员函数，在C++中，这通常是一个隐含参数），这也就将成员函数和对象绑定了，第三给参数是传递给成员函数的第一个参数，以此类推其他参数。\n\nstd::bind的组合使用\n使用绑定器和逻辑函数将多个函数组合成一个复合函数：\n``` c++\nusing std::placeholders::_1;\nauto func = std::bind(std::logical_and<boo>(),\n\t\t\t\t\t  std::bind(std::greater<int>(),_1,5),\n\t\t  \t\t\t  std::bind(std::less_equal<int>(),_1,10)\n\t\t \t\t\t );\n// 查找集合中大于5小于10的元素个数\nint count = std::count_if(container.begin(),container.end(),func);\n```\n### lambda表达式\n\n知道可调用对象之后，我们在传递一个可调用对象的时候就可以定义一个可调用对象传递过去，但是对于一些复用次数不多，处理过程简单的处理代码，为此特意定义一个可调用对象，显得大材小用。lambda就能很好的解决这个问题。例如：\n``` c++\n// 可调用对象版，使用仿函数\nclass Even\n{\npublic:\n\tvoid operator()(int a)\n\t{\n\t\tif (!(a & 0x01))\n\t\t{\n\t\t\tstd::cout << a << \"\\t\";\n\t\t}\n\t}\n};\n\nstd::vector<int> vec = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\nEven isEven;\nfor_each(vec.begin(), vec.end(), isEven);\n\n// lambda版\nstd::vector<int> vec = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\nfor_each(vec.begin(), vec.end(), [](int a)\n{\n\tif (!(a & 0x01))\n\t{\n\t\tstd::cout << a << \"\\t\";\n\t}\n});\n```\n从上面可以看出，lambda表达式使代码更可读，更简洁，上例或许还看不出多少简洁成分，可以看下例：\n``` c++\n// 查找集合中大于5小于10的元素个数，std::function和std::bind版本\nusing std::placeholders::_1;\nauto func = std::bind(std::logical_and<boo>(),\n\t\t\t\t\t  std::bind(std::greater<int>(),_1,5),\n\t\t  \t\t\t  std::bind(std::less_equal<int>(),_1,10)\n\t\t \t\t\t );\nint count = std::count_if(container.begin(),container.end(),func);\n\n// 查找集合中大于5小于10的元素个数，lambda版本\nint count = std::count_if(container.begin(),container.end(),[](int x){return x > 5 && x < 10;});\n```\nlambda表达式源于函数式编程的概念，有如下优点：\n1. 声明式编程风格：就地定义匿名目标函数或函数对象（即可调用对象）；\n2. 简洁：不需要定义具名函数或者函数对象；\n3. 在需要的时间和地点实现功能闭包，使程序更灵活。\n\n#### lambda表达式概念\nlambda语法格式：\n[ capture ] \\( params \\) opt -> ret { body; };\n说明：\n1. captura是捕获列表；\n2. params是参数列表，在参数列表没有参数时，可以省略参数列表（包括左右括号）；\n3. opt是函数选项，如mutable；\n4. ret是返回值类型，可以根据returned语句自动推导返回值类型，但是初始化列表不能用于推导，此时要显示写明返回值类型；\n5. body是函数体。\n\n捕获列表可以如下：\n\n| 捕获列表  |                   含义                                           |\n| :-------:|:----------------------------------------------------------------:|\n| []       | 不捕获任何变量                                                     |\n| [&]      | 以引用的方式捕获外部作用域中的所有变量                                |\n| [=]      | 以值的方式捕获外部作用域中的所有变量                                  |\n| [=,&foo] | 按值捕获外部作用域中的所有变量，按引用捕获foo                          |\n| [foo]    | 只按值捕获foo，其他变量都不捕获                                      |\n| [this]   | 捕获当前类中的this指针，与类成员函数一样的访问权限，[&]或[=]包括this在内 |\n\n注意：\n1. **按值捕获的变量是在定义lambda表达式时变量的复制品，当外部作用域改变该值时，不影响lambda中捕获的值**。如：\n``` c++\nint a = 0;\nauto func = [=]{return a;};\t\t\t\t//按值捕获\n\na += 1;\t\t\t\t\t\t\t\t\t//修改外部值\nstd::cout << func() << std::endl;\t\t//输出是0，不是1，因为func中是按值a,捕获的a其实是a的一个复制品，外部值改变不影响lambda这个闭包中的值。\n```\n2. **按值捕获的变量，在lambda中无法修改，如需修改，添加函数选项mutable，但是由于是按值捕获，在lambda中修改捕获值也不会影响外部变量的值，使用mutable时，就算没有参数参数列表也不能省略**。如：\n``` c++\nint a = 0;\nauto func1 = [=]{return a++;};\t\t\t\t//error,无法修改\nauto func2 = [=]() mutable {return a++;};\t//ok，mutable可以修改\n```\nlambda表达式类型在C++11中称为“闭包类型”，它是一种特殊的、匿名的非non-union的类类型。我们可以将它看作一个带有operator()的类，即仿函数。它可以使用std::function和std::bind来存储和操作lambda表达式。在上文中说道std::function函数包装器可以接收**函数指针**、**仿函数**、**静态成员函数指针**，现在还可以加上**lambda表达式**。例子：\n``` c++\nstd::function<int(int)> func1 = [](int a){ return a;};\nstd::function<int(int)> func2 = std::bind([](int a){return a;},std::placeholders::_1);\n```\nlambda表达式可以说是就地定义仿函数闭包的“语法糖”，它捕获的变量成为了闭包成员变量。按照C++标准，lambda表达式的operator()默认是const的，所以无法修改捕获到的变量。如果将lambda表达转换成函数指针，此时会丢失lambda闭包的this指针，对于无捕获列表的lambda表达式没什么问题，但是对于有捕获列表的将会报错，编译通不过。例如：\n``` c++\ntypedef void(*ptr)(int*);\nptr p1 = [](int* p) {delete p;};\t//ok\nptr p2 = [&](int *p) {delete p;};\t//error\n```\nC++11引入函数表达式，让代码更简洁，更灵活，更强大，挺提高了开发效率和提高了可维护性。\n\n### tuple元组\n\ntuple元组是一个固定大小的不同类型值的集合，是泛化的std::pair。\n1. 构造tuple：\n``` c++\n//方法一：\ntuple<int, int> tp(1,2);\t//ok\ntuple<int, int> tp{1,2);\t//ok\ntuple<int, int> tp = { 1, 2};\t//error,tuple构造函数被explicit限定\n//方法二：\ntuple<const char*,int> tp = std::make_tuple(sendPack,nSendSize);\n// 等效于\nstruct A\n{\n\tchar *pack;\n\tint len;\n}\n\n//方法三：\nauto tp = return std::tie(1,\"aa\",2);\t//实际类型：std::tuple<int&,string&,int&>\n\n//方法四：\nint a = 1, b = 2;\nstring s = \"aa\";\nauto tp = std::make_tuple(ref(a),ref(s),ref(b));\t//实际类型：std::tuple<int&,string&,int&)\n\n```\n说明：tuple构造函数被explicit限定，不能进行隐式转换，不可以将初始化列表传至“期望获取一个tuple”的地方，而是使用make_tuple。通过std::tie创建的元组是一个左值引用元组。\n2. 获取元组值\n``` c++\n//方法一：\nconst char* data = get<0>(tp);\nint len = get<1>(tp);\n\n//方法二：\nint x,y;\nstring a;\nstd::tie(x,a,y) = tp;\n\n//如果只想获取某个值\nstd::tie(std::ignore,std::ignore,y) = tp;\t//只取第三个值\n\n//方法三：\nint x,y;\nstring a;\nstd::make_tuple(ref(x),ref(a),ref(y)) = tp;\n```\n3. 连接多个tuple元组\n``` c++\n///////////////////////////////////////////\n/// printtuple.h file\n///////////////////////////////////////////\n#include <tuple>\n#include <iostream>\n\ntemplate <int IDX, int MAX, typename... Args>\nstruct PRINT_TUPLE{\n\tstatic void print (std::ostream& strm, const std::tuple<Args...>& t){\n\t\tstrm << std::get<IDX>(t) << (IDX+1==MAX ? \"\" : \",\");\n\t\tPRINT_TUPLE<IDX+1,MAX,Args...>::print(strm,t);\n\t}\n};\n\n// 偏特化类模版，终结递归调用\ntemplate <int MAX, typename... Args>\nstruct PRINT_TUPLE<MAX,MAX ,Args...>{\n\tstatic void print (std::ostream& strm, const std::tuple<Args...>& t){\n\t}\n};\n\ntemplate <typename... Args>\nstd::ostream& operator << (std::ostream& strm, const std::tuple<Args...>& t)\n{\n\tstrm << \"[\";\n\tPRINT_TUPLE<0,sizeof...(Args),Args...>::print(strm,t);\n\treturn strm << \"]\";\n}\n\n///////////////////////////////////////////\n/// testtuple.cpp file\n///////////////////////////////////////////\n#include <iostream>\n#include <tuple>\n#include <string>\n#include <functional>\n#include \"printtuple.h\"\n\nint main(void)\n{\n        std::tuple<int, std::string, float> t1(1, \"bb\", 1.23);\n        int n = 2;\n        auto t2 = std::tuple_cat(t1,std::make_pair(\"cc\",\"dd\"), std::tie(n));\n        n = 20;\n        std::cout << t2 << std::endl;\n\n        return EXIT_SUCCESS;\n}\n///////////////////////////////////////////\n/// output result\n///////////////////////////////////////////\n[1,bb,1.23,cc,dd,20]\n```\n从上面可以看出std::tie构造或者解构都是引用，std::make_tuple和std::ref组合使用能做到std::tie的效果。tuple无法直接输出，自己重载<<函数对tuple进行输出。\n\ntuple虽然可以用来代替简单的结构体，但是不要滥用，否则会导致代码的可读性下降。\n\n### 小结\n\n至此，使用C++11特性简化代码，使得代码更方便、简洁和优雅，特性有：类型推导（auto、decltype），模板别名和模板函数默认参数，基于范围的for循环，统一的初始化列表，函数包装器和函数绑定器，lambda表达式，tuple元组。\n\n\n### 参考资料\n### 参考资料\n1. 《深入应用C++11：代码优化和工程应用》\n2. 《C++ Primer》（第五版）\n3. 《C++标准库》（第二版）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"C-11特性与应用（三）","published":1,"updated":"2016-08-09T09:33:54.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw61003dtkb92w6pcgy1"},{"title":"C++11特性与应用（一）：C++11语言特性","date":"2016-08-01T10:21:27.000Z","_content":"\n\nC++11相对于C++98/03有一下几点显著增强：\n1. 通过内存模型、线程、原子操作等来支持本地并行编程；\n2. 通过同一初始化表达式、auto、decltype、移动语义等来同一对泛型编程的支持；\n3. 通过constexpr、POD（概念）等更好地支持系统编程；\n4. 通过内联命名空间、继承构造函数和右值引用等，以更好地支持库的构建。\n\n## 1、C++11改进我们的程序\n\n### 1.1 类型推导\n\n### 1、auto类型推导\n编程时常常需要把表达式赋值给变量，这就要求在声明变量的时候清除地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11引入了**auto**类型说明符，用它就能让编译器（说明这个过程是编译阶段完成）替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符不同，auto让编译器通过初始值来推算变量的类型。显然，**auto定义的变量必须有初始值**。\n\n#### 顶层const和底层const\n我们都知道指针本身是一个对象，它又可以指向另一个对象。因此，指针本身是不是常量和指针所指向的对象是不是常量就是两个相互独立的问题。用名词**顶层const（top-level const）**表示指针本身是一个常量，而**底层const（low-level const）**表示指针所指向的对象是一个常量。\n\n更一般的，**顶层const**可以表示任意的对象是常量，这一点对任何书籍类型都适用，如算术类型、类、指针等。**底层const**则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点与其他类型相比区别明显：\n``` c++\nint i = 0;\nint *const p1 = &i;\t\t//不能改变p1的值，这是一个顶层const\nconst int ci = 42;\t\t//不能改变ci的值，这是一个顶层const\nconst int *p2 = &ci;\t//允许改变p2的值，这是一个底层const\nconst int *const p3=p2; //右边的const是顶层const，左边的const是底层const\nconst int &r = ci;\t\t//用于声明引用的const都是底层const\n```\n<!--more-->\n#### 推导规则：\n1. 当不声明为指针或引用时，auto的推到结果和初始化表达式抛弃引用和cv（const和volatile限定符）限定符后类型一致，就是抛弃引用和顶层的cv；\n2. 当声明为指针或引用时，auto的推导结果将保持初始表达式的cv属性，也就是保存底层cv。\n\n例如：\n``` c++\nint x = 0;\n\nauto *a = &x;\t\t\t//a ->int *\nauto  b = &x;\t\t\t//b ->int *\nauto &c =  x;\t\t\t//c ->int &\nauto  d =  c;\t\t\t//d ->int,根据规则1,丢掉了引用\n\nconst auto e = x;\t\t//e ->const int\nauto f = e;\t\t\t\t//f ->int,根据规则1,丢到了const\nauto i = &e;\t\t\t//i ->const int *,根据规则2,保持const属性\n\nconst auto &g = x;\t\t//g ->const int &\nauto &h = g;\t\t\t//h ->const int &,根据规则2,保持const属性\n\n\nconst auto *v = &x, u = 6;\t\t//OK,v是const int*类型，u是const int类型\nconst auto *m = &x, n = 6.0;\t//error,从m推导出auto是int，从n推导出auto是double，产生二义性\nauto int r;\t\t\t\t\t\t//error,auto不再表示存储类型指示符\nauto s;\t\t\t\t\t\t\t//error,auto只是占位符，并不代表实际类型，必须要有初始值\n```\n\n需要注意以下几点：\n1. const auto *v=&x推导出v的类型是const int \\*类型，但是u仍然必须要写**u=6**，否则编译通不过。\n2. u的初始化不能是编译器推导产生二义性。例如把u的初始化成**u=6.0**，编译器将会报错。\n3. 在旧标准中，auto表示存储类型指示符（包括static，register、mutable等），但是在新标准中auto不再表示存储类型指示符，而是表示为类型指示符，用来提示编译器对变量类型做自动类型推导。\n\n#### auto的限制\n1. 不能用于函数参数类型推导；\n2. 不能用于非静态成员变量的类型推导；\n3. 不能用于数组类型推导；\n4. 不能用于模版参数类型推导；\n``` c++\nvoid func(auto a =1){}\t\t\t\t//error:auto不能用于函数参数类型推导\n\nstruct Foo\n{\n\tauto var1_ = 0;\t\t\t\t\t//error:auto不能用于非静态成员变量类型推导\n\tstatic const auto var2_ = 0;\t//OK:var2_ 是static const int\n};\n\ntemplate <typename T>\nstruct Bar {};\n\nint main(void)\n{\n\tint arr[10] = {0};\n\tauto aa     = arr;\t\t\t\t//OK:aa是int *\n\tauto rr[10] = arr;\t\t\t\t//error:auto无法定义数组\n\tBar<int> bar;\n\tBar<auto> bb = bar;\t\t\t\t//error:auto无法推导模版参数类型\n\n\treturn EXIT_SUCCESS;\n}\n```\n在类中，auto仅能推导出static const的整数类型或者枚举成员，因为其他静态类型在C++标准中无法就地初始化。虽然C++11中可以接受非静态成员变量就地初始化，却不支持auto类型非静态成员变量的初始化。\n\n#### auto的使用\n\n在C++98/03，我们最常用的遍历容器元素操作如下代码：\n``` c++\n#include <map>\n\nint main(void)\n{\n\tstd::map<double,double> resultMap;\n\t...\n\tstd::map<double,double>::iterator it = resultMap.begin();\n\tfor (;it != resultMap.end(); ++it)\n\t{\n\t\t...\n\t}\n\treturn EXIT_SUCCESS;\n}\n```\n再来看看C++11中使用auto的代码：\n``` c++\n#include <map>\n\nint main(void)\n{\n\tstd::map<double,double> resultMap;\n\t...\n\tfor (auto it = resultMap.begin(); it != resultMap.end(); ++it)\n\t{\n\t\t...\n\t}\n\treturn EXIT_SUCCESS;\n}\n```\n代码简洁很多，再也不用写长长的迭代器类型了。\n\n再看一个使用auto简化函数定义的示例：\n``` c++\nclass Foo\n{\npublic:\n\tstatic int get(void)\n\t{\n\t\treturn 0;\n\t}\n};\n\nclass Bar\n{\npublic:\n\tstatic const char* get(void)\n\t{\n\t\treturn \"0\";\n\t}\n};\n\ntemplate<typename T>\nvoid func(void)\n{\n\tauto val = T::get();\n\t...\n}\n\nint main(void)\n{\n\tfunc<Foo>();\n\tfunc<Bar>();\n\tretunr EXIT_SUCCESS;\n}\n```\n多亏了auto，不然我们就得如下实现func函数：\n``` c++\n...\n\ntemplate<typename T1,typename T2>\nvoid func(void)\n{\n\tT2 val = T1::get();\n\t...\n}\n\nint main(void)\n{\n\tfunc<Foo,int>();\n\tfunc<Bar,char*>();\n\treturn EXIT_SUCCESS;\n}\n```\nauto虽然能带来方便，但是如果滥用将会使得代码可读性下降，代码维护难道增大。\n\n### 2、decltype类型指示符\n\n有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始变量。在C++11中引入了类型说明符**decltype**，它的作用是选择并返回操作书的数据类型。此过程中，编译器（发生在编译阶段）分析表达式并得到它的类型，却不实际计算表达式的值。而auto只能根据变量的初始化表达式推导出变量应该具有的类型。\n\n#### decltype(exp)推导规则：\n1. exp是标识符、类访问表达式，decltype(exp)和exp的类型一致；\n2. exp是函数调用，decltype(exp)和返回值的类型一致；\n3. 其他情况，若exp是左值，则decltype(exp)是exp类型的左值引用，否则和exp类型一致。\ndecltype将精确地推导出表达式定义本身的类型，一般不舍弃引用和cv限定符，只用当函数返回值是非类类型的纯右值时，cv限定符会忽略，因为对于纯右值而言，只用类类型可以携带cv限定符，此外一般忽略掉cv限定。\n例一：标识符表达式和类访问表达式：\n``` c++\n//////////////////////////////////////\n/// type_name.h file\n//////////////////////////////////////\n#include <type_traits>\n#include <typeinfo>\n#ifndef _MSC_VER\n#include <cxxabi.h>\n#endif\n#include <memory>\n#include <string>\n#include <cstdlib>\n\ntemplate <class T>\nstd::string\ntype_name()\n{\n    typedef typename std::remove_reference<T>::type TR;\n    std::unique_ptr<char, void(*)(void*)> own\n           (\n#ifndef _MSC_VER\n                abi::__cxa_demangle(typeid(TR).name(), nullptr,\n                                           nullptr, nullptr),\n#else\n                nullptr,\n#endif\n                std::free\n           );\n    std::string r = own != nullptr ? own.get() : typeid(TR).name();\n    if (std::is_const<TR>::value)\n        r = \"const \" + r;\n    if (std::is_volatile<TR>::value)\n        r = \"volatile \" + r;\n    if (std::is_lvalue_reference<T>::value)\n        r += \"&\";\n    else if (std::is_rvalue_reference<T>::value)\n        r += \"&&\";\n    return r;\n}\n//////////////////////////////////////\n/// type_name.h file end\n//////////////////////////////////////\n\n//////////////////////////////////////\n/// decltype1.cpp file\n//////////////////////////////////////\n#include <iostream>\n#include ”type_name.h“\n\nclass Foo\n{\npublic:\n\tstatic const int Number = 0;\n\tint x;\n};\n\nint main(void)\n{\n\tint n = 0;\n\tauto n1 = 0;\n\tdecltype(n) n2 = 0;\n\t\n\tstd::cout << \"n is \" << type_name(n) << std::endl;\n\tstd::cout << \"n1 is \" << type_name(n1) << std::endl;\n\tstd::cout << \"n2 is \" << type_name(n2) << std::endl;\n\n\tvolatile const int &x = n;\n\tauto x1 = x;\n\tdecltype(x) x2 = x;\n\n\tstd::cout << \"x is \" << type_name(x) << std::endl;\n\tstd::cout << \"x1 is \" << type_name(x1) << std::endl;\n\tstd::cout << \"x2 is \" << type_name(x2) << std::endl;\n\n\tFoo foo;\n\tdecltype(foo) c;\n\tdecltype(Foo::Number) d = 0;\n\tdecltyoe(foo.x) e = 0;\n\n\tstd::cout << \"c is \" << type_name(c) << std::endl;\n\tstd::cout << \"d is \" << type_name(d) << std::endl;\n\tstd::cout << \"e is \" << type_name(e) << std::endl;\n\t\n\treturn EXIT_SUCCESS;\n}\n//////////////////////////////////////\n/// decltype1.cpp file end\n//////////////////////////////////////\n\n//////////////////////////////////////\n/// output result\n//////////////////////////////////////\nn is int\nn1 is int\nn2 is int\nx is volatile const int&\nx1 is int\nx2 is volatile const int&\nc is Foo\nd is const int\ne is int\n```\nauto根据初始化的值类型推导出变量类型，忽略cv限定符，比如x1，而decltype不忽略cv限定符。\n\n例二：函数调用\n``` C++\n//////////////////////////////////////\n/// decltype2.cpp file\n//////////////////////////////////////\n#include <iostream>\n#include \"type_name.h\"\n\nclass Foo {};\n\nint main(void)\n{\n\tint& func_int_r(void);\t\t\t//左值(lvalue)\n\tint&& func_int_rr(void);\t\t//x值(xvlalue,右值引用)\n\tint func_int(void);\t\t\t\t//纯右值(prvalue)\n\n\tstd::cout << \"func_int_r is \" << type_name<decltype(func_int_r)>() << std::endl;\n\tstd::cout << \"func_int_rr is \" << type_name<decltype(func_int_rr)>() << std::endl;\n\tstd::cout << \"func_int is \" << type_name<decltype(func_int)>() << std::endl;\n\n\tconst int& func_cint_r(void);\t//左值\n\tconst int&& func_cint_rr(void);\t//x值\n\tconst int func_cint(void);\t\t//纯右值\n\tconst Foo func_cfoo(void);\t\t//纯右值\n\t\n\tstd::cout << \"func_cint_r() is \" << type_name<decltype(func_cint_r)>() << std::endl;\n\tstd::cout << \"func_cint_rr() is \" << type_name<decltype(func_cint_rr)>() << std::endl;\n\tstd::cout << \"func_cint() is \" << type_name<decltype(func_cint)>() << std::endl;\n\tstd::cout << \"func_cfoo() is \" << type_name<decltype(func_cfoo)>() << std::endl;\n\t\n\treturn EXIT_SUCCESS;\n}\n//////////////////////////////////////\n/// decltype2.cpp file end\n//////////////////////////////////////\n\n//////////////////////////////////////\n/// output result\n//////////////////////////////////////\nfunc_int_r() is int&\nfunc_int_rr() is int&&\nfunc_int() is int\nfunc_cint_r() is const int&\nfunc_cint_rr() is const int&&\nfunc_cint() is int\nfunc_cfoo() is const Foo\n```\ndecltype与函数返回值类型一致，但是如果返回值是纯右值**非类类型**，忽略cv限定符，比如：func_cint；如果返回值是纯右值的**类类型**，保留cv限定符。\n\n例3：其他情况，带括号表达式和加法运算表达式\n``` c++\n//////////////////////////////////////\n/// decltype3.cpp file\n//////////////////////////////////////\n#include <iostream>\n#include \"type_name.h\"\n\nstruct Foo { int x; };\n\nint main(void)\n{\n\tconst Foo foo = Foo();\n\tstd::cout << \"foo.x is \" << type_name<decltype(foo.x)>() << std::endl;\n\tstd::cout << \"(foo.x) is \" << type_name<decltype((foo.x))>() << std::endl;\n\n\tint n = 0,m = 0;\n\tstd::cout << \"n+m is \" << type_name<decltype(n + m)>() << std::endl;\n\tstd::cout << \"n+=m is \" << type_name<decltype(n += m)>() << std::endl;\n\t\n\treturn EXIT_SUCCESS;\n}\n//////////////////////////////////////\n/// decltype3.cpp file end\n//////////////////////////////////////\n\n//////////////////////////////////////\n/// output result\n//////////////////////////////////////\nfoo.x is int\n(foo.x) is const int&\nn+m is int\nn+=m is int&\n```\nfoo.x根据推导规则一，类型是int；(foo.x)是左值，推导出是int&，而foo又是const，所以(foo.x)是const int&；n+m是右值，类型是int；n+=m是左值，类型是int&。\n\n#### decltype应用\ndecltype的应用多出现在泛型编程中。\n\n应用一：\n``` c++\n#include <vector>\n\ntemplate<typename ContainerT>\nclass Foo\n{\n\ttypename ContainerT::iterator it_;\npublic:\n\tvoid func(ContainerT& container)\n\t{\n\t\tit_ = container.begin();\n\t}\n};\n\nint main(void)\n{\n\ttypedef const std::vector<int> container_t;\n\tcontainer_t arr;\n\t\n\tFoo<container_t> foo;\n\tfoo.func(arr);\n\t\n\treturn EXIT_SUCCESS;\n}\n```\n单独看vector没有什么问题，但是如果传入的容器有const限定，那么就会出问题了，因为const容器的迭代器是const_iterator。在C++98/03中的解决方案是，特化一个类模版如下：\n``` c++\ntemplate<typename ContainerT>\nclass Foo<const ContainerT>\n{\n\ttypename ContainerT::const_iterator it_;\npublic:\n\tvoid func(const ContainerT& container)\n\t{\n\t\tit_ = container.begin();\n\t}\n};\n```\n上面的实现略显繁琐，在C++11中只要稍微修改一下类模版Foo即可实现相同功能，如下：\n``` c++\ntemplate<typename ContainerT>\nclass Foo\n{\n\tdecltype(ContainerT().begin()) it_;\npublic:\n\tvoid func(ContainerT& container)\n\t{\n\t\tit_ = container.begin();\n\t}\n};\n```\n这样无论容器是否被const限定都没问题，代码简洁了好多。\n\n### auto和decltype结合使用：返回类型后置语法\n在范型编程中，可能需要通过参数的运算来得到返回值类型。比如：\n``` c++\ntemplate<typename T,typename U>\ndecltype(t+u) add(T t,U u)\n{\n\treturn t+u;\n}\n```\n但是这样编译不过，因为t、u在参数列表中，C++的返回值是前置语法，返回值定义的时候参数变量还不存在。不过可以改成如下：\n``` c++\ntemplate<typename T,typename U>\ndecltype(T()+U()) add(T t,U u)\n{\n\treturn t+u;\n}\n```\n这样看上去没什么问题，但是如果T和U类型没有无参构造函数，依然会有问题，还可以改成下面这样：\n``` c++\ntemplate<typename T,typename U>\ndecltype((*(T*)0) + (*(U*)0)) add(T t,U u)\n{\n\treturn t+u;\n}\n```\n这样确实已经实现了此功能，但是看上去和复杂，而且让人费解，如果使用auto和decltype结合使用可以和简洁的完成此功能：\n``` c++\ntemplate<typename T,typename U>\nauto add(T t,U u) -> decltype(t+u)\n{\n\treturn t+u;\n}\n```\nauto会根据后置的decltype(t+u)类型推导出来，而此时t和u的已经存在，所以没有问题，代码也很简洁，可读性强。\n\n\n### 参考资料\n1. 《深入应用C++11：代码优化和工程应用》\n2. 《C++ Primer》（第五版）\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/C-11特性与应用（一）：C-11语言特性.md","raw":"title: C++11特性与应用（一）：C++11语言特性\ntags:\n  - C++11\ncategories:\n  - C++\ndate: 2016-08-01 18:21:27\n---\n\n\nC++11相对于C++98/03有一下几点显著增强：\n1. 通过内存模型、线程、原子操作等来支持本地并行编程；\n2. 通过同一初始化表达式、auto、decltype、移动语义等来同一对泛型编程的支持；\n3. 通过constexpr、POD（概念）等更好地支持系统编程；\n4. 通过内联命名空间、继承构造函数和右值引用等，以更好地支持库的构建。\n\n## 1、C++11改进我们的程序\n\n### 1.1 类型推导\n\n### 1、auto类型推导\n编程时常常需要把表达式赋值给变量，这就要求在声明变量的时候清除地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11引入了**auto**类型说明符，用它就能让编译器（说明这个过程是编译阶段完成）替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符不同，auto让编译器通过初始值来推算变量的类型。显然，**auto定义的变量必须有初始值**。\n\n#### 顶层const和底层const\n我们都知道指针本身是一个对象，它又可以指向另一个对象。因此，指针本身是不是常量和指针所指向的对象是不是常量就是两个相互独立的问题。用名词**顶层const（top-level const）**表示指针本身是一个常量，而**底层const（low-level const）**表示指针所指向的对象是一个常量。\n\n更一般的，**顶层const**可以表示任意的对象是常量，这一点对任何书籍类型都适用，如算术类型、类、指针等。**底层const**则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点与其他类型相比区别明显：\n``` c++\nint i = 0;\nint *const p1 = &i;\t\t//不能改变p1的值，这是一个顶层const\nconst int ci = 42;\t\t//不能改变ci的值，这是一个顶层const\nconst int *p2 = &ci;\t//允许改变p2的值，这是一个底层const\nconst int *const p3=p2; //右边的const是顶层const，左边的const是底层const\nconst int &r = ci;\t\t//用于声明引用的const都是底层const\n```\n<!--more-->\n#### 推导规则：\n1. 当不声明为指针或引用时，auto的推到结果和初始化表达式抛弃引用和cv（const和volatile限定符）限定符后类型一致，就是抛弃引用和顶层的cv；\n2. 当声明为指针或引用时，auto的推导结果将保持初始表达式的cv属性，也就是保存底层cv。\n\n例如：\n``` c++\nint x = 0;\n\nauto *a = &x;\t\t\t//a ->int *\nauto  b = &x;\t\t\t//b ->int *\nauto &c =  x;\t\t\t//c ->int &\nauto  d =  c;\t\t\t//d ->int,根据规则1,丢掉了引用\n\nconst auto e = x;\t\t//e ->const int\nauto f = e;\t\t\t\t//f ->int,根据规则1,丢到了const\nauto i = &e;\t\t\t//i ->const int *,根据规则2,保持const属性\n\nconst auto &g = x;\t\t//g ->const int &\nauto &h = g;\t\t\t//h ->const int &,根据规则2,保持const属性\n\n\nconst auto *v = &x, u = 6;\t\t//OK,v是const int*类型，u是const int类型\nconst auto *m = &x, n = 6.0;\t//error,从m推导出auto是int，从n推导出auto是double，产生二义性\nauto int r;\t\t\t\t\t\t//error,auto不再表示存储类型指示符\nauto s;\t\t\t\t\t\t\t//error,auto只是占位符，并不代表实际类型，必须要有初始值\n```\n\n需要注意以下几点：\n1. const auto *v=&x推导出v的类型是const int \\*类型，但是u仍然必须要写**u=6**，否则编译通不过。\n2. u的初始化不能是编译器推导产生二义性。例如把u的初始化成**u=6.0**，编译器将会报错。\n3. 在旧标准中，auto表示存储类型指示符（包括static，register、mutable等），但是在新标准中auto不再表示存储类型指示符，而是表示为类型指示符，用来提示编译器对变量类型做自动类型推导。\n\n#### auto的限制\n1. 不能用于函数参数类型推导；\n2. 不能用于非静态成员变量的类型推导；\n3. 不能用于数组类型推导；\n4. 不能用于模版参数类型推导；\n``` c++\nvoid func(auto a =1){}\t\t\t\t//error:auto不能用于函数参数类型推导\n\nstruct Foo\n{\n\tauto var1_ = 0;\t\t\t\t\t//error:auto不能用于非静态成员变量类型推导\n\tstatic const auto var2_ = 0;\t//OK:var2_ 是static const int\n};\n\ntemplate <typename T>\nstruct Bar {};\n\nint main(void)\n{\n\tint arr[10] = {0};\n\tauto aa     = arr;\t\t\t\t//OK:aa是int *\n\tauto rr[10] = arr;\t\t\t\t//error:auto无法定义数组\n\tBar<int> bar;\n\tBar<auto> bb = bar;\t\t\t\t//error:auto无法推导模版参数类型\n\n\treturn EXIT_SUCCESS;\n}\n```\n在类中，auto仅能推导出static const的整数类型或者枚举成员，因为其他静态类型在C++标准中无法就地初始化。虽然C++11中可以接受非静态成员变量就地初始化，却不支持auto类型非静态成员变量的初始化。\n\n#### auto的使用\n\n在C++98/03，我们最常用的遍历容器元素操作如下代码：\n``` c++\n#include <map>\n\nint main(void)\n{\n\tstd::map<double,double> resultMap;\n\t...\n\tstd::map<double,double>::iterator it = resultMap.begin();\n\tfor (;it != resultMap.end(); ++it)\n\t{\n\t\t...\n\t}\n\treturn EXIT_SUCCESS;\n}\n```\n再来看看C++11中使用auto的代码：\n``` c++\n#include <map>\n\nint main(void)\n{\n\tstd::map<double,double> resultMap;\n\t...\n\tfor (auto it = resultMap.begin(); it != resultMap.end(); ++it)\n\t{\n\t\t...\n\t}\n\treturn EXIT_SUCCESS;\n}\n```\n代码简洁很多，再也不用写长长的迭代器类型了。\n\n再看一个使用auto简化函数定义的示例：\n``` c++\nclass Foo\n{\npublic:\n\tstatic int get(void)\n\t{\n\t\treturn 0;\n\t}\n};\n\nclass Bar\n{\npublic:\n\tstatic const char* get(void)\n\t{\n\t\treturn \"0\";\n\t}\n};\n\ntemplate<typename T>\nvoid func(void)\n{\n\tauto val = T::get();\n\t...\n}\n\nint main(void)\n{\n\tfunc<Foo>();\n\tfunc<Bar>();\n\tretunr EXIT_SUCCESS;\n}\n```\n多亏了auto，不然我们就得如下实现func函数：\n``` c++\n...\n\ntemplate<typename T1,typename T2>\nvoid func(void)\n{\n\tT2 val = T1::get();\n\t...\n}\n\nint main(void)\n{\n\tfunc<Foo,int>();\n\tfunc<Bar,char*>();\n\treturn EXIT_SUCCESS;\n}\n```\nauto虽然能带来方便，但是如果滥用将会使得代码可读性下降，代码维护难道增大。\n\n### 2、decltype类型指示符\n\n有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始变量。在C++11中引入了类型说明符**decltype**，它的作用是选择并返回操作书的数据类型。此过程中，编译器（发生在编译阶段）分析表达式并得到它的类型，却不实际计算表达式的值。而auto只能根据变量的初始化表达式推导出变量应该具有的类型。\n\n#### decltype(exp)推导规则：\n1. exp是标识符、类访问表达式，decltype(exp)和exp的类型一致；\n2. exp是函数调用，decltype(exp)和返回值的类型一致；\n3. 其他情况，若exp是左值，则decltype(exp)是exp类型的左值引用，否则和exp类型一致。\ndecltype将精确地推导出表达式定义本身的类型，一般不舍弃引用和cv限定符，只用当函数返回值是非类类型的纯右值时，cv限定符会忽略，因为对于纯右值而言，只用类类型可以携带cv限定符，此外一般忽略掉cv限定。\n例一：标识符表达式和类访问表达式：\n``` c++\n//////////////////////////////////////\n/// type_name.h file\n//////////////////////////////////////\n#include <type_traits>\n#include <typeinfo>\n#ifndef _MSC_VER\n#include <cxxabi.h>\n#endif\n#include <memory>\n#include <string>\n#include <cstdlib>\n\ntemplate <class T>\nstd::string\ntype_name()\n{\n    typedef typename std::remove_reference<T>::type TR;\n    std::unique_ptr<char, void(*)(void*)> own\n           (\n#ifndef _MSC_VER\n                abi::__cxa_demangle(typeid(TR).name(), nullptr,\n                                           nullptr, nullptr),\n#else\n                nullptr,\n#endif\n                std::free\n           );\n    std::string r = own != nullptr ? own.get() : typeid(TR).name();\n    if (std::is_const<TR>::value)\n        r = \"const \" + r;\n    if (std::is_volatile<TR>::value)\n        r = \"volatile \" + r;\n    if (std::is_lvalue_reference<T>::value)\n        r += \"&\";\n    else if (std::is_rvalue_reference<T>::value)\n        r += \"&&\";\n    return r;\n}\n//////////////////////////////////////\n/// type_name.h file end\n//////////////////////////////////////\n\n//////////////////////////////////////\n/// decltype1.cpp file\n//////////////////////////////////////\n#include <iostream>\n#include ”type_name.h“\n\nclass Foo\n{\npublic:\n\tstatic const int Number = 0;\n\tint x;\n};\n\nint main(void)\n{\n\tint n = 0;\n\tauto n1 = 0;\n\tdecltype(n) n2 = 0;\n\t\n\tstd::cout << \"n is \" << type_name(n) << std::endl;\n\tstd::cout << \"n1 is \" << type_name(n1) << std::endl;\n\tstd::cout << \"n2 is \" << type_name(n2) << std::endl;\n\n\tvolatile const int &x = n;\n\tauto x1 = x;\n\tdecltype(x) x2 = x;\n\n\tstd::cout << \"x is \" << type_name(x) << std::endl;\n\tstd::cout << \"x1 is \" << type_name(x1) << std::endl;\n\tstd::cout << \"x2 is \" << type_name(x2) << std::endl;\n\n\tFoo foo;\n\tdecltype(foo) c;\n\tdecltype(Foo::Number) d = 0;\n\tdecltyoe(foo.x) e = 0;\n\n\tstd::cout << \"c is \" << type_name(c) << std::endl;\n\tstd::cout << \"d is \" << type_name(d) << std::endl;\n\tstd::cout << \"e is \" << type_name(e) << std::endl;\n\t\n\treturn EXIT_SUCCESS;\n}\n//////////////////////////////////////\n/// decltype1.cpp file end\n//////////////////////////////////////\n\n//////////////////////////////////////\n/// output result\n//////////////////////////////////////\nn is int\nn1 is int\nn2 is int\nx is volatile const int&\nx1 is int\nx2 is volatile const int&\nc is Foo\nd is const int\ne is int\n```\nauto根据初始化的值类型推导出变量类型，忽略cv限定符，比如x1，而decltype不忽略cv限定符。\n\n例二：函数调用\n``` C++\n//////////////////////////////////////\n/// decltype2.cpp file\n//////////////////////////////////////\n#include <iostream>\n#include \"type_name.h\"\n\nclass Foo {};\n\nint main(void)\n{\n\tint& func_int_r(void);\t\t\t//左值(lvalue)\n\tint&& func_int_rr(void);\t\t//x值(xvlalue,右值引用)\n\tint func_int(void);\t\t\t\t//纯右值(prvalue)\n\n\tstd::cout << \"func_int_r is \" << type_name<decltype(func_int_r)>() << std::endl;\n\tstd::cout << \"func_int_rr is \" << type_name<decltype(func_int_rr)>() << std::endl;\n\tstd::cout << \"func_int is \" << type_name<decltype(func_int)>() << std::endl;\n\n\tconst int& func_cint_r(void);\t//左值\n\tconst int&& func_cint_rr(void);\t//x值\n\tconst int func_cint(void);\t\t//纯右值\n\tconst Foo func_cfoo(void);\t\t//纯右值\n\t\n\tstd::cout << \"func_cint_r() is \" << type_name<decltype(func_cint_r)>() << std::endl;\n\tstd::cout << \"func_cint_rr() is \" << type_name<decltype(func_cint_rr)>() << std::endl;\n\tstd::cout << \"func_cint() is \" << type_name<decltype(func_cint)>() << std::endl;\n\tstd::cout << \"func_cfoo() is \" << type_name<decltype(func_cfoo)>() << std::endl;\n\t\n\treturn EXIT_SUCCESS;\n}\n//////////////////////////////////////\n/// decltype2.cpp file end\n//////////////////////////////////////\n\n//////////////////////////////////////\n/// output result\n//////////////////////////////////////\nfunc_int_r() is int&\nfunc_int_rr() is int&&\nfunc_int() is int\nfunc_cint_r() is const int&\nfunc_cint_rr() is const int&&\nfunc_cint() is int\nfunc_cfoo() is const Foo\n```\ndecltype与函数返回值类型一致，但是如果返回值是纯右值**非类类型**，忽略cv限定符，比如：func_cint；如果返回值是纯右值的**类类型**，保留cv限定符。\n\n例3：其他情况，带括号表达式和加法运算表达式\n``` c++\n//////////////////////////////////////\n/// decltype3.cpp file\n//////////////////////////////////////\n#include <iostream>\n#include \"type_name.h\"\n\nstruct Foo { int x; };\n\nint main(void)\n{\n\tconst Foo foo = Foo();\n\tstd::cout << \"foo.x is \" << type_name<decltype(foo.x)>() << std::endl;\n\tstd::cout << \"(foo.x) is \" << type_name<decltype((foo.x))>() << std::endl;\n\n\tint n = 0,m = 0;\n\tstd::cout << \"n+m is \" << type_name<decltype(n + m)>() << std::endl;\n\tstd::cout << \"n+=m is \" << type_name<decltype(n += m)>() << std::endl;\n\t\n\treturn EXIT_SUCCESS;\n}\n//////////////////////////////////////\n/// decltype3.cpp file end\n//////////////////////////////////////\n\n//////////////////////////////////////\n/// output result\n//////////////////////////////////////\nfoo.x is int\n(foo.x) is const int&\nn+m is int\nn+=m is int&\n```\nfoo.x根据推导规则一，类型是int；(foo.x)是左值，推导出是int&，而foo又是const，所以(foo.x)是const int&；n+m是右值，类型是int；n+=m是左值，类型是int&。\n\n#### decltype应用\ndecltype的应用多出现在泛型编程中。\n\n应用一：\n``` c++\n#include <vector>\n\ntemplate<typename ContainerT>\nclass Foo\n{\n\ttypename ContainerT::iterator it_;\npublic:\n\tvoid func(ContainerT& container)\n\t{\n\t\tit_ = container.begin();\n\t}\n};\n\nint main(void)\n{\n\ttypedef const std::vector<int> container_t;\n\tcontainer_t arr;\n\t\n\tFoo<container_t> foo;\n\tfoo.func(arr);\n\t\n\treturn EXIT_SUCCESS;\n}\n```\n单独看vector没有什么问题，但是如果传入的容器有const限定，那么就会出问题了，因为const容器的迭代器是const_iterator。在C++98/03中的解决方案是，特化一个类模版如下：\n``` c++\ntemplate<typename ContainerT>\nclass Foo<const ContainerT>\n{\n\ttypename ContainerT::const_iterator it_;\npublic:\n\tvoid func(const ContainerT& container)\n\t{\n\t\tit_ = container.begin();\n\t}\n};\n```\n上面的实现略显繁琐，在C++11中只要稍微修改一下类模版Foo即可实现相同功能，如下：\n``` c++\ntemplate<typename ContainerT>\nclass Foo\n{\n\tdecltype(ContainerT().begin()) it_;\npublic:\n\tvoid func(ContainerT& container)\n\t{\n\t\tit_ = container.begin();\n\t}\n};\n```\n这样无论容器是否被const限定都没问题，代码简洁了好多。\n\n### auto和decltype结合使用：返回类型后置语法\n在范型编程中，可能需要通过参数的运算来得到返回值类型。比如：\n``` c++\ntemplate<typename T,typename U>\ndecltype(t+u) add(T t,U u)\n{\n\treturn t+u;\n}\n```\n但是这样编译不过，因为t、u在参数列表中，C++的返回值是前置语法，返回值定义的时候参数变量还不存在。不过可以改成如下：\n``` c++\ntemplate<typename T,typename U>\ndecltype(T()+U()) add(T t,U u)\n{\n\treturn t+u;\n}\n```\n这样看上去没什么问题，但是如果T和U类型没有无参构造函数，依然会有问题，还可以改成下面这样：\n``` c++\ntemplate<typename T,typename U>\ndecltype((*(T*)0) + (*(U*)0)) add(T t,U u)\n{\n\treturn t+u;\n}\n```\n这样确实已经实现了此功能，但是看上去和复杂，而且让人费解，如果使用auto和decltype结合使用可以和简洁的完成此功能：\n``` c++\ntemplate<typename T,typename U>\nauto add(T t,U u) -> decltype(t+u)\n{\n\treturn t+u;\n}\n```\nauto会根据后置的decltype(t+u)类型推导出来，而此时t和u的已经存在，所以没有问题，代码也很简洁，可读性强。\n\n\n### 参考资料\n1. 《深入应用C++11：代码优化和工程应用》\n2. 《C++ Primer》（第五版）\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"C-11特性与应用（一）：C-11语言特性","published":1,"updated":"2016-08-04T07:40:17.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw62003gtkb9ba45sxqv"},{"title":"C++11并发编程（一）","date":"2016-07-22T06:33:15.000Z","_content":"\n## 1.1 何谓并发\n\n最简单和最基本的并发是指两个或更多独立的活动同时发生，在计算机领域，并发指的是在单个系统里同时执行多个独立任务。\n\n计算机并发物理方式：多核并行、单核任务切换以及多核任务切换。\n\n### 1.1.2 并发的途径\n\n并发的两种基本途径：多进程并发和多线程并发。\n\n#### 多进程并发\n将应用程序分为多个独立的进程，使其同时运行，进程间通过常规的通信渠道传递消息（包括信号、套接字、文件、管道等等）。\n\n缺点：\n1. 通信设置复杂或者通信速度慢（慢的原因是操作系统的进程安全保护措施，避免一个进程去修改另一个进程的数据）；\n2. 进程消耗的资源大，主要表现为启动时间长，操作系统需要消耗资源来管理进程。\n\n优点：\n1. 由于操作系统为进程间提供了附加保护操作和更高级别的通信机制，从而能够更容易的编写出安全的并发代码；\n2. 通过网络，使用远程连接方式，在不同机器上运行独立的进程，虽然增加了通信成本，但在设计精良的系统上，这是一个提高并行可用性和性能的低成本方式。\n<!--more-->\n#### 多线程并发\n在单个进程中运行多个相互独立的线程，且线程可以在不同的指令序列中运行，同一进程中的所有线程都是共享地址空间，并且所有线程能访问大部分数据（全局变量仍是全局的，指针、对象的引用或数据可以在线程之间传递）。进程间虽然也能做到共享内存，但是这种共享通常很难建立，因为，同一数据的内存地址在不同进程中是不同的。\n\n优点：地址空间共享，以及缺少线程间数据的保护，减少了操作系统的记录工作，从而是的多线程开销远小于多进程。\n\n缺点：同时，由于是共享内存以及缺少进程间数据的保护，如果数据要被多个线程访问，那么程序员必须保证数据的一致性，从而影响了程序员的开发效率。\n\n#### 多线程与多进程比较\n1. 多进程比多线程开销大；\n2. 多线程已经是C++标准，为线程间通信提过原生支持，更容易编写跨平台代码；\n3. 线程共享地址空间，需要编写更多的代码来确保数据的一致性；\n4. 多进程依赖与平台相关的API，却能编写出更安全的并发代码；\n5. 多进程能够通过网络实现分布式系统，提高并发性和性能。\n\n由于我们是讨论C++的并发，因此，主要是关注多线程并发。\n\n## 1.2 为什么使用并发？\n\n使用并发的主要原因有两点：\n1. 关注点分离（SOC）\n2. 性能\n\n### 1.2.1 为了分离关注点\n分离关注点是：通过将相关代码与无关代码分离，可以是程序更易理解和测试，降低出错率。这种情况关注点是概念上的设计，使得代码更清晰。\n\n### 1.2.2 为了性能\n提高并发性能的两种方式：\n1. 将单一任务分成几个部分，且各自并行运行，从而降低总运行时间，称“任务并行”。根据并行的细节，还可以分为：1）过程并行——多个线程执行算法的不同部分，2）数据并行——通过对多组数据同时执行相同的操作。\n2. 使用并行方式，来解决更大的问题。这是数据并行的一个应用，但是关注点不一样，数据并行强调降低处理的总时间，而此方式关注点是处理使用并行处理更大的问题，甚至是串行难以完成的问题。比如处理大量数据，使用并发提高吞吐量。\n\n### 1.2.3 什么时候不使用并发\n不是用并发的唯一原因是：收益比不上成本。\n1. 除非潜在的性能增益足够大或关注点分离地足够清晰，能抵消所需的额外的开发时间以及与维护多线程代码相关的额外成本(代码正确的前提下)；否则，别用并发。\n2. 性能增益可能会小于预期，比如：产生线程的时间要远大于线程执行时间；\n3. 线程是有限的资源，如果让太多的线程同时运行，则会消耗很多操作系统资源，从而使得操作系统整体上运行得更加缓慢；\n4. 运行越多的线程，操作系统就需要做越多的上下文切换，每个上下文切换都需要耗费本可以花在有价值工作上的时间；\n\n为性能而使用并发就像所有其他优化策略一样:它拥有大幅度提高应用性能的潜力，但它也可能使代码复杂化，使其更难理解，并更容易出错。因此，只有应用中具有显著增益潜力的性能关键部分，才值得并发化。当然，如果性能收益的潜力仅次于设计清晰或关注点分离，可能也值得使用多线程设计。\n\n## 1.3 C++中使的并发和多线程\n\n### 1.3.1 C++多线程历史\n从C语言的平台相关API，到C++面向对象的平台相关API，再到C++面向对象平台无关类库，最后成为C++标准。\n\n### 1.3.2 新标准支持并发\n所有的这些随着C++11标准的发布而改变了,不仅有了一个全新的线程感知内存模型，C++标准库也扩展了：包含了用于管理线程、保护共享数据、线程间同步操作，以及低级原子操作的各种类。\n\n### 1.3.3 C++线程库的效率\n实现使用高级工具和直接低级工具的开销差称为“抽象惩罚”。\n\n多线程效率在C++标准设计之初就一直考虑在内，在大部分主流平台上都能实现高效，有非常低的抽象惩罚。\n\n在非常罕见的情况下，当C++标准库没有提供所需的性能或行为时，就有必要使用平台相关的工具。\n\n### 1.3.4 平台相关的工具\n在C++线程库中提供一个 native_handle() 成员函数，允许通过使用平台相关API直接操作底层实现。\n\n## 1.4 开始入门\n\n### Hello, Concurrent World\n\n``` c++\n#include <iostream>\n#include <thread> \t\t//线程库头文件\nvoid hello() \t\t\t//线程开始函数\n{\n\tstd::cout << \"Hello Concurrent World\\n\";\n} \nint main()\n{\n\tstd::thread t(hello); \t//通过thread对象启动线程\n\tt.join(); \t\t\t\t//等待线程执行完成\n}\n```\n\n\n参考资料：\n1. 《C++ Concurrency In Action》","source":"_posts/C-11并发编程（一）：你好，并发世界.md","raw":"title: C++11并发编程（一）\ntags:\n  - C++11\n  - 并发编程\ncategories:\n  - C++\ndate: 2016-07-22 14:33:15\n---\n\n## 1.1 何谓并发\n\n最简单和最基本的并发是指两个或更多独立的活动同时发生，在计算机领域，并发指的是在单个系统里同时执行多个独立任务。\n\n计算机并发物理方式：多核并行、单核任务切换以及多核任务切换。\n\n### 1.1.2 并发的途径\n\n并发的两种基本途径：多进程并发和多线程并发。\n\n#### 多进程并发\n将应用程序分为多个独立的进程，使其同时运行，进程间通过常规的通信渠道传递消息（包括信号、套接字、文件、管道等等）。\n\n缺点：\n1. 通信设置复杂或者通信速度慢（慢的原因是操作系统的进程安全保护措施，避免一个进程去修改另一个进程的数据）；\n2. 进程消耗的资源大，主要表现为启动时间长，操作系统需要消耗资源来管理进程。\n\n优点：\n1. 由于操作系统为进程间提供了附加保护操作和更高级别的通信机制，从而能够更容易的编写出安全的并发代码；\n2. 通过网络，使用远程连接方式，在不同机器上运行独立的进程，虽然增加了通信成本，但在设计精良的系统上，这是一个提高并行可用性和性能的低成本方式。\n<!--more-->\n#### 多线程并发\n在单个进程中运行多个相互独立的线程，且线程可以在不同的指令序列中运行，同一进程中的所有线程都是共享地址空间，并且所有线程能访问大部分数据（全局变量仍是全局的，指针、对象的引用或数据可以在线程之间传递）。进程间虽然也能做到共享内存，但是这种共享通常很难建立，因为，同一数据的内存地址在不同进程中是不同的。\n\n优点：地址空间共享，以及缺少线程间数据的保护，减少了操作系统的记录工作，从而是的多线程开销远小于多进程。\n\n缺点：同时，由于是共享内存以及缺少进程间数据的保护，如果数据要被多个线程访问，那么程序员必须保证数据的一致性，从而影响了程序员的开发效率。\n\n#### 多线程与多进程比较\n1. 多进程比多线程开销大；\n2. 多线程已经是C++标准，为线程间通信提过原生支持，更容易编写跨平台代码；\n3. 线程共享地址空间，需要编写更多的代码来确保数据的一致性；\n4. 多进程依赖与平台相关的API，却能编写出更安全的并发代码；\n5. 多进程能够通过网络实现分布式系统，提高并发性和性能。\n\n由于我们是讨论C++的并发，因此，主要是关注多线程并发。\n\n## 1.2 为什么使用并发？\n\n使用并发的主要原因有两点：\n1. 关注点分离（SOC）\n2. 性能\n\n### 1.2.1 为了分离关注点\n分离关注点是：通过将相关代码与无关代码分离，可以是程序更易理解和测试，降低出错率。这种情况关注点是概念上的设计，使得代码更清晰。\n\n### 1.2.2 为了性能\n提高并发性能的两种方式：\n1. 将单一任务分成几个部分，且各自并行运行，从而降低总运行时间，称“任务并行”。根据并行的细节，还可以分为：1）过程并行——多个线程执行算法的不同部分，2）数据并行——通过对多组数据同时执行相同的操作。\n2. 使用并行方式，来解决更大的问题。这是数据并行的一个应用，但是关注点不一样，数据并行强调降低处理的总时间，而此方式关注点是处理使用并行处理更大的问题，甚至是串行难以完成的问题。比如处理大量数据，使用并发提高吞吐量。\n\n### 1.2.3 什么时候不使用并发\n不是用并发的唯一原因是：收益比不上成本。\n1. 除非潜在的性能增益足够大或关注点分离地足够清晰，能抵消所需的额外的开发时间以及与维护多线程代码相关的额外成本(代码正确的前提下)；否则，别用并发。\n2. 性能增益可能会小于预期，比如：产生线程的时间要远大于线程执行时间；\n3. 线程是有限的资源，如果让太多的线程同时运行，则会消耗很多操作系统资源，从而使得操作系统整体上运行得更加缓慢；\n4. 运行越多的线程，操作系统就需要做越多的上下文切换，每个上下文切换都需要耗费本可以花在有价值工作上的时间；\n\n为性能而使用并发就像所有其他优化策略一样:它拥有大幅度提高应用性能的潜力，但它也可能使代码复杂化，使其更难理解，并更容易出错。因此，只有应用中具有显著增益潜力的性能关键部分，才值得并发化。当然，如果性能收益的潜力仅次于设计清晰或关注点分离，可能也值得使用多线程设计。\n\n## 1.3 C++中使的并发和多线程\n\n### 1.3.1 C++多线程历史\n从C语言的平台相关API，到C++面向对象的平台相关API，再到C++面向对象平台无关类库，最后成为C++标准。\n\n### 1.3.2 新标准支持并发\n所有的这些随着C++11标准的发布而改变了,不仅有了一个全新的线程感知内存模型，C++标准库也扩展了：包含了用于管理线程、保护共享数据、线程间同步操作，以及低级原子操作的各种类。\n\n### 1.3.3 C++线程库的效率\n实现使用高级工具和直接低级工具的开销差称为“抽象惩罚”。\n\n多线程效率在C++标准设计之初就一直考虑在内，在大部分主流平台上都能实现高效，有非常低的抽象惩罚。\n\n在非常罕见的情况下，当C++标准库没有提供所需的性能或行为时，就有必要使用平台相关的工具。\n\n### 1.3.4 平台相关的工具\n在C++线程库中提供一个 native_handle() 成员函数，允许通过使用平台相关API直接操作底层实现。\n\n## 1.4 开始入门\n\n### Hello, Concurrent World\n\n``` c++\n#include <iostream>\n#include <thread> \t\t//线程库头文件\nvoid hello() \t\t\t//线程开始函数\n{\n\tstd::cout << \"Hello Concurrent World\\n\";\n} \nint main()\n{\n\tstd::thread t(hello); \t//通过thread对象启动线程\n\tt.join(); \t\t\t\t//等待线程执行完成\n}\n```\n\n\n参考资料：\n1. 《C++ Concurrency In Action》","slug":"C-11并发编程（一）：你好，并发世界","published":1,"updated":"2016-08-01T03:51:41.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw64003jtkb9p2ef7uax"},{"title":"《中国互联网地下产业链分析白皮书》阅读笔记（一）","_content":"\n### 一、 地下产业链概述与全貌性导读\n\n在中国的传统行业都有一定的所谓黑市门槛，即属于潜规则范畴或者是不为人知的\n行业秘密，这种信息只流传在最信任的人脉圈子里。中国互联网行业也有黑市门槛，那就是互联网地下产业链，互联网地下产业链并不是消极的事物，在一定程度上讲，它更接近用户需求，更能还原互联网本貌。\n\n#### 中国互联网地下产业链产生原因：\n\n1. 用户需求多样性，主流互联网产品无法满足所有用户需求；\n2. 互联网的高速发展带来了诱人的红利；\n3. 技术成本的不断下降。\n\n#### 研究互联网地下产业链的主要目的和意义：\n\n1. 给我们带来更真实的用户需求启示；\n2. 让我们更好的评估互联网地下产业链在商业游戏中带来的影响；\n3. 互联网地下产业链表现出来的生命力和接地气，对互联网的创业和创新有非常大的学习启示作用。\n\n#### 中国互联网产业链发展现状概述及分析\n\n目前国内互联网产业表现出明显的垄断性，巨头公司垄断了互联网最基础的资源——互联网流量（可以简单理解为用户访问数量）。随着国内互联网的高速发展带来的红利，催高了流量的价格，让互联网红利集中到了少数利益集团手中。目前国内流量主要是被巨头企业垄断，长尾流量被巨头企业采购，巨头们看不上眼的流量被广告联盟占领。\n\n这使得创新有了特别明显的定向性：\n\n 1. 流量强变现能力型创新，这样才能支撑起高额的流量费；\n 2. 资本介入型创新，以此支撑起出早期的发展成本，最典型的就是拉风投。\n \n第一种情况主要是催生了地下产业链的相关变现模式，第二种是比较主流的模式，但是在一定程度上扰乱了市场，原因有二：\n\n1. 风投资本的盈利模式和发展现状所决定；\n2. 由于热点的轮换，加上资本的推波助澜，使得短时间内在细分领域汇集大量的混水摸鱼者，他们最终的产物是一个个动人的故事和一遍遍的概念炒作。而正真的创新者却被推高的流量成本，最终被浮躁的行业环境给吞没，无声无息，进入长时间的黑夜。\n\n国内互联网行业的创新者，大概可以分为三类：\n\n1. 概念投资型：国内互联网的主流，通过媒体炒作，借鉴国外成熟商业模式，拉风投，最终奔着上市和被收购；\n2. 草根灰色型：草根特色，默默赚钱；\n3. 非法黑色型：见不得光、游离在法律边缘，但不是法外之地，有着大量的用户群，高风险，商业模式非常机密。\n\n《中国互联网地下产业链分析白皮书》（下称“白皮书”）主要讨论后两种形态，并且分析后两种形态与第一种形态的关联。\n\n#### 中国互联网地下产业链发展现状及分析\n\n地下产业链的本质：\n1. 独立型：利用目前国内互联网用户对网络的认知水平不同，精心打造产品，进行的各种获利；\n2. 吸附型：吸附于某互联网细分生态系统中，汲取其养分,利用信息差，进行的获利；\n3. 破坏型：利用技术水平的优势，进行破坏、侵权及获利。\n\n中国互联网地下产业链发展到目前阶段，已经渗透到互联网行业几乎所有的细分行业中。《白皮书》基于互联网的生态结构，主要从下面三个方面来分析目前地下产业链的发展现状：\n\n1. 流量获取分发：互联网的最基本的入口；\n2. 流量变现盈利：流量变现是任何互联网创新服务的基本形态，采购流量->提供增值服务->\n变现，也是大多数互联网创新的最基础的原理；\n3. 数据信息安全：除了流量获取分发，和流量变现盈利以外，还有一部分地下产业链在围绕\n数据服务、信息服务、信息与数据安全或是攻击敲诈勒索诈骗上做文章。\n\n通过这三方面的分析，也揭露了搜索结果排名的秘密,被具有诱惑头像的陌生人邀请为好友的原因，被盗后的QQ号（即信封号）的一套处理流程，淘宝刷单，海外代购，微店，游戏，博彩，网络色情诱惑，网络培训与传销，比特币与山寨币，个人信息盗取和贩卖，打码平台等等。\n\n\n","source":"_drafts/《中国互联网地下产业链分析白皮书》阅读笔记.md","raw":"title: 《中国互联网地下产业链分析白皮书》阅读笔记（一）\ntags:\n---\n\n### 一、 地下产业链概述与全貌性导读\n\n在中国的传统行业都有一定的所谓黑市门槛，即属于潜规则范畴或者是不为人知的\n行业秘密，这种信息只流传在最信任的人脉圈子里。中国互联网行业也有黑市门槛，那就是互联网地下产业链，互联网地下产业链并不是消极的事物，在一定程度上讲，它更接近用户需求，更能还原互联网本貌。\n\n#### 中国互联网地下产业链产生原因：\n\n1. 用户需求多样性，主流互联网产品无法满足所有用户需求；\n2. 互联网的高速发展带来了诱人的红利；\n3. 技术成本的不断下降。\n\n#### 研究互联网地下产业链的主要目的和意义：\n\n1. 给我们带来更真实的用户需求启示；\n2. 让我们更好的评估互联网地下产业链在商业游戏中带来的影响；\n3. 互联网地下产业链表现出来的生命力和接地气，对互联网的创业和创新有非常大的学习启示作用。\n\n#### 中国互联网产业链发展现状概述及分析\n\n目前国内互联网产业表现出明显的垄断性，巨头公司垄断了互联网最基础的资源——互联网流量（可以简单理解为用户访问数量）。随着国内互联网的高速发展带来的红利，催高了流量的价格，让互联网红利集中到了少数利益集团手中。目前国内流量主要是被巨头企业垄断，长尾流量被巨头企业采购，巨头们看不上眼的流量被广告联盟占领。\n\n这使得创新有了特别明显的定向性：\n\n 1. 流量强变现能力型创新，这样才能支撑起高额的流量费；\n 2. 资本介入型创新，以此支撑起出早期的发展成本，最典型的就是拉风投。\n \n第一种情况主要是催生了地下产业链的相关变现模式，第二种是比较主流的模式，但是在一定程度上扰乱了市场，原因有二：\n\n1. 风投资本的盈利模式和发展现状所决定；\n2. 由于热点的轮换，加上资本的推波助澜，使得短时间内在细分领域汇集大量的混水摸鱼者，他们最终的产物是一个个动人的故事和一遍遍的概念炒作。而正真的创新者却被推高的流量成本，最终被浮躁的行业环境给吞没，无声无息，进入长时间的黑夜。\n\n国内互联网行业的创新者，大概可以分为三类：\n\n1. 概念投资型：国内互联网的主流，通过媒体炒作，借鉴国外成熟商业模式，拉风投，最终奔着上市和被收购；\n2. 草根灰色型：草根特色，默默赚钱；\n3. 非法黑色型：见不得光、游离在法律边缘，但不是法外之地，有着大量的用户群，高风险，商业模式非常机密。\n\n《中国互联网地下产业链分析白皮书》（下称“白皮书”）主要讨论后两种形态，并且分析后两种形态与第一种形态的关联。\n\n#### 中国互联网地下产业链发展现状及分析\n\n地下产业链的本质：\n1. 独立型：利用目前国内互联网用户对网络的认知水平不同，精心打造产品，进行的各种获利；\n2. 吸附型：吸附于某互联网细分生态系统中，汲取其养分,利用信息差，进行的获利；\n3. 破坏型：利用技术水平的优势，进行破坏、侵权及获利。\n\n中国互联网地下产业链发展到目前阶段，已经渗透到互联网行业几乎所有的细分行业中。《白皮书》基于互联网的生态结构，主要从下面三个方面来分析目前地下产业链的发展现状：\n\n1. 流量获取分发：互联网的最基本的入口；\n2. 流量变现盈利：流量变现是任何互联网创新服务的基本形态，采购流量->提供增值服务->\n变现，也是大多数互联网创新的最基础的原理；\n3. 数据信息安全：除了流量获取分发，和流量变现盈利以外，还有一部分地下产业链在围绕\n数据服务、信息服务、信息与数据安全或是攻击敲诈勒索诈骗上做文章。\n\n通过这三方面的分析，也揭露了搜索结果排名的秘密,被具有诱惑头像的陌生人邀请为好友的原因，被盗后的QQ号（即信封号）的一套处理流程，淘宝刷单，海外代购，微店，游戏，博彩，网络色情诱惑，网络培训与传销，比特币与山寨币，个人信息盗取和贩卖，打码平台等等。\n\n\n","slug":"《中国互联网地下产业链分析白皮书》阅读笔记","published":0,"date":"2016-07-02T13:00:12.923Z","updated":"2016-07-02T13:00:12.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw69003otkb9c4hxmi0b"},{"title":"Web服务器安全策略","_content":"","source":"_drafts/Web服务器安全策略.md","raw":"title: Web服务器安全策略\ntags:\n---\n","slug":"Web服务器安全策略","published":0,"date":"2015-11-30T04:20:14.141Z","updated":"2015-11-30T04:20:14.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirn9sw6d003ptkb9uc386c86"}],"PostAsset":[{"_id":"source/_posts/读书笔记：Ruby篇（二）/图一.png","post":"cirn9svqi0001tkb9mzsbat3u","slug":"图一.png","modified":1},{"_id":"source/_posts/读书笔记：Ruby篇（二）/图三.jpg","post":"cirn9svqi0001tkb9mzsbat3u","slug":"图三.jpg","modified":1},{"_id":"source/_posts/读书笔记：Ruby篇（二）/图二.png","post":"cirn9svqi0001tkb9mzsbat3u","slug":"图二.png","modified":1},{"_id":"source/_posts/读书笔记：Ruby篇（二）/图五.jpg","post":"cirn9svqi0001tkb9mzsbat3u","slug":"图五.jpg","modified":1},{"_id":"source/_posts/读书笔记：Ruby篇（二）/图四.png","post":"cirn9svqi0001tkb9mzsbat3u","slug":"图四.png","modified":1},{"_id":"source/_posts/读书笔记：Ruby篇（三）/图一.jpg","post":"cirn9svti0006tkb9fepb4qb4","slug":"图一.jpg","modified":1},{"_id":"source/_posts/读书笔记：Ruby篇（三）/图三.jpg","post":"cirn9svti0006tkb9fepb4qb4","slug":"图三.jpg","modified":1},{"_id":"source/_posts/读书笔记：Ruby篇（三）/图二.jpg","post":"cirn9svti0006tkb9fepb4qb4","slug":"图二.jpg","modified":1},{"_id":"source/_posts/计算机网络概述/图一.jpg","post":"cirn9svv6000ctkb90cxeprm1","slug":"图一.jpg","modified":1},{"_id":"source/_posts/计算机网络概述/图三.png","post":"cirn9svv6000ctkb90cxeprm1","slug":"图三.png","modified":1},{"_id":"source/_posts/计算机网络概述/图二.png","post":"cirn9svv6000ctkb90cxeprm1","slug":"图二.png","modified":1},{"_id":"source/_posts/计算机网络概述/图五.png","post":"cirn9svv6000ctkb90cxeprm1","slug":"图五.png","modified":1},{"_id":"source/_posts/计算机网络概述/图四.png","post":"cirn9svv6000ctkb90cxeprm1","slug":"图四.png","modified":1},{"_id":"source/_posts/手电筒的启示/图一.png","post":"cirn9svy8000htkb9b6pmn211","slug":"图一.png","modified":1},{"_id":"source/_posts/手电筒的启示/图三.png","post":"cirn9svy8000htkb9b6pmn211","slug":"图三.png","modified":1},{"_id":"source/_posts/手电筒的启示/图二.png","post":"cirn9svy8000htkb9b6pmn211","slug":"图二.png","modified":1},{"_id":"source/_posts/手电筒的启示/图五.png","post":"cirn9svy8000htkb9b6pmn211","slug":"图五.png","modified":1},{"_id":"source/_posts/手电筒的启示/图四.png","post":"cirn9svy8000htkb9b6pmn211","slug":"图四.png","modified":1},{"_id":"source/_posts/常见面试题复习：字符串-二/图一.jpg","post":"cirn9svz0000mtkb9x2fziv6c","slug":"图一.jpg","modified":1},{"_id":"source/_posts/常见面试题复习：字符串-一/图一.png","post":"cirn9svzl000ttkb9lq0iaq7x","slug":"图一.png","modified":1},{"_id":"source/_posts/常见面试题复习：字符串-一/图三.png","post":"cirn9svzl000ttkb9lq0iaq7x","slug":"图三.png","modified":1},{"_id":"source/_posts/常见面试题复习：字符串-一/图二.png","post":"cirn9svzl000ttkb9lq0iaq7x","slug":"图二.png","modified":1},{"_id":"source/_posts/常见面试题复习：字符串-一/图五.png","post":"cirn9svzl000ttkb9lq0iaq7x","slug":"图五.png","modified":1},{"_id":"source/_posts/常见面试题复习：字符串-一/图四.png","post":"cirn9svzl000ttkb9lq0iaq7x","slug":"图四.png","modified":1},{"_id":"source/_posts/单击微信文章进入原文的方法/fengmian.jpg","post":"cirn9sw090014tkb986wtxzd8","slug":"fengmian.jpg","modified":1},{"_id":"source/_posts/单击微信文章进入原文的方法/六一儿童节.png","post":"cirn9sw090014tkb986wtxzd8","slug":"六一儿童节.png","modified":1},{"_id":"source/_posts/单击微信文章进入原文的方法/图一.png","post":"cirn9sw090014tkb986wtxzd8","slug":"图一.png","modified":1},{"_id":"source/_posts/单击微信文章进入原文的方法/图三.png","post":"cirn9sw090014tkb986wtxzd8","slug":"图三.png","modified":1},{"_id":"source/_posts/单击微信文章进入原文的方法/图二.png","post":"cirn9sw090014tkb986wtxzd8","slug":"图二.png","modified":1},{"_id":"source/_posts/单击微信文章进入原文的方法/图五.png","post":"cirn9sw090014tkb986wtxzd8","slug":"图五.png","modified":1},{"_id":"source/_posts/单击微信文章进入原文的方法/图六.png","post":"cirn9sw090014tkb986wtxzd8","slug":"图六.png","modified":1},{"_id":"source/_posts/单击微信文章进入原文的方法/图四.png","post":"cirn9sw090014tkb986wtxzd8","slug":"图四.png","modified":1},{"_id":"source/_posts/别样的进制/图一.png","post":"cirn9sw0s0019tkb9aicrpagh","slug":"图一.png","modified":1},{"_id":"source/_posts/别样的进制/图三.png","post":"cirn9sw0s0019tkb9aicrpagh","slug":"图三.png","modified":1},{"_id":"source/_posts/别样的进制/图二.png","post":"cirn9sw0s0019tkb9aicrpagh","slug":"图二.png","modified":1},{"_id":"source/_posts/别样的进制/图四.png","post":"cirn9sw0s0019tkb9aicrpagh","slug":"图四.png","modified":1},{"_id":"source/_posts/初识Netfilter-iptables/Netfilter-packet-flow.png","post":"cirn9sw1m001ktkb9eqzkx297","slug":"Netfilter-packet-flow.png","modified":1},{"_id":"source/_posts/初识Netfilter-iptables/Netfilter-packet-flow.svg","post":"cirn9sw1m001ktkb9eqzkx297","slug":"Netfilter-packet-flow.svg","modified":1},{"_id":"source/_posts/初识Netfilter-iptables/Netfilter与iptabales关系.png","post":"cirn9sw1m001ktkb9eqzkx297","slug":"Netfilter与iptabales关系.png","modified":1},{"_id":"source/_posts/初识Netfilter-iptables/iptables数据包流程.png","post":"cirn9sw1m001ktkb9eqzkx297","slug":"iptables数据包流程.png","modified":1},{"_id":"source/_posts/初识Netfilter-iptables/iptables策略组成.png","post":"cirn9sw1m001ktkb9eqzkx297","slug":"iptables策略组成.png","modified":1},{"_id":"source/_posts/初识Netfilter-iptables/显式匹配.jpg","post":"cirn9sw1m001ktkb9eqzkx297","slug":"显式匹配.jpg","modified":1},{"_id":"source/_posts/初识Netfilter-iptables/模拟网络.png","post":"cirn9sw1m001ktkb9eqzkx297","slug":"模拟网络.png","modified":1},{"_id":"source/_posts/初识Netfilter-iptables/虚拟机网络配置1.png","post":"cirn9sw1m001ktkb9eqzkx297","slug":"虚拟机网络配置1.png","modified":1},{"_id":"source/_posts/初识Netfilter-iptables/虚拟机网络配置2.png","post":"cirn9sw1m001ktkb9eqzkx297","slug":"虚拟机网络配置2.png","modified":1},{"_id":"source/_posts/初识Netfilter-iptables/虚拟机网络配置3.png","post":"cirn9sw1m001ktkb9eqzkx297","slug":"虚拟机网络配置3.png","modified":1},{"_id":"source/_posts/初识Netfilter-iptables/设置默认网关.png","post":"cirn9sw1m001ktkb9eqzkx297","slug":"设置默认网关.png","modified":1},{"_id":"source/_posts/初识Netfilter-iptables/访问LM服务1.png","post":"cirn9sw1m001ktkb9eqzkx297","slug":"访问LM服务1.png","modified":1},{"_id":"source/_posts/初识Netfilter-iptables/访问LM服务2.png","post":"cirn9sw1m001ktkb9eqzkx297","slug":"访问LM服务2.png","modified":1},{"_id":"source/_posts/初识Netfilter-iptables/隐含匹配.jpg","post":"cirn9sw1m001ktkb9eqzkx297","slug":"隐含匹配.jpg","modified":1},{"_id":"source/_posts/信息编码随想/图一.png","post":"cirn9sw30001vtkb9x9nuw5zf","slug":"图一.png","modified":1},{"_id":"source/_posts/信息编码随想/图三.png","post":"cirn9sw30001vtkb9x9nuw5zf","slug":"图三.png","modified":1},{"_id":"source/_posts/信息编码随想/图二.png","post":"cirn9sw30001vtkb9x9nuw5zf","slug":"图二.png","modified":1},{"_id":"source/_posts/信息编码随想/图五.png","post":"cirn9sw30001vtkb9x9nuw5zf","slug":"图五.png","modified":1},{"_id":"source/_posts/信息编码随想/图六.png","post":"cirn9sw30001vtkb9x9nuw5zf","slug":"图六.png","modified":1},{"_id":"source/_posts/信息编码随想/图四.png","post":"cirn9sw30001vtkb9x9nuw5zf","slug":"图四.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图一.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图一.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图七.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图七.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图三.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图三.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图九.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图九.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图二.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图二.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图二十.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图二十.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图二十一.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图二十一.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图二十三.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图二十三.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图二十二.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图二十二.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图五.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图五.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图八.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图八.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图六.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图六.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十一.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图十一.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十七.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图十七.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十三.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图十三.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十九.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图十九.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十二.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图十二.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十五.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图十五.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十八.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图十八.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十六.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图十六.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图十四.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图十四.png","modified":1},{"_id":"source/_posts/也说“当你输入一个网址，实际会发生什么-”/图四.png","post":"cirn9sw3e001ytkb9gmdyvhoc","slug":"图四.png","modified":1},{"_id":"source/_posts/一个关于递推关系的思考/图一.jpg","post":"cirn9sw4w0021tkb9afd156ry","slug":"图一.jpg","modified":1},{"_id":"source/_posts/一个关于递推关系的思考/图三.png","post":"cirn9sw4w0021tkb9afd156ry","slug":"图三.png","modified":1},{"_id":"source/_posts/一个关于递推关系的思考/图二.jpg","post":"cirn9sw4w0021tkb9afd156ry","slug":"图二.jpg","modified":1},{"_id":"source/_posts/RSA系类（一）：辗转相除法/图一.png","post":"cirn9sw5p002ttkb963cqqvqt","slug":"图一.png","modified":1}],"PostCategory":[{"post_id":"cirn9svqi0001tkb9mzsbat3u","category_id":"cirn9svqk0002tkb9cvb6hzb8","_id":"cirn9svqo0005tkb9dch2gtju"},{"post_id":"cirn9svti0006tkb9fepb4qb4","category_id":"cirn9svqk0002tkb9cvb6hzb8","_id":"cirn9svtk0007tkb9ezqdry08"},{"post_id":"cirn9svu10009tkb9n66k5f61","category_id":"cirn9svqk0002tkb9cvb6hzb8","_id":"cirn9svu2000atkb9aoc2x4my"},{"post_id":"cirn9svv6000ctkb90cxeprm1","category_id":"cirn9svv9000dtkb9v8585wlf","_id":"cirn9svwp000gtkb9vwjgnequ"},{"post_id":"cirn9svy8000htkb9b6pmn211","category_id":"cirn9svya000itkb993opuipu","_id":"cirn9svyc000ltkb9t1q5c6it"},{"post_id":"cirn9svz0000mtkb9x2fziv6c","category_id":"cirn9svz1000ntkb9u2rtkh16","_id":"cirn9svz3000qtkb9muxek2ns"},{"post_id":"cirn9svzl000ttkb9lq0iaq7x","category_id":"cirn9svz1000ntkb9u2rtkh16","_id":"cirn9svzm000utkb96id1hbs4"},{"post_id":"cirn9sw04000xtkb9jwye7ybb","category_id":"cirn9sw05000ytkb9a4ebcigp","_id":"cirn9sw070011tkb9ysw00vlf"},{"post_id":"cirn9sw090014tkb986wtxzd8","category_id":"cirn9sw0a0015tkb9k7wdq7r8","_id":"cirn9sw0b0018tkb9v99zo1y3"},{"post_id":"cirn9sw0s0019tkb9aicrpagh","category_id":"cirn9sw0v001atkb9570oyqm5","_id":"cirn9sw0w001dtkb9wsac7v7p"},{"post_id":"cirn9sw1i001gtkb983gluet6","category_id":"cirn9sw0v001atkb9570oyqm5","_id":"cirn9sw1k001htkb915hxfbqa"},{"post_id":"cirn9sw1m001ktkb9eqzkx297","category_id":"cirn9sw1n001ltkb9sj3h84ke","_id":"cirn9sw1p001otkb9r6ucsjbm"},{"post_id":"cirn9sw30001vtkb9x9nuw5zf","category_id":"cirn9svya000itkb993opuipu","_id":"cirn9sw32001wtkb9y0foln1w"},{"post_id":"cirn9sw3e001ytkb9gmdyvhoc","category_id":"cirn9svv9000dtkb9v8585wlf","_id":"cirn9sw3f001ztkb9p79k0e7v"},{"post_id":"cirn9sw4w0021tkb9afd156ry","category_id":"cirn9svz1000ntkb9u2rtkh16","_id":"cirn9sw4x0022tkb99w8xz8cq"},{"post_id":"cirn9sw530026tkb9761mr0f2","category_id":"cirn9sw550027tkb9byjfr7yh","_id":"cirn9sw57002atkb9dtrm1f9m"},{"post_id":"cirn9sw5f002gtkb9ocv94lnw","category_id":"cirn9sw550027tkb9byjfr7yh","_id":"cirn9sw5g002htkb9tz24qkbf"},{"post_id":"cirn9sw5k002mtkb92kfk23ec","category_id":"cirn9sw550027tkb9byjfr7yh","_id":"cirn9sw5l002ntkb9rf5p968z"},{"post_id":"cirn9sw5p002ttkb963cqqvqt","category_id":"cirn9sw550027tkb9byjfr7yh","_id":"cirn9sw5q002utkb94dh1yc7x"},{"post_id":"cirn9sw5u002ztkb9yxbs0ss8","category_id":"cirn9sw5v0030tkb9k6lbbes6","_id":"cirn9sw5w0033tkb962rxp7ug"},{"post_id":"cirn9sw5y0038tkb9rey5dcc1","category_id":"cirn9sw5z0039tkb9i1lm406h","_id":"cirn9sw60003ctkb9wpoz4n77"},{"post_id":"cirn9sw61003dtkb92w6pcgy1","category_id":"cirn9sw5z0039tkb9i1lm406h","_id":"cirn9sw61003etkb9pdesfczt"},{"post_id":"cirn9sw62003gtkb9ba45sxqv","category_id":"cirn9sw5z0039tkb9i1lm406h","_id":"cirn9sw63003htkb9n81oarbr"},{"post_id":"cirn9sw64003jtkb9p2ef7uax","category_id":"cirn9sw5z0039tkb9i1lm406h","_id":"cirn9sw65003ktkb9gzp6y3br"}],"PostTag":[{"post_id":"cirn9svqi0001tkb9mzsbat3u","tag_id":"cirn9svql0003tkb9gw7mbucu","_id":"cirn9svqn0004tkb9cr3pwoct"},{"post_id":"cirn9svti0006tkb9fepb4qb4","tag_id":"cirn9svql0003tkb9gw7mbucu","_id":"cirn9svtk0008tkb9jefqrc0t"},{"post_id":"cirn9svu10009tkb9n66k5f61","tag_id":"cirn9svql0003tkb9gw7mbucu","_id":"cirn9svu2000btkb91tcv8iak"},{"post_id":"cirn9svv6000ctkb90cxeprm1","tag_id":"cirn9svv9000etkb9qgxo23fz","_id":"cirn9svwp000ftkb9rpj8ov6e"},{"post_id":"cirn9svy8000htkb9b6pmn211","tag_id":"cirn9svyb000jtkb98jvj8l88","_id":"cirn9svyc000ktkb91xn5qyo3"},{"post_id":"cirn9svz0000mtkb9x2fziv6c","tag_id":"cirn9svz1000otkb9svarvjel","_id":"cirn9svz4000rtkb9qjr6iah0"},{"post_id":"cirn9svz0000mtkb9x2fziv6c","tag_id":"cirn9svz3000ptkb90502kj1r","_id":"cirn9svz4000stkb9qm1oeonb"},{"post_id":"cirn9svzl000ttkb9lq0iaq7x","tag_id":"cirn9svz1000otkb9svarvjel","_id":"cirn9svzn000vtkb916dffic8"},{"post_id":"cirn9svzl000ttkb9lq0iaq7x","tag_id":"cirn9svz3000ptkb90502kj1r","_id":"cirn9svzn000wtkb9msmglt3u"},{"post_id":"cirn9sw04000xtkb9jwye7ybb","tag_id":"cirn9sw06000ztkb9xzdsleoq","_id":"cirn9sw070012tkb9mjiknyi8"},{"post_id":"cirn9sw04000xtkb9jwye7ybb","tag_id":"cirn9sw060010tkb92ul36uf4","_id":"cirn9sw070013tkb9cs9ui9d0"},{"post_id":"cirn9sw090014tkb986wtxzd8","tag_id":"cirn9sw0a0016tkb9ihvnwl3h","_id":"cirn9sw0b0017tkb9an4b2jka"},{"post_id":"cirn9sw0s0019tkb9aicrpagh","tag_id":"cirn9sw0v001btkb9dfz76fdv","_id":"cirn9sw0x001etkb96pgl850a"},{"post_id":"cirn9sw0s0019tkb9aicrpagh","tag_id":"cirn9sw0w001ctkb9yjlepstd","_id":"cirn9sw0x001ftkb963kmoaii"},{"post_id":"cirn9sw1i001gtkb983gluet6","tag_id":"cirn9sw0v001btkb9dfz76fdv","_id":"cirn9sw1k001itkb9gw1o3vn4"},{"post_id":"cirn9sw1i001gtkb983gluet6","tag_id":"cirn9sw0w001ctkb9yjlepstd","_id":"cirn9sw1l001jtkb9q0wm75nh"},{"post_id":"cirn9sw1m001ktkb9eqzkx297","tag_id":"cirn9sw1o001mtkb9a7lz6xwb","_id":"cirn9sw1q001rtkb9q0f8gtqt"},{"post_id":"cirn9sw1m001ktkb9eqzkx297","tag_id":"cirn9sw1o001ntkb9fyn4df5z","_id":"cirn9sw1q001stkb99xn1lmpf"},{"post_id":"cirn9sw1m001ktkb9eqzkx297","tag_id":"cirn9sw1p001ptkb97ggfx0vj","_id":"cirn9sw1q001ttkb9bf9sr2o6"},{"post_id":"cirn9sw1m001ktkb9eqzkx297","tag_id":"cirn9sw1p001qtkb9h8czn1r8","_id":"cirn9sw1r001utkb9q7fm5wyr"},{"post_id":"cirn9sw30001vtkb9x9nuw5zf","tag_id":"cirn9svyb000jtkb98jvj8l88","_id":"cirn9sw32001xtkb9gbnbieu4"},{"post_id":"cirn9sw3e001ytkb9gmdyvhoc","tag_id":"cirn9svv9000etkb9qgxo23fz","_id":"cirn9sw3g0020tkb901a0lz5i"},{"post_id":"cirn9sw4w0021tkb9afd156ry","tag_id":"cirn9sw0w001ctkb9yjlepstd","_id":"cirn9sw4y0024tkb9tiaoxjhq"},{"post_id":"cirn9sw4w0021tkb9afd156ry","tag_id":"cirn9sw4x0023tkb9goohx03h","_id":"cirn9sw4y0025tkb9t1564v6u"},{"post_id":"cirn9sw530026tkb9761mr0f2","tag_id":"cirn9sw560028tkb96rnwwtrf","_id":"cirn9sw58002ctkb9wo9a3s1y"},{"post_id":"cirn9sw530026tkb9761mr0f2","tag_id":"cirn9sw0w001ctkb9yjlepstd","_id":"cirn9sw59002dtkb9rt2ky6cy"},{"post_id":"cirn9sw530026tkb9761mr0f2","tag_id":"cirn9sw570029tkb9pfzpci4z","_id":"cirn9sw59002etkb9tsfdssvq"},{"post_id":"cirn9sw530026tkb9761mr0f2","tag_id":"cirn9sw57002btkb97fbcr4es","_id":"cirn9sw5a002ftkb93w03rksc"},{"post_id":"cirn9sw5f002gtkb9ocv94lnw","tag_id":"cirn9sw560028tkb96rnwwtrf","_id":"cirn9sw5h002jtkb96dr2drh5"},{"post_id":"cirn9sw5f002gtkb9ocv94lnw","tag_id":"cirn9sw0w001ctkb9yjlepstd","_id":"cirn9sw5i002ktkb92usv5oqv"},{"post_id":"cirn9sw5f002gtkb9ocv94lnw","tag_id":"cirn9sw5h002itkb9abx1b4gy","_id":"cirn9sw5i002ltkb9aph0lqmy"},{"post_id":"cirn9sw5k002mtkb92kfk23ec","tag_id":"cirn9sw560028tkb96rnwwtrf","_id":"cirn9sw5m002ptkb91lxzcpb0"},{"post_id":"cirn9sw5k002mtkb92kfk23ec","tag_id":"cirn9sw0w001ctkb9yjlepstd","_id":"cirn9sw5m002qtkb9skx8dpjj"},{"post_id":"cirn9sw5k002mtkb92kfk23ec","tag_id":"cirn9sw5l002otkb9n9h4yf82","_id":"cirn9sw5m002rtkb9acqlhnpa"},{"post_id":"cirn9sw5k002mtkb92kfk23ec","tag_id":"cirn9sw57002btkb97fbcr4es","_id":"cirn9sw5n002stkb9yg9ekzlm"},{"post_id":"cirn9sw5p002ttkb963cqqvqt","tag_id":"cirn9sw560028tkb96rnwwtrf","_id":"cirn9sw5q002wtkb9w4bbnpaq"},{"post_id":"cirn9sw5p002ttkb963cqqvqt","tag_id":"cirn9sw0w001ctkb9yjlepstd","_id":"cirn9sw5r002xtkb982pfdw2u"},{"post_id":"cirn9sw5p002ttkb963cqqvqt","tag_id":"cirn9sw5q002vtkb9cvsda5ki","_id":"cirn9sw5r002ytkb9x38bji4i"},{"post_id":"cirn9sw5u002ztkb9yxbs0ss8","tag_id":"cirn9sw5v0031tkb9v2kvqvs3","_id":"cirn9sw5w0035tkb9n776b063"},{"post_id":"cirn9sw5u002ztkb9yxbs0ss8","tag_id":"cirn9sw5v0032tkb9v1z4c3yf","_id":"cirn9sw5x0036tkb9kpsrj675"},{"post_id":"cirn9sw5u002ztkb9yxbs0ss8","tag_id":"cirn9sw5w0034tkb9smhi7kz8","_id":"cirn9sw5x0037tkb9zayjkond"},{"post_id":"cirn9sw5y0038tkb9rey5dcc1","tag_id":"cirn9sw5z003atkb9qecxa13b","_id":"cirn9sw5z003btkb9jl9njcg6"},{"post_id":"cirn9sw61003dtkb92w6pcgy1","tag_id":"cirn9sw5z003atkb9qecxa13b","_id":"cirn9sw62003ftkb99f5b2x43"},{"post_id":"cirn9sw62003gtkb9ba45sxqv","tag_id":"cirn9sw5z003atkb9qecxa13b","_id":"cirn9sw63003itkb9lk1ughpl"},{"post_id":"cirn9sw64003jtkb9p2ef7uax","tag_id":"cirn9sw5z003atkb9qecxa13b","_id":"cirn9sw66003mtkb92nnytvi2"},{"post_id":"cirn9sw64003jtkb9p2ef7uax","tag_id":"cirn9sw65003ltkb9nh3ncafh","_id":"cirn9sw67003ntkb97a05yq63"}],"Tag":[{"name":"Ruby","_id":"cirn9svql0003tkb9gw7mbucu"},{"name":"计算机网络","_id":"cirn9svv9000etkb9qgxo23fz"},{"name":"信息编码","_id":"cirn9svyb000jtkb98jvj8l88"},{"name":"字符串","_id":"cirn9svz1000otkb9svarvjel"},{"name":"笔试题","_id":"cirn9svz3000ptkb90502kj1r"},{"name":"杂谈","_id":"cirn9sw06000ztkb9xzdsleoq"},{"name":"关于博客","_id":"cirn9sw060010tkb92ul36uf4"},{"name":"微信开发","_id":"cirn9sw0a0016tkb9ihvnwl3h"},{"name":"计算机基础","_id":"cirn9sw0v001btkb9dfz76fdv"},{"name":"数学","_id":"cirn9sw0w001ctkb9yjlepstd"},{"name":"iptables","_id":"cirn9sw1o001mtkb9a7lz6xwb"},{"name":"Netfilter","_id":"cirn9sw1o001ntkb9fyn4df5z"},{"name":"防火墙","_id":"cirn9sw1p001ptkb97ggfx0vj"},{"name":"网络","_id":"cirn9sw1p001qtkb9h8czn1r8"},{"name":"笔试","_id":"cirn9sw4x0023tkb9goohx03h"},{"name":"RSA算法","_id":"cirn9sw560028tkb96rnwwtrf"},{"name":"欧拉函数","_id":"cirn9sw570029tkb9pfzpci4z"},{"name":"费马小定理","_id":"cirn9sw57002btkb97fbcr4es"},{"name":"扩展辗转相除法","_id":"cirn9sw5h002itkb9abx1b4gy"},{"name":"中国剩余定理","_id":"cirn9sw5l002otkb9n9h4yf82"},{"name":"辗转相除法","_id":"cirn9sw5q002vtkb9cvsda5ki"},{"name":"教程","_id":"cirn9sw5v0031tkb9v2kvqvs3"},{"name":"总结","_id":"cirn9sw5v0032tkb9v1z4c3yf"},{"name":"Hexo","_id":"cirn9sw5w0034tkb9smhi7kz8"},{"name":"C++11","_id":"cirn9sw5z003atkb9qecxa13b"},{"name":"并发编程","_id":"cirn9sw65003ltkb9nh3ncafh"}]}}