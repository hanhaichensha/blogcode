title: C++11并发编程（一）
tags:
  - C++11
  - 并发编程
categories:
  - C++
date: 2016-07-22 14:33:15
---

## 1.1 何谓并发

最简单和最基本的并发是指两个或更多独立的活动同时发生，在计算机领域，并发指的是在单个系统里同时执行多个独立任务。

计算机并发物理方式：多核并行、单核任务切换以及多核任务切换。

### 1.1.2 并发的途径

并发的两种基本途径：多进程并发和多线程并发。

#### 多进程并发
将应用程序分为多个独立的进程，使其同时运行，进程间通过常规的通信渠道传递消息（包括信号、套接字、文件、管道等等）。

缺点：
1. 通信设置复杂或者通信速度慢（慢的原因是操作系统的进程安全保护措施，避免一个进程去修改另一个进程的数据）；
2. 进程消耗的资源大，主要表现为启动时间长，操作系统需要消耗资源来管理进程。

优点：
1. 由于操作系统为进程间提供了附加保护操作和更高级别的通信机制，从而能够更容易的编写出安全的并发代码；
2. 通过网络，使用远程连接方式，在不同机器上运行独立的进程，虽然增加了通信成本，但在设计精良的系统上，这是一个提高并行可用性和性能的低成本方式。
<!--more-->
#### 多线程并发
在单个进程中运行多个相互独立的线程，且线程可以在不同的指令序列中运行，同一进程中的所有线程都是共享地址空间，并且所有线程能访问大部分数据（全局变量仍是全局的，指针、对象的引用或数据可以在线程之间传递）。进程间虽然也能做到共享内存，但是这种共享通常很难建立，因为，同一数据的内存地址在不同进程中是不同的。

优点：地址空间共享，以及缺少线程间数据的保护，减少了操作系统的记录工作，从而是的多线程开销远小于多进程。

缺点：同时，由于是共享内存以及缺少进程间数据的保护，如果数据要被多个线程访问，那么程序员必须保证数据的一致性，从而影响了程序员的开发效率。

#### 多线程与多进程比较
1. 多进程比多线程开销大；
2. 多线程已经是C++标准，为线程间通信提过原生支持，更容易编写跨平台代码；
3. 线程共享地址空间，需要编写更多的代码来确保数据的一致性；
4. 多进程依赖与平台相关的API，却能编写出更安全的并发代码；
5. 多进程能够通过网络实现分布式系统，提高并发性和性能。

由于我们是讨论C++的并发，因此，主要是关注多线程并发。

## 1.2 为什么使用并发？

使用并发的主要原因有两点：
1. 关注点分离（SOC）
2. 性能

### 1.2.1 为了分离关注点
分离关注点是：通过将相关代码与无关代码分离，可以是程序更易理解和测试，降低出错率。这种情况关注点是概念上的设计，使得代码更清晰。

### 1.2.2 为了性能
提高并发性能的两种方式：
1. 将单一任务分成几个部分，且各自并行运行，从而降低总运行时间，称“任务并行”。根据并行的细节，还可以分为：1）过程并行——多个线程执行算法的不同部分，2）数据并行——通过对多组数据同时执行相同的操作。
2. 使用并行方式，来解决更大的问题。这是数据并行的一个应用，但是关注点不一样，数据并行强调降低处理的总时间，而此方式关注点是处理使用并行处理更大的问题，甚至是串行难以完成的问题。比如处理大量数据，使用并发提高吞吐量。

### 1.2.3 什么时候不使用并发
不是用并发的唯一原因是：收益比不上成本。
1. 除非潜在的性能增益足够大或关注点分离地足够清晰，能抵消所需的额外的开发时间以及与维护多线程代码相关的额外成本(代码正确的前提下)；否则，别用并发。
2. 性能增益可能会小于预期，比如：产生线程的时间要远大于线程执行时间；
3. 线程是有限的资源，如果让太多的线程同时运行，则会消耗很多操作系统资源，从而使得操作系统整体上运行得更加缓慢；
4. 运行越多的线程，操作系统就需要做越多的上下文切换，每个上下文切换都需要耗费本可以花在有价值工作上的时间；

为性能而使用并发就像所有其他优化策略一样:它拥有大幅度提高应用性能的潜力，但它也可能使代码复杂化，使其更难理解，并更容易出错。因此，只有应用中具有显著增益潜力的性能关键部分，才值得并发化。当然，如果性能收益的潜力仅次于设计清晰或关注点分离，可能也值得使用多线程设计。

## 1.3 C++中使的并发和多线程

### 1.3.1 C++多线程历史
从C语言的平台相关API，到C++面向对象的平台相关API，再到C++面向对象平台无关类库，最后成为C++标准。

### 1.3.2 新标准支持并发
所有的这些随着C++11标准的发布而改变了,不仅有了一个全新的线程感知内存模型，C++标准库也扩展了：包含了用于管理线程、保护共享数据、线程间同步操作，以及低级原子操作的各种类。

### 1.3.3 C++线程库的效率
实现使用高级工具和直接低级工具的开销差称为“抽象惩罚”。

多线程效率在C++标准设计之初就一直考虑在内，在大部分主流平台上都能实现高效，有非常低的抽象惩罚。

在非常罕见的情况下，当C++标准库没有提供所需的性能或行为时，就有必要使用平台相关的工具。

### 1.3.4 平台相关的工具
在C++线程库中提供一个 native_handle() 成员函数，允许通过使用平台相关API直接操作底层实现。

## 1.4 开始入门

### Hello, Concurrent World

``` c++
#include <iostream>
#include <thread> 		//线程库头文件
void hello() 			//线程开始函数
{
	std::cout << "Hello Concurrent World\n";
} 
int main()
{
	std::thread t(hello); 	//通过thread对象启动线程
	t.join(); 				//等待线程执行完成
}
```


参考资料：
1. 《C++ Concurrency In Action》