title: C++11特性与应用（二）
tags:
  - C++11
categories:
  - C++
---

### 模板细节

#### 模板右尖括号

在C++98/03范型编程中，模板实例的两个连续右尖括号之间必须加一空格，以免和右移操作符混淆。在C++11中这种限制取消了，不过，要注意的一点是：
``` c++
template<int N>
struct Foo
{
};
int main(void)
{
	Foo<100 >> 2> x;
	return EXIT_SUCCESS;
}
```
在c++98/03中编译是么有问题的，它将Foo<100 >> 2> x理解为Foo<(100 >> 2)> x。但是在C++中编译器会提示错误，因为100 >> 2会先解释为模板的定界符，所以要手动写上括号Foo<(100 >> 2)> x。

#### 模板的别名

**类型别名**是一个名字，它是某种类型的同义词。有两种方法可以定义类型别名，一是传统方法使用关键字**typedef**：
``` c++
typedef double wages;
typedef unsigned int uint_t;
```
typedef只是为某种类型取别名，并没有真的定义一种新的类型，因此，下面这样将不是合法的函数重载：
``` c++
typedef unsigned int uint_t;
void func(unsigned int);
void func(uint_t);			//error:重定义
```
假如我们要定义一个map类型，它的key是固定类型std::string，值可以是int也可以是std::string等类型，该如何定义这么一种类型的map呢？在C++98/03中，可以如下实现：
``` c++
template<typename Val>
struct str_map
{
	typedef std::map<std::string,Val> type;
};

str_map<int>::type map1;		//key是std::string，值是int
str_map<std::string>::type map2	//key是std::string，只是std::string
```
使用C++11的新语法，会使得简洁易懂，如下：
``` c++
template<typename Val>
using str_map_t = std::map<std::string,Val>;

str_map_t<int> map1;			//key是std::string，值是int
str_map_t<std::string> map2;	//key是std::string，值是std::string
```
这种方法叫**别名声明**，同样，别名声明也没有定义新的类型。实际上，using的别名语法覆盖了typedef的全部功能。using定义的str_map_t是一个模板，但是它既不是函数模板，也不是类模板，而是一种新的模板形式：**模板别名**。

#### 函数模板的默认模板参数

在C++98/03中，类模板可以有默认的模板参数，但是函数模板不支持默认参数，在C++11中这种限制被解除了。当所有模板参数都有默认值时，函数模板的调用如同调用普通函数，而对于类模板，即使参数都有默认值，在使用的时候也一定要加“<>”来实例化对象。函数模板的默认模板参数在使用规则上和其他的默认参数有所不同，它没有必要卸载参数列表的最后面。
``` c++
#include <iostream>
#include "type_name.h"

template<typename R = int,typename U>
R func(U val)
{
	std::cout << type_name<decltype(val)>() << std::endl;
	reuturn val;
}

int main(void)
{
	func(123);
	std::cout << type_name<decltype(func(123))>() << std::endl;
	func(123L);
	std::cout << type_name<decltype(func(123L))>() << std::endl;
	func<long>(123)
	std::cout << type_name<decltype(func<long>(123))>() << std::endl;
	return EXIT_SUCCESS;
}

////////////////////////////////////////
/// output result
////////////////////////////////////////
int			//func(123)，val类型是int,即U是int
int			//decltype(func(123))是函数返回类型R,默认int
long		//func(123L),val类型是long，即U是long
int			//decltype(func(123L))是函数返回类型R,默认int
int			//func<long>(123)，val类型是int,即U是int
long		//decltype(func<long>(123))是函数返回类型R,根据模板参数是long
```
从上面可以看出，由于函数调用时，参数是从右往左填充，此时根据func(123)，推导出U是int，R使用默认值；decltype(func<long>(123))函数参数是123推导出U是int，模板参数是long，所以R是long。

### 初始化列表
C++11中能够使用初始化列表进行初始化的只有**聚合类型**。什么是聚合类型呢？聚合类型的定义如下：
1. 类型是一个普通数组（如int[1],char[2],long[3]\[4]）；
2. 类型是一个类（class，struct，union），且
   1）、无用户自定义的构造函数；
   2）、无私有(private)或者(protected)的非静态数据成员；
   3）、无基类；
   4）、无虚函数；
   5）、不能有{}和=直接初始化的非静态数据成员。

例一：普通数组
``` c++
int arr[] = {1,2,3,4,5};
float y[2][3] =
{
	{1,2,3},
	{4,5,6}
};
```
例二：类类型
``` c++
struct Foo
{
	int x;
	double y;
	
};
```































