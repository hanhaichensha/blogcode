title: C++11特性与应用（三）
tags:
  - C++11
categories:
  - C++
---

### 基于范围的for循环

基于范围的for循环非常的简洁，如：
``` c++
#include <iostream>
#include <vector>

// C++11版本
int main(void)
{
        std::vector<int> arr = { 1, 2, 3, 4, 5 };
        for (auto n : arr)
        {
                std::cout << n << std::endl;
        }
        return EXIT_SUCCESS;
}

// C++98/03版本
int main(void)
{
        std::vector<int> arr = { 1, 2, 3, 4, 5 };
		std::vector<int>::iterator it = arr.begin();

        for (; it != arr.end(); ++it)
        {
                std::cout << *it << std::endl;
        }
        return EXIT_SUCCESS;
}
```
相比之下，C++版本更加简洁。

#### 基于范围的for循环使用细节

注意到基于范围的for循环中的auto n，推导出来的是int类型，也就是说**auto推导出来的类型是容器的value_type，而不是迭代器**。

看到for (auto n : arr)这句，有人会怀疑对容器的访问是没取一个值访问一次容器。事实真是这样吗？我们可以用下面的代码验证一下：
``` c++
#include <iostream>
#include <vector>

std::vector<int> arr = { 1, 2, 3 };

std::vector<int>& get_range(void)
{
        std::cout << __FUNCTION__ << std::endl;
        return arr;
}

int main(void)
{
        for (auto val : get_range())
        {
                std::cout << val << std::endl;
        }
        return EXIT_SUCCESS;
}
//////////////////////////////////////
/// output result
//////////////////////////////////////
get_range
1
2
3
```
从上面的结果可以看出，for (auto val : get_range())对容器只访问了一次。说明**基于范围的for循环，冒号后面的表达式只会被执行一次**

在遍历时，对容器进行修改的情况：
``` c++
#include <iostream>
#include <vector>

int main(void)
{
        std::vector<int> arr = { 1, 2, 3 };
        for(auto val : arr)
        {
                std::cout << val << std::endl;
                arr.push_back(0);
        }
		std::cout << "==================================" << std::endl;for(auto val : arr)
        {
                std::cout << val << std::endl;
        }
        return EXIT_SUCCESS;
}
///////////////////////////////////////////
/// output result
///////////////////////////////////////////
1
2
3
==================================
1
2
3
0
0
0

``` 
上面输出结果是在gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1)环境下的输出结果。对于同的编译器有不同的结果，随意在遍历容器时，尽量不要修改容器。而且可以看来上面的第一次变量虽然改变了容器，但是，遍历次数并没有增加。基于范围的for循环其实是普通for循环的语法糖，它等效下面的循环(参考ISO/IEC 14882 2014, 6.5.4 The range-based for statement)：
``` c++
std::vector<int> arr = { 1, 2, 3 };
for(auto val : arr)
{
        std::cout << val << std::endl;
        arr.push_back(0);
}
//上面几句，等效于下面语句
std::vector<int> arr = { 1, 2, 3 };
{
	auto && __range = (arr);
	for ( auto __begin = __range.begin(),__end = __range.end(); __begin != __end; ++__begin ) 
	{
		auto val = *__begin;
		std::cout << val << std::endl;
        arr.push_back(0);
	}
}
```
通过上面的分析，我们知道只要一个容器实现了如下功能就能自定义一个容器，使得它也可以使用基于范围的for循环：
1. 容器要提供begin()和end()接口，返回一个该容器的迭代器；
2. 容器的迭代器，实现重载前置++、解引用*和!=运算符；
