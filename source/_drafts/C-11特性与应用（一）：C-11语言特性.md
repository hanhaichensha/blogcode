title: C++11特性与应用（一）：C++11语言特性
tags:
  - C++11
  - 并发编程
categories:
  - C++
---

C++11相对于C++98/03有一下几点显著增强：
1. 通过内存模型、线程、原子操作等来支持本地并行编程；
2. 通过同一初始化表达式、auto、decltype、移动语义等来同一对泛型编程的支持；
3. 通过constexpr、POD（概念）等更好地支持系统编程；
4. 通过内联命名空间、继承构造函数和右值引用等，以更好地支持库的构建。

## 1、C++11改进我们的程序

### 1.1 类型推导

### 1、auto类型推导
编程时常常需要把表达式赋值给变量，这就要求在声明变量的时候清除地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11引入了**auto**类型说明符，用它就能让编译器（说明这个过程是编译阶段完成）替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符不同，auto让编译器通过初始值来推算变量的类型。显然，**auto定义的变量必须有初始值**。

#### 顶层const和底层const
我们都知道指针本身是一个对象，它又可以指向另一个对象。因此，指针本身是不是常量和指针所指向的对象是不是常量就是两个相互独立的问题。用名词**顶层const（top-level const）**表示指针本身是一个常量，而**底层const（low-level const）**表示指针所指向的对象是一个常量。

更一般的，**顶层const**可以表示任意的对象是常量，这一点对任何书籍类型都适用，如算术类型、类、指针等。**底层const**则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点与其他类型相比区别明显：
``` c++
int i = 0;
int *const p1 = &i;		//不能改变p1的值，这是一个顶层const
const int ci = 42;		//不能改变ci的值，这是一个顶层const
const int *p2 = &ci;	//允许改变p2的值，这是一个底层const
const int *const p3=p2; //右边的const是顶层const，左边的const是底层const
const int &r = ci;		//用于声明引用的const都是底层const
```

#### 推导规则：
1. 当不声明为指针或引用时，auto的推到结果和初始化表达式抛弃引用和cv（const和volatile限定符）限定符后类型一致，就是抛弃引用和顶层的cv；
2. 当声明为指针或引用时，auto的推导结果将保持初始表达式的cv属性，也就是保存底层cv。

例如：
``` c++
int x = 0;

auto *a = &x;			//a ->int *
auto  b = &x;			//b ->int *
auto &c =  x;			//c ->int &
auto  d =  c;			//d ->int,根据规则1,丢掉了引用

const auto e = x;		//e ->const int
auto f = e;				//f ->int,根据规则1,丢到了const
auto i = &e;			//i ->const int *,根据规则2,保持const属性

const auto &g = x;		//g ->const int &
auto &h = g;			//h ->const int &,根据规则2,保持const属性


const auto *v = &x, u = 6;		//OK,v是const int*类型，u是const int类型
const auto *m = &x, n = 6.0;	//error,从m推导出auto是int，从n推导出auto是double，产生二义性
auto int r;						//error,auto不再表示存储类型指示符
auto s;							//error,auto只是占位符，并不代表实际类型，必须要有初始值
```

需要注意以下几点：
1. const auto *v=&x推导出v的类型是const int \*类型，但是u仍然必须要写**u=6**，否则编译通不过。
2. u的初始化不能是编译器推导产生二义性。例如把u的初始化成**u=6.0**，编译器将会报错。
3. 在旧标准中，auto表示存储类型指示符（包括static，register、mutable等），但是在新标准中auto不再表示存储类型指示符，而是表示为类型指示符，用来提示编译器对变量类型做自动类型推导。

#### auto的限制
1. 不能用于函数参数类型推导；
2. 不能用于非静态成员变量的类型推导；
3. 不能用于数组类型推导；
4. 不能用于模版参数类型推导；
``` c++
void func(auto a =1){}				//error:auto不能用于函数参数类型推导

struct Foo
{
	auto var1_ = 0;					//error:auto不能用于非静态成员变量类型推导
	static const auto var2_ = 0;	//OK:var2_ 是static const int
};

template <typename T>
struct Bar {};

int main(void)
{
	int arr[10] = {0};
	auto aa     = arr;				//OK:aa是int *
	auto rr[10] = arr;				//error:auto无法定义数组
	Bar<int> bar;
	Bar<auto> bb = bar;				//error:auto无法推导模版参数类型

	return EXIT_SUCCESS;
}
```
在类中，auto仅能推导出static const的整数类型或者枚举成员，因为其他静态类型在C++标准中无法就地初始化。虽然C++11中可以接受非静态成员变量就地初始化，却不支持auto类型非静态成员变量的初始化。

#### auto的使用

在C++98/03，我们最常用的遍历容器元素操作如下代码：
``` c++
#include <map>

int main(void)
{
	std::map<double,double> resultMap;
	...
	std::map<double,double>::iterator it = resultMap.begin();
	for (;it != resultMap.end(); ++it)
	{
		...
	}
	return EXIT_SUCCESS;
}
```
再来看看C++11中使用auto的代码：
``` c++
#include <map>

int main(void)
{
	std::map<double,double> resultMap;
	...
	for (auto it = resultMap.begin(); it != resultMap.end(); ++it)
	{
		...
	}
	return EXIT_SUCCESS;
}
```
代码简洁很多，再也不用写长长的迭代器类型了。

再看一个使用auto简化函数定义的示例：
``` c++
class Foo
{
public:
	static int get(void)
	{
		return 0;
	}
};

class Bar
{
public:
	static const char* get(void)
	{
		return "0";
	}
};

template<typename T>
void func(void)
{
	auto val = T::get();
	...
}

int main(void)
{
	func<Foo>();
	func<Bar>();
	retunr EXIT_SUCCESS;
}
```
多亏了auto，不然我们就得如下实现func函数：
``` c++
...

template<typename T1,typename T2>
void func(void)
{
	T2 val = T1::get();
	...
}

int main(void)
{
	func<Foo,int>();
	func<Bar,char*>();
	return EXIT_SUCCESS;
}
```
auto虽然能带来方便，但是如果滥用将会使得代码可读性下降，代码维护难道增大。

### 2、decltype类型指示符

有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始变量。在C++11中引入了类型说明符**decltype**，它的作用是选择并返回操作书的数据类型。此过程中，编译器（发生在编译阶段）分析表达式并得到它的类型，却不实际计算表达式的值。而auto只能根据变量的初始化表达式推导出变量应该具有的类型。

#### 推导规则：
decltype将精确地推导出表达式定义本身的类型，不舍弃引用和cv限定符。
















